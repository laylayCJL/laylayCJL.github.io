<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>laylayCJL&#39;s Blog</title>
  
  
  <link href="https://laylaycjl.github.io/atom.xml" rel="self"/>
  
  <link href="https://laylaycjl.github.io/"/>
  <updated>2024-04-28T09:17:08.306Z</updated>
  <id>https://laylaycjl.github.io/</id>
  
  <author>
    <name>laylayCJL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux文件权限管理</title>
    <link href="https://laylaycjl.github.io/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>https://laylaycjl.github.io/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</id>
    <published>2024-04-28T07:42:50.000Z</published>
    <updated>2024-04-28T09:17:08.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、文件访问权限和用户种类"><a href="#一、文件访问权限和用户种类" class="headerlink" title="一、文件访问权限和用户种类"></a>一、文件访问权限和用户种类</h1><h2 id="1、文件访问权限"><a href="#1、文件访问权限" class="headerlink" title="1、文件访问权限"></a>1、文件访问权限</h2><h3 id="（1）用ls查看时，显示内容说明："><a href="#（1）用ls查看时，显示内容说明：" class="headerlink" title="（1）用ls查看时，显示内容说明："></a>（1）用ls查看时，显示内容说明：</h3><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428154306993.png" style="zoom: 67%;"></p><p>权限说明：</p><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428155458149.png" alt="image-20240428155458149" style="zoom:50%;"></p><h3 id="（2）文件权限分类"><a href="#（2）文件权限分类" class="headerlink" title="（2）文件权限分类"></a>（2）文件权限分类</h3><div class="table-container"><table><thead><tr><th><strong>权限</strong></th><th><strong>文件的存取权限</strong></th><th><strong>目录的存取权限</strong></th></tr></thead><tbody><tr><td>r</td><td>具有<strong>读</strong>文件的权限</td><td>对文件：能查看文件内容（cat、less、head、tail、ls、more命令可以执行）  对目录：可以查看目录内容</td></tr><tr><td>w</td><td>具有<strong>写</strong>文件的权限</td><td>能创建和删除文件（比如：在文件夹下面，使用touch命令创建文件）</td></tr><tr><td>x</td><td>具有<strong>执行</strong>文件的权限</td><td>能使用该目录下的文件（如cd命令），能进入该目录</td></tr></tbody></table></div><span id="more"></span><h5 id="1-读权限举例："><a href="#1-读权限举例：" class="headerlink" title="1))读权限举例："></a>1))读权限举例：</h5><ul><li><p>对文件来说jack用户没有对test.sh的任何权限</p><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428160749491.png" alt="image-20240428160749491" style="zoom:67%;"></p><p>给jack用户增加权限之后，就可以查看相应内容</p><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428160908250.png" alt="image-20240428160908250" style="zoom: 50%;"></p></li><li><p>对目录来说，jack文件没有对tom目录的读权限，增加权限之后，可读</p><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428160150911.png" alt="image-20240428160150911" style="zoom: 50%;"></p></li></ul><h5 id="2-写权限举例"><a href="#2-写权限举例" class="headerlink" title="2))写权限举例"></a>2))写权限举例</h5><ul><li><p>对文件来说，没有写权限，显示为readonly，给jack加上写权利后，就可以写文件了</p><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428161521690.png" alt="image-20240428161521690" style="zoom:67%;"></p></li><li><p>对于目录来说，没有写权限，就无法mkdir，rmdir目录，也无法创建文件，无法移动和复制</p><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428161715454.png" alt="image-20240428161715454" style="zoom:67%;"></p></li></ul><h5 id="3-可执行权限举例："><a href="#3-可执行权限举例：" class="headerlink" title="3))可执行权限举例："></a>3))可执行权限举例：</h5><ul><li>对于文件来说，没有执行权限就无法运行该文件</li></ul><h2 id="2、用户分类"><a href="#2、用户分类" class="headerlink" title="2、用户分类"></a>2、用户分类</h2><p>对于文件来说用户分为三类</p><ul><li>owner：所有者，一般这个文件谁创建，谁就是owner</li><li>group：组用户，谁创建了文件，这个用户的<strong>主组</strong>就是文件所属组</li><li>others：其他用户，既不是所有者，也不是组用户</li></ul><h1 id="二、修改文件访问权限-chmod"><a href="#二、修改文件访问权限-chmod" class="headerlink" title="二、修改文件访问权限==chmod=="></a>二、修改文件访问权限==chmod==</h1><ul><li>==谁可以改变文件访问权限？root和owner==</li></ul><h2 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">语法：chmod [who][operation][permission] filename</span><br><span class="line">例如：chmod u+x file01</span><br><span class="line"></span><br><span class="line">who项表示用户类型，它的内容为以下一项或多项</span><br><span class="line">u                     拥有者（user --owner）</span><br><span class="line">g                     与拥有者同一组的用户（group）</span><br><span class="line">o                     其他人（other）</span><br><span class="line">a                     所有人（all）</span><br><span class="line"></span><br><span class="line">operiation项表示动作</span><br><span class="line">+                          表示要加上permission指定的权限</span><br><span class="line">-                          表示要取消permission指定的权限</span><br><span class="line"></span><br><span class="line">permission项为存取权限，它的内容为以下一项或多项</span><br><span class="line">r                         表示可读</span><br><span class="line">w                        表示可写</span><br><span class="line">x                         表示可执行</span><br></pre></td></tr></tbody></table></figure><h2 id="2、三种写法"><a href="#2、三种写法" class="headerlink" title="2、三种写法"></a>2、三种写法</h2><h3 id="（1）增加-、减少-权限"><a href="#（1）增加-、减少-权限" class="headerlink" title="（1）增加+、减少-权限"></a>（1）增加<code>+</code>、减少<code>-</code>权限</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">针对file01，给其他用户加一个可执行权限</span><br><span class="line">chmod o+x file01</span><br><span class="line"></span><br><span class="line">针对文件file01，给其他用户和组用户增加写权限</span><br><span class="line">chmod og+w file01</span><br><span class="line"></span><br><span class="line">针对文件file01，给owner用户增加读写执行权限，给组用户可读可写权限，其他用户执行权限(用逗号隔开)</span><br><span class="line">chmod u+rwx,g+rw,o+x file01</span><br><span class="line"></span><br><span class="line">针对文件file01，给其他用户取消写权限</span><br><span class="line">chmod o-w file01</span><br></pre></td></tr></tbody></table></figure><h3 id="（2）-，赋予权限，不关心原始权限"><a href="#（2）-，赋予权限，不关心原始权限" class="headerlink" title="（2）=，赋予权限，不关心原始权限"></a>（2）=，赋予权限，不关心原始权限</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">针对文件file01，给owner用户增加读写执行权限，给组用户可读可写权限，其他用户执行权限(用逗号隔开)</span><br><span class="line">chmod u=rwx,g=rw,o=x file01</span><br></pre></td></tr></tbody></table></figure><h3 id="（3）r、w、x分别用4、2、1数字来表示"><a href="#（3）r、w、x分别用4、2、1数字来表示" class="headerlink" title="（3）r、w、x分别用4、2、1数字来表示"></a>（3）r、w、x分别用4、2、1数字来表示</h3><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428165537604.png" alt="image-20240428165537604" style="zoom:50%;"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">owner用户、group用户和其他用户权限均可读可写可执行：</span><br><span class="line">chmod 777 file01</span><br><span class="line"></span><br><span class="line">owner用户可读可写可执行、group用户可读可写、其他用户可读可执行</span><br><span class="line">chmod 765 file01</span><br><span class="line"></span><br><span class="line">0：什么权限都没有</span><br><span class="line">1：可执行</span><br><span class="line">2：可写</span><br><span class="line">3：可写可执行</span><br><span class="line">4：可读</span><br><span class="line">5：可读可执行</span><br><span class="line">6：可读可写</span><br><span class="line">7：可读可写可执行</span><br></pre></td></tr></tbody></table></figure><h1 id="三、修改文件所属用户和所属组-chown"><a href="#三、修改文件所属用户和所属组-chown" class="headerlink" title="三、修改文件所属用户和所属组==chown=="></a>三、修改文件所属用户和所属组==chown==</h1><p>谁可以改变文件的所有者和所属组？</p><p>==只有root用户，owner都不行==</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">语法：chown [参数] [用户]:[组] 文件</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-R：级联修改，递归</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">只修改文件所属者：把文件file01的所有者改成jack：</span><br><span class="line">chown jack file01</span><br><span class="line">只修改文件的所属组：把文件file01的所属组改成jack：</span><br><span class="line">chown :jack file01</span><br><span class="line">把文件file02的所有者改成jack，所属组改成jack：</span><br><span class="line">chown jack:jack file02</span><br><span class="line"></span><br><span class="line">把目录dir01以及下面所有的子目录和文件的所有者改成jack：</span><br><span class="line">chown -R jack dir01</span><br><span class="line">把目录dir01以及下面所有的子目录和文件的所属组改成jack：</span><br><span class="line">chown -R :jack dir01</span><br><span class="line">把目录dir02以及下面所有的子目录和文件的所有者改成jack，所属组改成jack：</span><br><span class="line">chown -R jack:jack dir02</span><br><span class="line"></span><br><span class="line">不加-R：chown jack dir01：只修改dir01这个目录的所有者，子目录和文件不修改</span><br></pre></td></tr></tbody></table></figure><h1 id="四、只修改文件所属组-chgrp"><a href="#四、只修改文件所属组-chgrp" class="headerlink" title="四、只修改文件所属组==chgrp=="></a>四、只修改文件所属组==chgrp==</h1><p><strong>chown可以替代chgrp</strong></p><p>谁可以改变文件的所属组？</p><p>==root，owner（只能改变到owner所在的组）==</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chgrp</span><br><span class="line">语法：chgrp [选项]…[组] 文件</span><br><span class="line">举例：chgrp jack file01把file01的所属组改成jack</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、文件访问权限和用户种类&quot;&gt;&lt;a href=&quot;#一、文件访问权限和用户种类&quot; class=&quot;headerlink&quot; title=&quot;一、文件访问权限和用户种类&quot;&gt;&lt;/a&gt;一、文件访问权限和用户种类&lt;/h1&gt;&lt;h2 id=&quot;1、文件访问权限&quot;&gt;&lt;a href=&quot;#1、文件访问权限&quot; class=&quot;headerlink&quot; title=&quot;1、文件访问权限&quot;&gt;&lt;/a&gt;1、文件访问权限&lt;/h2&gt;&lt;h3 id=&quot;（1）用ls查看时，显示内容说明：&quot;&gt;&lt;a href=&quot;#（1）用ls查看时，显示内容说明：&quot; class=&quot;headerlink&quot; title=&quot;（1）用ls查看时，显示内容说明：&quot;&gt;&lt;/a&gt;（1）用ls查看时，显示内容说明：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428154306993.png&quot; style=&quot;zoom: 67%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;权限说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428155458149.png&quot; alt=&quot;image-20240428155458149&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;（2）文件权限分类&quot;&gt;&lt;a href=&quot;#（2）文件权限分类&quot; class=&quot;headerlink&quot; title=&quot;（2）文件权限分类&quot;&gt;&lt;/a&gt;（2）文件权限分类&lt;/h3&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;权限&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;文件的存取权限&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;目录的存取权限&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;具有&lt;strong&gt;读&lt;/strong&gt;文件的权限&lt;/td&gt;
&lt;td&gt;对文件：能查看文件内容（cat、less、head、tail、ls、more命令可以执行）  对目录：可以查看目录内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;具有&lt;strong&gt;写&lt;/strong&gt;文件的权限&lt;/td&gt;
&lt;td&gt;能创建和删除文件（比如：在文件夹下面，使用touch命令创建文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;具有&lt;strong&gt;执行&lt;/strong&gt;文件的权限&lt;/td&gt;
&lt;td&gt;能使用该目录下的文件（如cd命令），能进入该目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Linux" scheme="https://laylaycjl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>用户管理</title>
    <link href="https://laylaycjl.github.io/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>https://laylaycjl.github.io/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</id>
    <published>2024-04-28T06:01:09.000Z</published>
    <updated>2024-04-28T08:36:45.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、用户和用户组"><a href="#一、用户和用户组" class="headerlink" title="一、用户和用户组"></a>一、用户和用户组</h1><h3 id="1、用户、用户组概念"><a href="#1、用户、用户组概念" class="headerlink" title="1、用户、用户组概念"></a>1、用户、用户组概念</h3><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428141914666.png" alt="image-20240428141914666" style="zoom:50%;"></p><ul><li><p>Linux是一个多用户的操作系统</p></li><li><p>任何一个要使用系统资源的用户，必须登录进入系统</p></li><li><p>Linux用户属于一个或多个特定的组，称为用户组，即group</p></li></ul><h3 id="2、为什么分组"><a href="#2、为什么分组" class="headerlink" title="2、为什么分组"></a>2、为什么分组</h3><ul><li><p>资源访问控制：文件（泛义上的文件）</p></li><li><p>所有文件都属于一个特定的用户，和一个特定的用户组</p></li><li><p>每个文件都有一定的访问权限，用户限制不同用户和用户组的访问行为</p></li></ul><h3 id="3、用户和用户组的关系"><a href="#3、用户和用户组的关系" class="headerlink" title="3、用户和用户组的关系"></a>3、用户和用户组的关系</h3><ul><li><p><strong>多对多</strong>的关系</p><p>Linux系统以组Group方式管理用户，用户和组的对应关系为多对多，即某个用户可属于一个或多个组，某个组可以有0个、1个或多个用户。</p></li><li><p>组的分类</p><p>从用户的角度，分为主组和附属组：</p><ul><li><strong>主组</strong>：也被称为primary group、first group或initial login group，用户的默认组，用户的gid所标识的组</li><li><strong>附属组</strong>：也被称为Secondary group或supplementary group，用户的附加组</li><li><strong>用户必须有且只能有一个主组，就可以有0个、1个或多个附属组</strong>，如我们一定会有一个用来安家的房子（类同主组），还可以有n个用于投资或其他打算的房子（附属组）</li></ul></li></ul><h3 id="4、用户分类"><a href="#4、用户分类" class="headerlink" title="4、用户分类"></a>4、用户分类</h3><p>（1）root用户：超级管理员用户，具有操作系统的最大权限</p><p>（2）普通用户：由超级用户创建及授权，并且可以登录到Linux系统执行某些任务</p><p>（3）系统用户：系统内创建了若干用户，如mail、ftp、bin等，默认情况下，系统用户都是无法登录的</p><span id="more"></span><h1 id="二、用户管理操作"><a href="#二、用户管理操作" class="headerlink" title="二、用户管理操作"></a>二、用户管理操作</h1><h3 id="1、查看用户和组信息"><a href="#1、查看用户和组信息" class="headerlink" title="1、查看用户和组信息"></a>1、查看用户和组信息</h3><h4 id="（1）查看用户-cat-etc-passwd"><a href="#（1）查看用户-cat-etc-passwd" class="headerlink" title="（1）查看用户==cat /etc/passwd=="></a>（1）查看用户==cat /etc/passwd==</h4><h5 id="1）查看所有用户"><a href="#1）查看所有用户" class="headerlink" title="1）查看所有用户"></a>1）查看所有用户</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></tbody></table></figure><ul><li>用户展现顺序：</li></ul><p>==超级管理员（id为0）—— &gt; 系统用户（id为1到999）：nologin ——&gt; 普通用户（id从1000开始）==</p><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428140839244.png" alt="image-20240428140839244" style="zoom:50%;"></p><ul><li>查询结果含义解释：</li></ul><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428151416824.png" alt="image-20240428151416824" style="zoom:80%;"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root：用户名</span><br><span class="line">x：密码</span><br><span class="line">0：用户id</span><br><span class="line">0：用户组id</span><br><span class="line">root：</span><br><span class="line">/root：该用户的家目录路径</span><br><span class="line">/bin/bash：用户默认的shell</span><br></pre></td></tr></tbody></table></figure><h5 id="2）查看某个用户信息："><a href="#2）查看某个用户信息：" class="headerlink" title="2）查看某个用户信息："></a>2）查看某个用户信息：</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | grep clj</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428151541979.png" alt="image-20240428151541979" style="zoom:50%;"></p><h4 id="（2）查看组-cat-etc-group"><a href="#（2）查看组-cat-etc-group" class="headerlink" title="（2）查看组==cat /etc/group=="></a>（2）查看组==cat /etc/group==</h4><h5 id="1）查看所有组"><a href="#1）查看所有组" class="headerlink" title="1）查看所有组"></a>1）查看所有组</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group</span><br></pre></td></tr></tbody></table></figure><h5 id="2）查看zhangsan的用户组"><a href="#2）查看zhangsan的用户组" class="headerlink" title="2）查看zhangsan的用户组"></a>2）查看zhangsan的用户组</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | grep zhangsan</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428144414279.png" alt="image-20240428144414279" style="zoom:67%;"></p><h3 id="2、添加用户-useradd"><a href="#2、添加用户-useradd" class="headerlink" title="2、添加用户==useradd=="></a>2、添加用户==useradd==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名 [-g用户组名][-d家目录]</span><br><span class="line">-g：指明用户所属组，该用户组必须存在</span><br><span class="line">-d：可以指定用户的家目录，如果没有指定，那么默认家目录在/home</span><br></pre></td></tr></tbody></table></figure><p>该命令完成的事情：（默认没有指定<code>-g</code>和<code>-d</code>）</p><ul><li><p>在/etc/passwd文件中增加一行数据，表示该用户的信息</p></li><li><p>为该用户<strong>创建用户组</strong>，将该用户标识符加在/etc/group文件中，如果有-g选项，则不创建用户组，而是将该用户加入指定组中</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group 可以查询用户组</span><br></pre></td></tr></tbody></table></figure></li><li><p>为该用户<strong>创建一个家目录</strong>（home directory），将家目录的拥有者改为该用户所有</p></li></ul><h3 id="3、设置、修改用户密码-passwd"><a href="#3、设置、修改用户密码-passwd" class="headerlink" title="3、设置、修改用户密码==passwd=="></a>3、设置、修改用户密码==passwd==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 用户名</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428142357737.png" alt="image-20240428142357737" style="zoom:50%;"></p><ul><li>创建了用户之后，其密码是随机的</li><li>用户可以修改自己的密码（需要输入当前密码）</li><li>只有root用户可以修改其他用户密码</li></ul><h3 id="4、修改用户所属组-usermod"><a href="#4、修改用户所属组-usermod" class="headerlink" title="4、修改用户所属组==usermod=="></a>4、修改用户所属组==usermod==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">usermod</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-g修改主组</span><br><span class="line">-G修改附属组</span><br><span class="line">-a增加附属组</span><br><span class="line">-L lock锁定</span><br><span class="line">-U unlock解锁</span><br></pre></td></tr></tbody></table></figure><p><code>-g</code> 修改主组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g root jim //修改用户jim的主组为root</span><br></pre></td></tr></tbody></table></figure><p><code>-G</code> 修改附属组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -G g2,g3 jim //修改用户jim的附属组为g2、g3</span><br></pre></td></tr></tbody></table></figure><p><code>-a</code>增加附属组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -a -G g4 jim //增加用户jim的附属组g4</span><br></pre></td></tr></tbody></table></figure><p><code>-L</code> lock锁定</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -L jim //锁定jim用户，锁定后该用户不能再登录</span><br></pre></td></tr></tbody></table></figure><p><code>-U</code> unlock解锁</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -U jim //解锁jim用户，解锁后该用户可以再登录</span><br></pre></td></tr></tbody></table></figure><h3 id="5、删除用户-userdel"><a href="#5、删除用户-userdel" class="headerlink" title="5、删除用户==userdel=="></a>5、删除用户==userdel==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userdel 用户名</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-r：加-r删除更彻底</span><br></pre></td></tr></tbody></table></figure><p>不加<code>-r</code> 删除用户时，删除不彻底，家目录和邮箱目录都在：</p><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428144709336.png" alt="image-20240428144709336" style="zoom:50%;"></p><p>加<code>-r</code> 删除用户时，是彻底删除：</p><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428145008963.png" alt="image-20240428145008963" style="zoom:50%;"></p><h3 id="6、查询用户"><a href="#6、查询用户" class="headerlink" title="6、查询用户"></a>6、查询用户</h3><p>用户可以使用下列指令查询用户相关信息</p><h4 id="（1）-who"><a href="#（1）-who" class="headerlink" title="（1）==who=="></a>（1）==who==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who</span><br></pre></td></tr></tbody></table></figure><p>注意：查询当前在线的用户，只能查询在登录页面输入了用户名密码登录的用户，<strong>通过su命令切换方式登录的用户，用who命令无法查询到该用户！！</strong></p><p>目前在登录状态的有root和zhangsan：</p><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428153125523.png" alt="image-20240428153125523" style="zoom:67%;"></p><h4 id="（2）-whoami"><a href="#（2）-whoami" class="headerlink" title="（2）==whoami=="></a>（2）==whoami==</h4><p>用户身份查询，当前所在的用户</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428153207695.png" alt="image-20240428153207695" style="zoom:67%;"></p><h4 id="（3）-id"><a href="#（3）-id" class="headerlink" title="（3）==id=="></a>（3）==id==</h4><p>显示当前用户信息</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428153244865.png" alt="image-20240428153244865" style="zoom:67%;"></p><h4 id="（4）-groups-用户名"><a href="#（4）-groups-用户名" class="headerlink" title="（4）==groups 用户名=="></a>（4）==groups 用户名==</h4><p>查询用户所属的组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groups jack</span><br><span class="line">jack : user05 user03 user04</span><br></pre></td></tr></tbody></table></figure><h1 id="三、用户之间的切换-su"><a href="#三、用户之间的切换-su" class="headerlink" title="三、用户之间的切换==su=="></a>三、用户之间的切换==su==</h1><h3 id="1、root切换到普通用户"><a href="#1、root切换到普通用户" class="headerlink" title="1、root切换到普通用户"></a>1、root切换到普通用户</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - 普通用户用户名</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428142744888.png" alt="image-20240428142744888" style="zoom:67%;"></p><ul><li><p>不用输入密码</p></li><li><p><strong>有没有 <code>-</code> 的区别</strong>：有 <code>-</code> 会重新初始化环境，比如全新用户home目录，新的环境变量。没有加 <code>-</code> 切换得不彻底，没有完整地初始化用户环境</p><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428143013726.png" alt="image-20240428143013726" style="zoom:50%;"></p><p>比如，从zhangsan用户切换到root之后：</p><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428143728952.png" alt="image-20240428143728952" style="zoom:67%;"></p><p>显示MAIL、PWD、HOME等环境变量依旧是zhangsan的环境变量，没有初始化到root的环境变量</p></li></ul><h3 id="2、普通用户切换到root"><a href="#2、普通用户切换到root" class="headerlink" title="2、普通用户切换到root"></a>2、普通用户切换到root</h3><p>要输入密码才能切换</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428142744888.png" alt="image-20240428142744888" style="zoom:50%;"></p><h1 id="四、用户组的创建和删除"><a href="#四、用户组的创建和删除" class="headerlink" title="四、用户组的创建和删除"></a>四、用户组的创建和删除</h1><p>==只有root用户可以操作==</p><h3 id="1、创建组-groupadd"><a href="#1、创建组-groupadd" class="headerlink" title="1、创建组==groupadd=="></a>1、创建组==groupadd==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groupadd：创建组</span><br><span class="line">eg.root用户创建用户组sales</span><br><span class="line">   groupadd sales</span><br><span class="line">eg.root用户创建用户sa01，sa02用户，并把它们添加到sales组里</span><br><span class="line">   useradd -g sales sa01</span><br><span class="line">   useradd -g sales sa02</span><br></pre></td></tr></tbody></table></figure><h3 id="2、删除组-groupdel"><a href="#2、删除组-groupdel" class="headerlink" title="2、删除组==groupdel=="></a>2、删除组==groupdel==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupdel：删除组</span><br><span class="line">eg.root用户删除用户组sales</span><br><span class="line">   groupdel sales</span><br></pre></td></tr></tbody></table></figure><p>注意：如果有用户属于这个组呢？—<strong>primary组不能删除</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、用户和用户组&quot;&gt;&lt;a href=&quot;#一、用户和用户组&quot; class=&quot;headerlink&quot; title=&quot;一、用户和用户组&quot;&gt;&lt;/a&gt;一、用户和用户组&lt;/h1&gt;&lt;h3 id=&quot;1、用户、用户组概念&quot;&gt;&lt;a href=&quot;#1、用户、用户组概念&quot; class=&quot;headerlink&quot; title=&quot;1、用户、用户组概念&quot;&gt;&lt;/a&gt;1、用户、用户组概念&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428141914666.png&quot; alt=&quot;image-20240428141914666&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linux是一个多用户的操作系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任何一个要使用系统资源的用户，必须登录进入系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Linux用户属于一个或多个特定的组，称为用户组，即group&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2、为什么分组&quot;&gt;&lt;a href=&quot;#2、为什么分组&quot; class=&quot;headerlink&quot; title=&quot;2、为什么分组&quot;&gt;&lt;/a&gt;2、为什么分组&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;资源访问控制：文件（泛义上的文件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有文件都属于一个特定的用户，和一个特定的用户组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个文件都有一定的访问权限，用户限制不同用户和用户组的访问行为&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3、用户和用户组的关系&quot;&gt;&lt;a href=&quot;#3、用户和用户组的关系&quot; class=&quot;headerlink&quot; title=&quot;3、用户和用户组的关系&quot;&gt;&lt;/a&gt;3、用户和用户组的关系&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;多对多&lt;/strong&gt;的关系&lt;/p&gt;
&lt;p&gt;Linux系统以组Group方式管理用户，用户和组的对应关系为多对多，即某个用户可属于一个或多个组，某个组可以有0个、1个或多个用户。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组的分类&lt;/p&gt;
&lt;p&gt;从用户的角度，分为主组和附属组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主组&lt;/strong&gt;：也被称为primary group、first group或initial login group，用户的默认组，用户的gid所标识的组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;附属组&lt;/strong&gt;：也被称为Secondary group或supplementary group，用户的附加组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户必须有且只能有一个主组，就可以有0个、1个或多个附属组&lt;/strong&gt;，如我们一定会有一个用来安家的房子（类同主组），还可以有n个用于投资或其他打算的房子（附属组）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4、用户分类&quot;&gt;&lt;a href=&quot;#4、用户分类&quot; class=&quot;headerlink&quot; title=&quot;4、用户分类&quot;&gt;&lt;/a&gt;4、用户分类&lt;/h3&gt;&lt;p&gt;（1）root用户：超级管理员用户，具有操作系统的最大权限&lt;/p&gt;
&lt;p&gt;（2）普通用户：由超级用户创建及授权，并且可以登录到Linux系统执行某些任务&lt;/p&gt;
&lt;p&gt;（3）系统用户：系统内创建了若干用户，如mail、ftp、bin等，默认情况下，系统用户都是无法登录的&lt;/p&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Linux" scheme="https://laylaycjl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>重定向、管道与环境变量</title>
    <link href="https://laylaycjl.github.io/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://laylaycjl.github.io/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2024-04-26T08:42:46.000Z</published>
    <updated>2024-04-28T06:02:57.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、重定向"><a href="#一、重定向" class="headerlink" title="一、重定向"></a>一、重定向</h1><h2 id="1、标准输入、标准输出、标准错误"><a href="#1、标准输入、标准输出、标准错误" class="headerlink" title="1、标准输入、标准输出、标准错误"></a>1、标准输入、标准输出、标准错误</h2><p>执行一个shell命令行时通常会自动打开三个标准文件，即：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426164557090.png" alt="image-20240426164557090" style="zoom:50%;"></p><ul><li><p>标准输入文件（stdin），通常对应终端的键盘，stdin的文件描述符为==0==，Unix程序默认从stdin读取数据</p></li><li><p>标准输出文件（stdout），对应终端的屏幕，stdout 的文件描述符为==1==，Unix程序默认向stdout输出数据</p></li><li>标准错误输出文件（stderr），对应终端的屏幕，stderr的文件描述符为==2==，Unix程序会向stderr流中写入错误信息</li></ul><p>进程将从标准输入文件中得到输入数据，将<strong>正常输出数据</strong>输出到<u>标准输出文件</u>，而将<strong>错误信息</strong>送到<u>标准错误文件</u>中</p><span id="more"></span><h2 id="2、输出重定向"><a href="#2、输出重定向" class="headerlink" title="2、输出重定向"></a>2、输出重定向</h2><h3 id="1、标准输出重定向"><a href="#1、标准输出重定向" class="headerlink" title="1、标准输出重定向"></a>1、标准输出重定向</h3><h4 id="（1）为什么重定向？"><a href="#（1）为什么重定向？" class="headerlink" title="（1）为什么重定向？"></a>（1）为什么重定向？</h4><p>有时候命令结果要使用，不想输出到终端上，可以将输出定向到别的设备，比如重定向到一个文件中</p><h4 id="（2）如何输出重定向"><a href="#（2）如何输出重定向" class="headerlink" title="（2）如何输出重定向"></a>（2）如何输出重定向</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">命令 &gt; 文件(输出重定向)</span><br><span class="line">命令 &gt;&gt; 文件（不覆盖文件，追加到文件末尾）</span><br><span class="line"></span><br><span class="line">比如：ps -ef &gt; file01 表示把ps -ef的结果重定向到文件file01中</span><br></pre></td></tr></tbody></table></figure><p><strong>注意</strong>：输出重定向会覆盖文件内容，如果不希望文件内容被覆盖，可以使用 <code>&gt;&gt;</code>追加到文件末尾</p><h4 id="（3）输出重定向符号的特殊用法"><a href="#（3）输出重定向符号的特殊用法" class="headerlink" title="（3）输出重定向符号的特殊用法"></a>（3）输出重定向符号的特殊用法</h4><h5 id="1）新建文件"><a href="#1）新建文件" class="headerlink" title="1）新建文件"></a>1）新建文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文件名</span><br><span class="line">eg.&gt; file01</span><br><span class="line">当file01文件不存在时，就会新建file01</span><br></pre></td></tr></tbody></table></figure><h5 id="2）清空文件"><a href="#2）清空文件" class="headerlink" title="2）清空文件"></a>2）清空文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文件名</span><br><span class="line">eg.&gt; file01</span><br><span class="line">当file01文件存在时，就会覆盖file01，从而清空file01</span><br></pre></td></tr></tbody></table></figure><h4 id="（4）输出重定向的应用"><a href="#（4）输出重定向的应用" class="headerlink" title="（4）输出重定向的应用"></a>（4）输出重定向的应用</h4><h5 id="1）把错误信息重定向到文件里，方便分析"><a href="#1）把错误信息重定向到文件里，方便分析" class="headerlink" title="1）把错误信息重定向到文件里，方便分析"></a>1）把错误信息重定向到文件里，方便分析</h5><ul><li><p>用grep查找catalina.log中的错误信息</p><p>会直接打印到屏幕上，不方便</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -i -E "error|Illegal" catalina.out</span><br><span class="line">-i 不区分大小写</span><br><span class="line">-E 正则</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426173716608.png" alt="image-20240426173716608" style="zoom:50%;"></p></li><li><p>把错误信息重定向到catalina_error文件里</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i -E "error|illegal" catalina.out &gt; catalina_error</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="2）实时监控日志，重定向到文件里"><a href="#2）实时监控日志，重定向到文件里" class="headerlink" title="2）实时监控日志，重定向到文件里"></a>2）实时监控日志，重定向到文件里</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f catalina.out &gt; catalina_output.log</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426174158802.png" alt="image-20240426174158802" style="zoom: 67%;"></p><h3 id="2、标准错误重定向"><a href="#2、标准错误重定向" class="headerlink" title="2、标准错误重定向"></a>2、标准错误重定向</h3><h4 id="（1）如何错误重定向"><a href="#（1）如何错误重定向" class="headerlink" title="（1）如何错误重定向"></a>（1）如何错误重定向</h4><p>默认情况下，<code>命令 &gt; 文件</code>会将输出重定向到 file</p><ul><li><p>如果希望将错误重定向到文件，可以这样写：命令 2 &gt; 文件</p></li><li><p>同样可以用&gt;&gt;来追加错误到文件末尾。</p></li><li><p>举例：直接重定向错误信息，会失败：<code>Ls &gt;&gt; file02</code></p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426171302675.png" alt="image-20240426171302675" style="zoom: 50%;"></p><p>加上限定2，定向成功：<code>Ls 2&gt;&gt; file02</code></p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426171533588.png" alt="image-20240426171533588" style="zoom:50%;"></p></li></ul><h4 id="（2）同时重定向标准输出和标准错误"><a href="#（2）同时重定向标准输出和标准错误" class="headerlink" title="（2）同时重定向标准输出和标准错误"></a>（2）同时重定向标准输出和标准错误</h4><p>执行文件中既有正确输出也有错误信息：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426171922457.png" alt="image-20240426171922457" style="zoom:50%;"></p><p>直接重定向，会让标准错误重定向失败：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426172147959.png" alt="image-20240426172147959" style="zoom: 50%;"></p><h5 id="1）重定向标准输出和标准错误到同一个文件"><a href="#1）重定向标准输出和标准错误到同一个文件" class="headerlink" title="1）重定向标准输出和标准错误到同一个文件"></a>1）重定向标准输出和标准错误到同一个文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：可执行命令/文件 &gt; file 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">注意：可执行命令/文件 &gt; file 1&gt;&amp;2会失败，必须按照2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426172302520.png" alt="image-20240426172302520" style="zoom:50%;"></p><h5 id="2）分别重定向标准输出和标准错误到不同一个文件"><a href="#2）分别重定向标准输出和标准错误到不同一个文件" class="headerlink" title="2）分别重定向标准输出和标准错误到不同一个文件"></a>2）分别重定向标准输出和标准错误到不同一个文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：可执行命令/文件 1&gt;正确file 2&gt;错误file</span><br><span class="line">将1（标准输出）重定向到正确的file，将2（标准错误）重定向到错误的file</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426172623372.png" alt="image-20240426172623372" style="zoom:50%;"></p><h2 id="3、输入重定向"><a href="#3、输入重定向" class="headerlink" title="3、输入重定向"></a>3、输入重定向</h2><h4 id="（1）语法"><a href="#（1）语法" class="headerlink" title="（1）语法"></a>（1）语法</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：命令 &lt; 文件</span><br><span class="line">比如：rm -i file01 &lt; file02表示从file02文件中读取内容作为命令的输入</span><br></pre></td></tr></tbody></table></figure><p>默认输入会显示在屏幕上：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426173137483.png" alt="image-20240426173137483" style="zoom:50%;"></p><p>将输入结果重定向到yes文件中：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426173315924.png" alt="image-20240426173315924" style="zoom:50%;"></p><h4 id="（2）常见用法"><a href="#（2）常见用法" class="headerlink" title="（2）常见用法"></a>（2）常见用法</h4><h5 id="1）通过cat编可视化编辑文件"><a href="#1）通过cat编可视化编辑文件" class="headerlink" title="1）通过cat编可视化编辑文件"></a>1）通过cat编可视化编辑文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF</span><br><span class="line">EOF代表End Of File</span><br><span class="line">输入命令之后进入编辑，输入EOF结束编辑</span><br><span class="line">还可以将编辑内容重定向到别的文件中，比如test61.log</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428095940677.png" alt="image-20240428095940677" style="zoom: 67%;"></p><h1 id="二、管道"><a href="#二、管道" class="headerlink" title="二、管道"></a>二、管道</h1><h2 id="1、管道的用法"><a href="#1、管道的用法" class="headerlink" title="1、管道的用法"></a>1、管道的用法</h2><p>经常要将一个命令的输出的内容，给另一个命令作为输入的内容进行处理</p><ul><li><p>例如，查看所有jack进程：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef &gt; ps.log</span><br><span class="line">将所有进程重定向到ps.log中</span><br><span class="line">grep jack ps.log</span><br><span class="line">查找所有带jack的行，也就是查所有jack进程</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428100445822.png" alt="image-20240428100445822" style="zoom:50%;"></p><p>如此导致ps命令的结果，会被下一个命令grep使用，为了方便，可以把ps命令的结果直接放入管道，给下一个命令使用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep jack</span><br></pre></td></tr></tbody></table></figure></li><li><p>再例如，统计jack进程有多少个</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法1：</span><br><span class="line">ps -ef &gt; ps.log</span><br><span class="line">grep jack ps.log &gt; jackps.log</span><br><span class="line">wc -l jackps.log</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法2：</span><br><span class="line">ps -ef &gt; ps.log</span><br><span class="line">grep -c jack ps.log &gt; jacknum.log</span><br></pre></td></tr></tbody></table></figure><p>使用管道就简单很多</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1：</span><br><span class="line">ps -ef | grep jack | wc -l</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法2：</span><br><span class="line">ps -ef | grep -c jack</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="2、管道示意图"><a href="#2、管道示意图" class="headerlink" title="2、管道示意图"></a>2、管道示意图</h3><h4 id="（1）图示"><a href="#（1）图示" class="headerlink" title="（1）图示"></a>（1）图示</h4><p>将前面的ps -ef命令的stdout（本来是输出到终端设备的）重定向到一个==临时管道设备==里</p><p>同时将后一个命令grep 1182的stdin重定向到这个临时的管道设备里</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428101313951.png" alt="image-20240428101313951" style="zoom:67%;"></p><h4 id="（2）例子"><a href="#（2）例子" class="headerlink" title="（2）例子"></a>（2）例子</h4><p>区分两者的区别，虽然输出结果一样</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428102114494.png" alt="image-20240428102114494" style="zoom:50%;"></p><p>1、直接屏幕输出错误信息</p><ul><li>运行test.sh后有标准输出hello world，还有标准错误command not found</li><li>将标准输出放入管道后查询command，自然没有查询到</li><li>标准错误没有被重定向，所以直接输出到屏幕</li></ul><p>2、重定向错误信息到管道，然后grep查询后输出</p><ul><li>运行test.sh后有标准输出hello world，还有标准错误command not found</li><li>将标准输出和标准错误都放入管道后查询command</li><li>查询到含有command的行，输出到屏幕</li></ul><h1 id="三、环境变量"><a href="#三、环境变量" class="headerlink" title="三、环境变量"></a>三、环境变量</h1><h2 id="1、什么是环境变量"><a href="#1、什么是环境变量" class="headerlink" title="1、什么是环境变量"></a>1、什么是环境变量</h2><h3 id="（1）变量"><a href="#（1）变量" class="headerlink" title="（1）变量"></a>（1）变量</h3><p>让某个特定的字符串代表不固定的内容就是变量</p><h3 id="（2）Linux系统的环境变量"><a href="#（2）Linux系统的环境变量" class="headerlink" title="（2）Linux系统的环境变量"></a>（2）Linux系统的环境变量</h3><ul><li>Linux是一个<strong>多用户</strong>的操作系统，每个用户登录系统后，都会有一个<strong>专用的运行环境</strong></li><li>这个<strong>运行环境是用一组环境变量来定义</strong>的。用户也可以对自己的运行环境进行定制，其方法就是修改相应的系统环境变量。</li></ul><p>打印环境变量的命令： env、 printenv</p><p>常见的环境变量如HOME，PWD，PATH等</p><h2 id="2、查看环境变量命令-env-、-printenv-、-echo"><a href="#2、查看环境变量命令-env-、-printenv-、-echo" class="headerlink" title="2、查看环境变量命令==env== 、==printenv==、==echo=="></a>2、查看环境变量命令==env== 、==printenv==、==echo==</h2><h3 id="（1）查看系统的所有环境变量及值env、printenv："><a href="#（1）查看系统的所有环境变量及值env、printenv：" class="headerlink" title="（1）查看系统的所有环境变量及值env、printenv："></a>（1）查看系统的<strong>所有</strong>环境变量及值env、printenv：</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env</span><br><span class="line">或</span><br><span class="line">printenv</span><br></pre></td></tr></tbody></table></figure><p>例：<img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428110034279.png" alt="image-20240428110034279" style="zoom:50%;"></p><h3 id="（2）查看系统的某个环境变量的值echo："><a href="#（2）查看系统的某个环境变量的值echo：" class="headerlink" title="（2）查看系统的某个环境变量的值echo："></a>（2）查看系统的<strong>某个</strong>环境变量的值echo：</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $变量名</span><br><span class="line">比如：echo $PATH</span><br></pre></td></tr></tbody></table></figure><p><code>echo</code>命令的作用是==显示字符==，<code>$</code>放在变量名前表示==引用==某个变量，不然整个配置文件都可能出问题</p><p>查看PATH：<img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428110251396.png" alt="image-20240428110251396" style="zoom:67%;"></p><p>查看HOME、SHELL：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428110346405.png" alt="image-20240428110346405" style="zoom: 67%;"></p><h2 id="3、常见的环境变量"><a href="#3、常见的环境变量" class="headerlink" title="3、常见的环境变量"></a>3、常见的环境变量</h2><ul><li><code>USER</code> - 这指的是当前登录的用户。</li><li><code>HOME</code> - 这显示了当前用户的主目录。</li><li><code>SHELL</code> - 这存储了当前用户的 shell 路径，如 bash 或 zsh。</li><li><code>LANG</code> - 这个变量指向当前的语言 /locales 设置。</li><li><code>MAIL</code> - 这显示了当前用户的邮件存储的位置。</li></ul><h3 id="（1）PATH"><a href="#（1）PATH" class="headerlink" title="（1）PATH"></a>（1）PATH</h3><ul><li><p>当输入命令的时候Linux会去查找PATH里面记录的路径</p><p>举例说明，在根目录/下可以输入命令<code>ls</code>，在<code>/usr</code>目录下也可以输入<code>ls</code>，但其实<code>ls</code>这个命令根本不在这个两个目录下，所有当你输入命令的时候Linux会去<code>/bin</code>，<code>/usr/bin</code>，<code>/sbin</code>等目录下面去找你此时输入的命令，而PATH的值恰恰就是<code>/bin:/sbin:/usr/bin:……</code>（其中的冒号使目录与目录之间隔开），一个个地查找此命令的可执行二进制文件</p><p><strong>找到了就正常执行</strong>：<img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428111546416.png" alt="image-20240428111546416" style="zoom:67%;"></p><ul><li><p>==找到第一个就会执行，不会再继续找==：</p><p>例如：<img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428114621370.png" alt="image-20240428114621370" style="zoom:50%;"></p><p>图中test文件夹和data文件夹中都有test.sh这个可执行文件，且两个test.sh文件的执行内容不同，将他们都配置到<code>/etc/profile</code>中，最后执行时，只会执行目录靠前的test.sh</p></li></ul><p><strong>没找到就显示错误</strong>：<img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428111328897.png" alt="image-20240428111328897" style="zoom:67%;"></p></li></ul><h2 id="4、如何设置环境变量-export"><a href="#4、如何设置环境变量-export" class="headerlink" title="4、如何设置环境变量==export=="></a>4、如何设置环境变量==export==</h2><p>==注意：添加到path的一定是目录、而不是可执行文件！！！==</p><p>常用的就是修改PATH环境变量和新增环境变量，修改方法举例在下面，新增环境变量方法如图：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428114118345.png" alt="image-20240428114118345" style="zoom:67%;"></p><h3 id="（1）临时方案（常用于测试）"><a href="#（1）临时方案（常用于测试）" class="headerlink" title="（1）临时方案（常用于测试）"></a>（1）临时方案（常用于测试）</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置环境变量命令：export</span><br><span class="line">举例：修改环境变量PATH的值，增加/www/data</span><br><span class="line">命令如下：</span><br><span class="line">export PATH=$PATH:/www/data</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428112453503.png" alt="image-20240428112453503" style="zoom:67%;"></p><p>但是，直接执行这个命令设置的变量值只是临时有效的，在重启系统后会失效，如果要永久有效，需要修改配置文件</p><h3 id="（2）永久方案"><a href="#（2）永久方案" class="headerlink" title="（2）永久方案"></a>（2）永久方案</h3><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>把<code>export PATH=$PATH:/www/data</code>的命令添加到配置文件的末尾</p><p>1）如果要配置对<strong>所有用户</strong>永久生效，则添加到配置文件<code>/etc/profile</code></p><ul><li><p>进入配置文件<code>vim /etc/profile</code></p></li><li><p>添加配置文件：把可执行文件的==目录==加入其中，<code>$</code>表示引用，不可省略</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428112934817.png" alt="image-20240428112934817" style="zoom:50%;"></p></li></ul><p>2）如果要配置对<strong>当前用户</strong>生效，则添加到配置文件<code>~/.bashrc</code></p><ul><li>步骤略</li></ul><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>执行如下命令使配置生效</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、重定向&quot;&gt;&lt;a href=&quot;#一、重定向&quot; class=&quot;headerlink&quot; title=&quot;一、重定向&quot;&gt;&lt;/a&gt;一、重定向&lt;/h1&gt;&lt;h2 id=&quot;1、标准输入、标准输出、标准错误&quot;&gt;&lt;a href=&quot;#1、标准输入、标准输出、标准错误&quot; class=&quot;headerlink&quot; title=&quot;1、标准输入、标准输出、标准错误&quot;&gt;&lt;/a&gt;1、标准输入、标准输出、标准错误&lt;/h2&gt;&lt;p&gt;执行一个shell命令行时通常会自动打开三个标准文件，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426164557090.png&quot; alt=&quot;image-20240426164557090&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标准输入文件（stdin），通常对应终端的键盘，stdin的文件描述符为==0==，Unix程序默认从stdin读取数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标准输出文件（stdout），对应终端的屏幕，stdout 的文件描述符为==1==，Unix程序默认向stdout输出数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;标准错误输出文件（stderr），对应终端的屏幕，stderr的文件描述符为==2==，Unix程序会向stderr流中写入错误信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程将从标准输入文件中得到输入数据，将&lt;strong&gt;正常输出数据&lt;/strong&gt;输出到&lt;u&gt;标准输出文件&lt;/u&gt;，而将&lt;strong&gt;错误信息&lt;/strong&gt;送到&lt;u&gt;标准错误文件&lt;/u&gt;中&lt;/p&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Linux" scheme="https://laylaycjl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>软件测试基础</title>
    <link href="https://laylaycjl.github.io/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://laylaycjl.github.io/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</id>
    <published>2024-04-25T07:04:06.000Z</published>
    <updated>2024-04-28T06:02:40.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、目的、原则、流程、职责"><a href="#一、目的、原则、流程、职责" class="headerlink" title="一、目的、原则、流程、职责"></a>一、目的、原则、流程、职责</h1><h2 id="1、软件测试目的、概念"><a href="#1、软件测试目的、概念" class="headerlink" title="1、软件测试目的、概念"></a>1、软件测试目的、概念</h2><h3 id="（1）测试目的"><a href="#（1）测试目的" class="headerlink" title="（1）测试目的"></a>（1）测试目的</h3><ul><li>软件测试是程序的执行过程，目的在于<strong>发现错误</strong>,尽可能多的找出缺陷</li><li>软件测试的目的是确保交给用户的软件产品<strong>符合用户的需求</strong></li><li>软件测试的目的是检验软件产品是否满足用户的<strong>显性和隐性需求</strong><ul><li>显性需求:产品经理(跟客户对接、整理需求)—-》需求文档</li><li>隐形需求:按照约定俗成，应该要实现的需求（删除弹出确认对话框、金额小数点2位、密码*显示)</li></ul></li></ul><h3 id="（2）测试的概念"><a href="#（2）测试的概念" class="headerlink" title="（2）测试的概念"></a>（2）测试的概念</h3><ul><li>60-70年代梅耶执行程序，发现错误</li><li>80-90年代特定条件下操作软件，发现错误，评估质量（是否达到质量标准)</li><li>2000 IEEE 使用人工或自动化手段，来<strong>运行</strong>或<strong>测试</strong>某个系统的过程，其目的在于检验它<strong>是否满足规定的需求</strong>或<strong>弄清预期结果与实际结果之间的差别</strong>。</li></ul><span id="more"></span><h2 id="2、软件测试的原则"><a href="#2、软件测试的原则" class="headerlink" title="2、软件测试的原则"></a>2、软件测试的原则</h2><ul><li><p>测试证明软件存在缺陷</p><p>只能证明软件存在缺陷，而无法证明软件不存在哪些缺陷</p></li><li><p>测试不能穷尽</p><p>测试的场景和数据非常多，无法穷尽</p></li><li><p>测试的2/8现象</p><p>80%的缺陷集中在20%的模块中</p></li><li><p>测试应尽早介入</p><p>越早发现问题，修复的成本就越低</p></li><li><p>杀虫剂现象</p><p>避免杀虫剂现象，不断调整测试计划、策略、优化测试用例</p></li><li><p>避免开发测试自己的代码</p><p>避免思维定式，很难发现问题</p></li><li><p>用例包含合理和不合理的输入条件</p><p>应该有正确的和不正确的条件</p></li><li><p>所有的软件测试都应追溯到用户需求</p><p>黑盒测试（根据需求文档&lt;———客户的需求)</p></li></ul><h2 id="3、测试流程"><a href="#3、测试流程" class="headerlink" title="3、测试流程"></a>3、测试流程</h2><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240425201450519.png" alt="image-20240425201450519" style="zoom:80%;"></p><ul><li>1、需求分析：测试首先要对软件需求有着深入的理解，所以我们会开需求评审会议，分析和讨论需求。</li><li>2、指定测试计划：这个计划会明确测试的范围、方法、资源分配、时间表和目标。</li><li>3、测试用例设计：基于测试计划，设计详细的测试用例。这些用例应该覆盖所有功能点，包括正常情况和边界情况的测试。</li><li>4、测试用例评审</li><li>5、搭建和配置适合的测试环境，执行测试用例，记录测试结果(找bug),将在测试过程中发现的缺陷报告给开发团队</li><li>6、回归测试：每当代码发生更改后，执行回归测试以确保新的更改没有破坏现有的功能</li><li>7、性能测试:评估系统的响应时间、稳定性和扩展性。</li><li>8、部署项目到预生产环境，在预生产环境测试</li><li>9、编写测试报告，总结测试活动的结果，包括测试覆盖率、发现的缺陷和未解决的问题。</li><li>10、项目上线后，根据反馈进行复盘和总结。</li></ul><h2 id="4、软件测试对象"><a href="#4、软件测试对象" class="headerlink" title="4、软件测试对象"></a>4、软件测试对象</h2><p>程序+数据+文档</p><h2 id="5、测试的风险"><a href="#5、测试的风险" class="headerlink" title="5、测试的风险"></a>5、测试的风险</h2><ul><li><p>进度风险</p><p>开发提交测试时延迟，进度被耽误</p></li><li><p>人员风险</p><p>人员数量不够：解决方法就是加班，加人，优先级高的部分优先测试</p><p>人员技术不足：集中培训、一对一辅导、自学</p></li><li><p>成本风险</p><p>与进度、人员、质量风险都有关</p></li><li><p>质量风险</p><p>开发和测试对质量的理解不一致</p><ul><li><p>如果测试提交了一个问题，开发认为不是问题，你会怎么办？</p><p>沟通，讲清楚问题的原因，找产品经理，问题要跟踪到底</p></li></ul></li><li><p>变更风险</p><p>需求变更：新增、修改、删除</p><p>（难点在于，需求变更之后，对其他模块的影响分析，需要刷新测试用例）</p></li></ul><h2 id="6、测试工程师具备的技能"><a href="#6、测试工程师具备的技能" class="headerlink" title="6、测试工程师具备的技能"></a>6、测试工程师具备的技能</h2><ul><li>计算机相关基础知识</li><li>软件基础知识：软件生命周期，测试理论和测试方式有较深的理解</li><li>软件测试技术，方法，流程，测试文档编写，能独立设计和执行测试用例，提交完整的缺陷报告单,编写测试报告</li><li>软件开发语言：Python</li><li>数据库：MySQL，Redis</li><li>操作系统：Linux，iOS，Android，DOS</li><li>业务知识</li><li>网络基本知识，能够独立完成测试环境的搭建</li><li>学好一门或多门外语</li></ul><h2 id="7、测试人员具备素质"><a href="#7、测试人员具备素质" class="headerlink" title="7、测试人员具备素质"></a>7、测试人员具备素质</h2><p>三心二力一精神</p><ul><li>三心：细心、耐心、责任心</li><li>二力：洞察力沟通能力</li><li>—精神：团队合作精神</li></ul><h2 id="8、测试工程师的工作职责"><a href="#8、测试工程师的工作职责" class="headerlink" title="8、测试工程师的工作职责"></a>8、测试工程师的工作职责</h2><p>1、编写测试计划</p><p>2、提取测试点</p><p>3、编写测试用例</p><p>4、搭建测试环境</p><p>5、测试执行、缺陷管理</p><p>6、编写测试报告</p><h1 id="二、研发流程与模型"><a href="#二、研发流程与模型" class="headerlink" title="二、研发流程与模型"></a>二、研发流程与模型</h1><h3 id="1、软件开发过程"><a href="#1、软件开发过程" class="headerlink" title="1、软件开发过程"></a>1、软件开发过程</h3><p>从最初的想法到公开发行的过程，称为软件开发过程</p><h1 id="三、测试分类"><a href="#三、测试分类" class="headerlink" title="三、测试分类"></a>三、测试分类</h1><h1 id="四、软件八大质量特性"><a href="#四、软件八大质量特性" class="headerlink" title="四、软件八大质量特性"></a>四、软件八大质量特性</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、目的、原则、流程、职责&quot;&gt;&lt;a href=&quot;#一、目的、原则、流程、职责&quot; class=&quot;headerlink&quot; title=&quot;一、目的、原则、流程、职责&quot;&gt;&lt;/a&gt;一、目的、原则、流程、职责&lt;/h1&gt;&lt;h2 id=&quot;1、软件测试目的、概念&quot;&gt;&lt;a href=&quot;#1、软件测试目的、概念&quot; class=&quot;headerlink&quot; title=&quot;1、软件测试目的、概念&quot;&gt;&lt;/a&gt;1、软件测试目的、概念&lt;/h2&gt;&lt;h3 id=&quot;（1）测试目的&quot;&gt;&lt;a href=&quot;#（1）测试目的&quot; class=&quot;headerlink&quot; title=&quot;（1）测试目的&quot;&gt;&lt;/a&gt;（1）测试目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;软件测试是程序的执行过程，目的在于&lt;strong&gt;发现错误&lt;/strong&gt;,尽可能多的找出缺陷&lt;/li&gt;
&lt;li&gt;软件测试的目的是确保交给用户的软件产品&lt;strong&gt;符合用户的需求&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;软件测试的目的是检验软件产品是否满足用户的&lt;strong&gt;显性和隐性需求&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;显性需求:产品经理(跟客户对接、整理需求)—-》需求文档&lt;/li&gt;
&lt;li&gt;隐形需求:按照约定俗成，应该要实现的需求（删除弹出确认对话框、金额小数点2位、密码*显示)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;（2）测试的概念&quot;&gt;&lt;a href=&quot;#（2）测试的概念&quot; class=&quot;headerlink&quot; title=&quot;（2）测试的概念&quot;&gt;&lt;/a&gt;（2）测试的概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;60-70年代梅耶执行程序，发现错误&lt;/li&gt;
&lt;li&gt;80-90年代特定条件下操作软件，发现错误，评估质量（是否达到质量标准)&lt;/li&gt;
&lt;li&gt;2000 IEEE 使用人工或自动化手段，来&lt;strong&gt;运行&lt;/strong&gt;或&lt;strong&gt;测试&lt;/strong&gt;某个系统的过程，其目的在于检验它&lt;strong&gt;是否满足规定的需求&lt;/strong&gt;或&lt;strong&gt;弄清预期结果与实际结果之间的差别&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试基础" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>测试报告</title>
    <link href="https://laylaycjl.github.io/2024/04/25/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/"/>
    <id>https://laylaycjl.github.io/2024/04/25/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/</id>
    <published>2024-04-25T04:40:23.000Z</published>
    <updated>2024-04-25T05:57:46.949Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>什么是测试报告？</p><p>测试报告是测试人员在<strong>完成整个系统的测试工作之后</strong>所撰写的文档，该文档可以反映测试<strong>过程</strong>与测试<strong>结果</strong>，是对阶段性测试任务的<u>总结</u>。</p></li><li><p>测试报告作用？</p><ul><li>可以评估项目当前状态和产品质量</li><li>确定产品是否准备好发布的最终文档</li></ul></li></ul><h2 id="一、测试报告的几大要素"><a href="#一、测试报告的几大要素" class="headerlink" title="一、测试报告的几大要素"></a>一、测试报告的几大要素</h2><h3 id="1、人力投入"><a href="#1、人力投入" class="headerlink" title="1、人力投入"></a>1、人力投入</h3><p>对不同测试阶段所花的时间有清晰记录</p><p>eg. 测试用例编写：人员、工作量</p><p>测试执行：人员、工作量</p><h3 id="2、用例覆盖度"><a href="#2、用例覆盖度" class="headerlink" title="2、用例覆盖度"></a>2、用例覆盖度</h3><p>==用例覆盖率=（pass+fail）/总用例数==</p><p>用例状态：pass（通过）、fail（未通过）、NT（not test尚未测试）、block（阻塞，暂时没有条件执行）、investigate（观察中，正在测试）</p><p>eg.pass和fail一共251，总用例263个</p><p>用例覆盖率=251/263=95%</p><h3 id="3、缺陷统计"><a href="#3、缺陷统计" class="headerlink" title="3、缺陷统计"></a>3、缺陷统计</h3><ul><li><p>bug严重等级：其中致命bug少的原因——开发自测和冒烟测试已经筛掉了大部分致命bug</p></li><li><p>功能型bug最多</p></li><li><p>bug状态：激活、已解决、已关闭</p><p>==缺陷遗留率=（激活+已解决）/总bug数==</p><p>只认准已关闭的bug为已解决</p></li><li><p>bug来源：一般是需求、编码类bug较多</p></li></ul><h3 id="4、缺陷遗留问题"><a href="#4、缺陷遗留问题" class="headerlink" title="4、缺陷遗留问题"></a>4、缺陷遗留问题</h3><p>缺陷遗留率：是否达标? 3%、一般、提示没有关闭的缺陷数/缺陷总数</p><ul><li>对于影响大的问题，不能遗留，需要在当前版本立马解决</li><li>对于某些兼容性问题且只有ie6浏览器会出现问题时，可以忽略，因为有规避措施，换浏览器就可以解决</li></ul><span id="more"></span><h3 id="5、测试结论"><a href="#5、测试结论" class="headerlink" title="5、测试结论"></a>5、测试结论</h3><p>测试结论应该明确</p><h2 id="二、测试报告书写格式"><a href="#二、测试报告书写格式" class="headerlink" title="二、测试报告书写格式"></a>二、测试报告书写格式</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1编写目的"><a href="#1-1编写目的" class="headerlink" title="1.1编写目的"></a>1.1编写目的</h4><p>1）本报告按照<strong>项目的技术要求反映</strong>项目的测试结果。</p><p>2）阅读对象为项目组所有成员及其相关授权的人员。</p><h4 id="1-2项目背景"><a href="#1-2项目背景" class="headerlink" title="1.2项目背景"></a>1.2项目背景</h4><p><strong>项目背景</strong>:这里简单介绍该项目产生的背景，可以把该项目的《需求说明书》中的“项目背景”部分摘抄到这里。<br><strong>系统简介</strong>:这里简单介绍该系统的实际使用场景，需要提供的功能等信息，可以把该项目的《需求说明书》中的“系统简介”部分摘抄到这里。<br><strong>测试目标</strong>:配合开发部，使该项目最终产品达到商用标准。</p><h4 id="1-3参考文档"><a href="#1-3参考文档" class="headerlink" title="1.3参考文档"></a>1.3参考文档</h4><p><img src="/2024/04/25/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/image-20240424201439051.png" style="zoom:50%;"></p><p><img src="/2024/04/25/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/image-20240425125144939.png" alt="image-20240425125144939" style="zoom:67%;"></p><h3 id="2、测试设计简介"><a href="#2、测试设计简介" class="headerlink" title="2、测试设计简介"></a>2、测试设计简介</h3><h4 id="2-1-测试用例设计"><a href="#2-1-测试用例设计" class="headerlink" title="2.1 测试用例设计"></a>2.1 测试用例设计</h4><p>设计测试用例点xx个</p><p>把每个模块设计的用例记录下来</p><p><img src="/2024/04/25/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/image-20240425125114634.png" alt="image-20240425125114634" style="zoom:67%;"></p><h4 id="2-2-测试环境与配置"><a href="#2-2-测试环境与配置" class="headerlink" title="2.2 测试环境与配置"></a>2.2 测试环境与配置</h4><p><img src="/2024/04/25/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/image-20240425125215665.png" alt="image-20240425125215665" style="zoom:67%;"></p><h4 id="2-3-测试方法与工具"><a href="#2-3-测试方法与工具" class="headerlink" title="2.3 测试方法与工具"></a>2.3 测试方法与工具</h4><ul><li><p>测试方法：手工测试</p></li><li><p>测试工具：</p><p>xmind：设计测试用例；</p><p>word：编写测试计划、测试报告；</p><p>excel：编写测试用例；</p><p>禅道：管理测试用例与缺陷；</p><p>自动化测试: Selenium、requests；</p><p>接口测试：JMeter、Postman；</p><p>性能测试：JMeter；</p><p>APP专项测试:Monkey、PerfDog、QNET、Fiddlerk、Wetest、手机助手；</p></li></ul><h3 id="3、测试结果及分析"><a href="#3、测试结果及分析" class="headerlink" title="3、测试结果及分析"></a>3、测试结果及分析</h3><h4 id="3-1-测试执行情况与记录"><a href="#3-1-测试执行情况与记录" class="headerlink" title="3.1 测试执行情况与记录"></a>3.1 测试执行情况与记录</h4><p><img src="/2024/04/25/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/image-20240425125304045.png" alt="image-20240425125304045" style="zoom:67%;"></p><h4 id="3-2-缺陷汇总"><a href="#3-2-缺陷汇总" class="headerlink" title="3.2 缺陷汇总"></a>3.2 缺陷汇总</h4><p><img src="/2024/04/25/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/image-20240425125315394.png" alt="image-20240425125315394"></p><p>测试中发现致命问题：XX ;严重问题:XX众;一般问:XX众;提示问题:XX个。</p><p>Postponed:因为不是很重要或技术难度过大或需求不明确，可推迟到下一个版本再解决。</p><p>Fixed:已被开发人员找到原因并修复的缺陷。</p><p>Closed:测试人员在修复的版本中验证该问题确实已修复。</p><p>Open:测试人员发现并提交的 bug。</p><p>New:测试人员发现并新建了bug 单。</p><p>这里说明在测试过程中总共提交了多少bug，其中有效bug数为多分，无效 bug数为多少，已修改bug数为多少，遗留bug数为多少。</p><p>==管理可以通过缺陷汇总来判断：==</p><ul><li><strong>缺陷密度</strong>是否正常：</li><li><strong>缺陷的遗留率</strong>是否正常：一般和提示问题数量/缺陷总数</li><li><strong>缺陷修复率</strong>是否达标：已经修复并关闭的缺陷数量/缺陷总数</li></ul><h4 id="3-3-测试覆盖率"><a href="#3-3-测试覆盖率" class="headerlink" title="3.3 测试覆盖率"></a>3.3 测试覆盖率</h4><p>覆盖率=（pass+fail）/总用例数</p><h4 id="3-4-结论"><a href="#3-4-结论" class="headerlink" title="3.4 结论"></a>3.4 结论</h4><p>用一段简洁明了的文字，总结测试的质量。<br>例如：所有的功能已经实现，基本稳定，性能已经达标；</p><ul><li>以科睿项目为例：用户管理模块，导出用户功能不可用，同时添加和修改用户时对账号、密码等输入没有进行校验，不合理的输入也能添加或修改，其他功能已经实现且比较稳定。</li></ul><p>如果不稳定，存在XXX问题。<br>但还存在以下问题（在表格中把遗留问题逐一列举，并对问题根因进行说明)</p><p><img src="/2024/04/25/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A-1/image-20240425125328211.png" alt="image-20240425125328211" style="zoom:67%;"></p><h4 id="3-5-建议"><a href="#3-5-建议" class="headerlink" title="3.5 建议"></a>3.5 建议</h4><p>对遗留问题对系统商用进行简单评估，给出是否可以商用的建议。<br>缺陷遗留比较多，还有XXX严重问题没解决，建议修改后回归测试再评估。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是测试报告？&lt;/p&gt;
&lt;p&gt;测试报告是测试人员在&lt;strong&gt;完成整个系统的测试工作之后&lt;/strong&gt;所撰写的文档，该文档可以反映测试&lt;strong&gt;过程&lt;/strong&gt;与测试&lt;strong&gt;结果&lt;/strong&gt;，是对阶段性测试任务的&lt;u&gt;总结&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试报告作用？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以评估项目当前状态和产品质量&lt;/li&gt;
&lt;li&gt;确定产品是否准备好发布的最终文档&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一、测试报告的几大要素&quot;&gt;&lt;a href=&quot;#一、测试报告的几大要素&quot; class=&quot;headerlink&quot; title=&quot;一、测试报告的几大要素&quot;&gt;&lt;/a&gt;一、测试报告的几大要素&lt;/h2&gt;&lt;h3 id=&quot;1、人力投入&quot;&gt;&lt;a href=&quot;#1、人力投入&quot; class=&quot;headerlink&quot; title=&quot;1、人力投入&quot;&gt;&lt;/a&gt;1、人力投入&lt;/h3&gt;&lt;p&gt;对不同测试阶段所花的时间有清晰记录&lt;/p&gt;
&lt;p&gt;eg. 测试用例编写：人员、工作量&lt;/p&gt;
&lt;p&gt;测试执行：人员、工作量&lt;/p&gt;
&lt;h3 id=&quot;2、用例覆盖度&quot;&gt;&lt;a href=&quot;#2、用例覆盖度&quot; class=&quot;headerlink&quot; title=&quot;2、用例覆盖度&quot;&gt;&lt;/a&gt;2、用例覆盖度&lt;/h3&gt;&lt;p&gt;==用例覆盖率=（pass+fail）/总用例数==&lt;/p&gt;
&lt;p&gt;用例状态：pass（通过）、fail（未通过）、NT（not test尚未测试）、block（阻塞，暂时没有条件执行）、investigate（观察中，正在测试）&lt;/p&gt;
&lt;p&gt;eg.pass和fail一共251，总用例263个&lt;/p&gt;
&lt;p&gt;用例覆盖率=251/263=95%&lt;/p&gt;
&lt;h3 id=&quot;3、缺陷统计&quot;&gt;&lt;a href=&quot;#3、缺陷统计&quot; class=&quot;headerlink&quot; title=&quot;3、缺陷统计&quot;&gt;&lt;/a&gt;3、缺陷统计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;bug严重等级：其中致命bug少的原因——开发自测和冒烟测试已经筛掉了大部分致命bug&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;功能型bug最多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bug状态：激活、已解决、已关闭&lt;/p&gt;
&lt;p&gt;==缺陷遗留率=（激活+已解决）/总bug数==&lt;/p&gt;
&lt;p&gt;只认准已关闭的bug为已解决&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bug来源：一般是需求、编码类bug较多&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4、缺陷遗留问题&quot;&gt;&lt;a href=&quot;#4、缺陷遗留问题&quot; class=&quot;headerlink&quot; title=&quot;4、缺陷遗留问题&quot;&gt;&lt;/a&gt;4、缺陷遗留问题&lt;/h3&gt;&lt;p&gt;缺陷遗留率：是否达标? 3%、一般、提示没有关闭的缺陷数/缺陷总数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于影响大的问题，不能遗留，需要在当前版本立马解决&lt;/li&gt;
&lt;li&gt;对于某些兼容性问题且只有ie6浏览器会出现问题时，可以忽略，因为有规避措施，换浏览器就可以解决&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试基础" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux概述与常用命令</title>
    <link href="https://laylaycjl.github.io/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://laylaycjl.github.io/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2024-04-24T11:19:20.000Z</published>
    <updated>2024-04-27T13:29:17.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、操作系统"><a href="#一、操作系统" class="headerlink" title="一、操作系统"></a>一、操作系统</h2><ul><li><p>操作系统（Operating System，OS）：管理硬件和应用程序的一套==系统软件==。</p></li><li><p>操作系统的作用： CPU管理、内存管理、文件系统管理、进程管理、外设管理、用户管理…（<em>理解：表现出来就是让CPU可以开始判断逻辑与运算数值，让内存可以开始加载/读出数据与程序代码，让硬盘可以开始被访问，让网卡可以开始传输数据，让所有周边设备可以开始运转等，总之硬件的所有操作都必须要通过操作系统来完成。</em>）</p></li><li><p>一个操作系统的核心叫==内核==，操作系统的各项功能都是通过内核实现的。</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424195236588-1714013539134.png" style="zoom:50%;"></p></li></ul><h3 id="1、常见的操作系统："><a href="#1、常见的操作系统：" class="headerlink" title="1、常见的操作系统："></a>1、常见的操作系统：</h3><ul><li>DoS：个人电脑；</li><li>Windows：个人电脑，Windows7、Windows10、WindowsServer；</li><li>Mac OS X：MacBook系列笔记本；</li><li>Android：安卓手机、平板、机顶盒、智能电视机、手环；</li><li>ios：iPhone、iPad、iWatch、iPod等；</li><li>Unix（服务器）</li><li>Linux：免费、可靠、安全、稳定、多平台；（服务器）</li></ul><h3 id="2、操作系统之间的关系"><a href="#2、操作系统之间的关系" class="headerlink" title="2、操作系统之间的关系"></a>2、操作系统之间的关系</h3><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424195349886.png" alt="image-20240424195349886" style="zoom:67%;"></p><h3 id="3、主要学习Linux原因："><a href="#3、主要学习Linux原因：" class="headerlink" title="3、主要学习Linux原因："></a>3、主要学习Linux原因：</h3><ul><li>大部分软件都运行在Linux上<ul><li>Linux作为服务器的操作系统，大部分软件都运行在Linux操作系统上;</li><li>互联网Web服务、物联网、车联网、大数据、云计算服务、人工智能、智能运维等各个方面都广泛应用;</li></ul></li><li>工作中要用Linux</li></ul><span id="more"></span><h2 id="二、Linux系统简介"><a href="#二、Linux系统简介" class="headerlink" title="二、Linux系统简介"></a>二、Linux系统简介</h2><h3 id="1、Linux系统结构"><a href="#1、Linux系统结构" class="headerlink" title="1、Linux系统结构"></a>1、Linux系统结构</h3><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424195322986.png" alt="image-20240424195322986" style="zoom: 67%;"></p><p>kernel——内核（所有命令最终由内核完成）</p><p>shell——<strong>负责接受命令，然后找到该命令对应的二进制文件</strong></p><p>file system——文件系统（组织和管理系统文件）</p><p>users application——应用程序</p><h3 id="2、Linux发行版本"><a href="#2、Linux发行版本" class="headerlink" title="2、Linux发行版本"></a>2、Linux发行版本</h3><p>各种组织或单位采用Linux内核和GNU工具集以及各类软件，编译及包装成自己所谓的Linux发行版（就像安卓)</p><ul><li>一类是<strong>商业公司</strong>维护的发行版本：以Redhat企业版（RHEL)为代表<ul><li>Redhat系列: RHEL ( Redhat Enterprise Linux ) 、Fedora Core、OpenSUSE(德国著名Linux)</li></ul></li><li><p>一类是<strong>社区组织</strong>维护的发行版本：以CentOS、Debian为代表</p><ul><li>Debian系列: Debian、Ubuntu、CentOS (RHEL的社区克隆版本，免费)不同系列的内核都是采用Linux内核，大部分命令相同，部分命令不一样</li></ul></li></ul><h3 id="3、Linux系统特点"><a href="#3、Linux系统特点" class="headerlink" title="3、Linux系统特点"></a>3、Linux系统特点</h3><ul><li>多用户：同时支持多个用户登录使用_(用户管理)<ul><li>与win的明显差异，支持多用户是Linux的一大特点</li></ul></li><li>多任务：多个任务（程序）可以同时运行（与Windows类似)·安全:源代码开源，有问题可以及时发现和优化</li><li>源码公开：任何人、组织只要遵守官方许可条款，就可以自由使用Linux源代码</li><li>广泛的硬件/软件支持：常见的应用先为Linux版本开发，后续才移植到其他平台</li><li>强大的命令、工具</li><li>稳定：可以长时间地稳定运行</li></ul><h3 id="4、Linux系统在软件测试中的应用"><a href="#4、Linux系统在软件测试中的应用" class="headerlink" title="4、Linux系统在软件测试中的应用"></a>4、Linux系统在软件测试中的应用</h3><ul><li><p>Linux作为操作系统在企业中广泛使用</p></li><li><p>大量的公司项目软件安装在Linux操作系统上</p></li><li><p>公司软件运行过程中出现问题，需要运用Linux知识去排查和解决</p><p>如：==a.网络故障排查、b.程序状态查看、c.定时启动一个程序、d.<strong>查看日志</strong>(重点)、e.软件安装/卸载、f.程序配置文件修改==</p></li></ul><p>（重点学Linux怎么看日志，方便定位问题）</p><h2 id="三、Linux指令"><a href="#三、Linux指令" class="headerlink" title="三、Linux指令"></a>三、Linux指令</h2><h3 id="1、Linux系统登录"><a href="#1、Linux系统登录" class="headerlink" title="1、Linux系统登录"></a>1、Linux系统登录</h3><ul><li><p>本地登录</p></li><li><p>远程登录：通过远程登录工具登录，如SecureCRT/Xshell/putty等</p></li></ul><p><strong>远程无法登录时，去查看虚拟机分配的ip地址是否改变</strong></p><h3 id="2、Linux运行级别（runlevel）"><a href="#2、Linux运行级别（runlevel）" class="headerlink" title="2、Linux运行级别（runlevel）"></a>2、Linux运行级别（runlevel）</h3><h4 id="（1）0-6级别"><a href="#（1）0-6级别" class="headerlink" title="（1）0-6级别"></a>（1）0-6级别</h4><blockquote><p><strong>0： 系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</strong></p><p>1： 单用户工作状态，root权限，用于系统维护，禁止远程登陆</p><p>（超级管理员）</p><p>2： 多用户无网络状态(没有NFS) </p><p><strong>3： 多用户有网络状态(有NFS)，登陆后进入控制台==命令行模式==</strong></p><p>（默认运行级别3）</p><p>4： 系统未使用，保留 </p><p>5： 多用户有网络，登陆后进入图形GUI模式 </p><p><strong>6： 系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启</strong></p><p> <strong>动</strong></p></blockquote><h4 id="（2）修改运行级别-sudo"><a href="#（2）修改运行级别-sudo" class="headerlink" title="（2）修改运行级别==sudo=="></a>（2）修改运行级别==sudo==</h4><p>1）运行时修改，转换为3级运行模式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo init 3</span><br></pre></td></tr></tbody></table></figure><p>2）开机启动时指定运行模式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/inittab</span><br></pre></td></tr></tbody></table></figure><p>3）查看运行级别</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ runlevel</span><br><span class="line">2 3</span><br></pre></td></tr></tbody></table></figure><p> 2和3分别是刚刚的运行级别，和现在当前的运行级别</p><h3 id="3、Shell与Shell脚本"><a href="#3、Shell与Shell脚本" class="headerlink" title="3、Shell与Shell脚本"></a>3、Shell与Shell脚本</h3><h4 id="（1）Shell"><a href="#（1）Shell" class="headerlink" title="（1）Shell"></a>（1）Shell</h4><ul><li><p>Shell是一个用C语言编写的==程序==，是用户通过命令和Linux进行交互的<strong>桥梁</strong>，它接受用户从字符终端输入的命令，并<strong>调用对应的程序</strong>去执行</p></li><li><p>==Linux是通过Shell来解释执行命令（命令解释器）==</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424195554007.png" alt="image-20240424195554007" style="zoom: 80%;"></p><p>可以看到用于处理cd命令的程序在/usr/bin/cd 中，由shell来调用</p></li><li><p>Linux默认的Shell是bash</p><p>Shell种类：</p><ul><li>标准shell（ash）：是Linux 中占用系统资源最少的一个小Shell，它只包含24个内部命令，因而使用起来很不方便</li><li><strong>Bonrne Again Shell（bash）</strong>：bash是Linux系统默认使用的Shell，内部命令一共有40 个。Linux 使用它作为默认的Shell是因为它具有以下特色：1、可以使用类似DOS下面的doskey的功能，用上下方向键查阅和快速输入并修改命令。2、自动通过查找匹配的方式，给出以某字串开头的命令。3、包含了自身的帮助功能，你只要在提示符下面键入help就可以得到相关的帮助信息。</li><li>Korn shell（ksh）：该Shell最大的优点是几乎和商业发行版的ksh 完全相容，这样就可以在不用花钱购买商业版本的情况下尝试商业版本的性能。</li><li>C shell（csh）：csh 是Linux 比较大的内核，它由以William Joy 为代表的共计47 位作者编成，共有52个内部命令。该Shell其实是指向/bin/tcsh这样的一个Shell，也就是说，csh其实就是tcsh。</li></ul></li></ul><h4 id="（2）Shell脚本"><a href="#（2）Shell脚本" class="headerlink" title="（2）Shell脚本"></a>（2）Shell脚本</h4><p>shell与shell脚本的区别：</p><ul><li><p>shell是命令解释器，作用是接受终端输入的命令，找到命令对应的可执行文件运行；</p></li><li><p>shell script是shell脚本，一种为 shell 编写的脚本程序</p><ul><li>vim创建一个shell脚本：test.sh</li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200011636.png" alt="image-20240424200011636" style="zoom:67%;"></p><ul><li><p>进入test.sh，编辑脚本：cat查看脚本内容，第一行是声明：<code>#!/bin/bash</code>；然后输出hello world</p></li><li><p>运行：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200051533.png" alt="image-20240424200051533" style="zoom:80%;"></p></li></ul></li></ul><h3 id="4、Linux常用命令"><a href="#4、Linux常用命令" class="headerlink" title="4、Linux常用命令"></a>4、Linux常用命令</h3><p>==格式：命令 参数1 参数2…参数n==</p><ul><li>Linux命令由一个命令（command）和<strong>零到多个参数构成</strong>，命令和参数之间，以及参数与参数之间用空格隔开</li><li>命令和参数严格区分大小写</li></ul><h4 id="（1）-ps-用于查看进程"><a href="#（1）-ps-用于查看进程" class="headerlink" title="（1）==ps==用于查看进程"></a>（1）==ps==用于查看进程</h4><p><code>ps -e -f</code>：<code>-e</code>查看所有进程；<code>-f</code>明确显示格式</p><p><code>ps -e -f | wc -l</code>：查看进程个数</p><p>其中<code>ps -e -f</code>与<code>ps -ef</code>作用一样，即多个参数可以合并</p><h4 id="（2）-man-命令查看命令的说明和参数"><a href="#（2）-man-命令查看命令的说明和参数" class="headerlink" title="（2）==man==命令查看命令的说明和参数"></a>（2）==man==命令查看命令的说明和参数</h4><p><code>man ps</code>：查看ps命令的作用和所有参数的作用</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200143538.png" alt="image-20240424200143538" style="zoom:67%;"></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200217701.png" alt="image-20240424200217701" style="zoom: 67%;"></p><h4 id="（3）-date-查看时间"><a href="#（3）-date-查看时间" class="headerlink" title="（3）==date==查看时间"></a>（3）==date==查看时间</h4><p>默认表达式星期 月份 日 具体时间 年</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200249970.png" alt="image-20240424200249970" style="zoom: 67%;"></p><p>格式化显示时间<code>date +'%Y-%m-%d %H:%M:%S'</code></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200405547.png" alt="image-20240424200405547" style="zoom:67%;"></p><p>设置时间<code>date -s "当前时间"</code>：-s参数用于设置时间，时间为string类型</p><h4 id="（4）查看发行版本号cat-etc-release"><a href="#（4）查看发行版本号cat-etc-release" class="headerlink" title="（4）查看发行版本号cat /etc/*release"></a>（4）查看发行版本号<code>cat /etc/*release</code></h4><p>完整的写法<code>cat /etc /redhat-release</code>,两个写法作用一样，经常用星号省略</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200554736.png" alt="image-20240424200554736" style="zoom:67%;"></p><h4 id="（5）退出登录-exit"><a href="#（5）退出登录-exit" class="headerlink" title="（5）退出登录==exit=="></a>（5）退出登录==exit==</h4><p>退出Linux之后，标记会变成红色，显示未连接到服务器，且命令行变成Windows的dos系统</p><h4 id="（6）关机和重启-init"><a href="#（6）关机和重启-init" class="headerlink" title="（6）关机和重启==init=="></a>（6）关机和重启==init==</h4><ul><li>关机命令：<code>init 0</code>、<code>poweroff</code>、<code>shutdown -h now</code>、<code>halt -p</code></li><li>重启命令：<code>init 6</code>、<code>reboot</code>、<code>shutdown -r now</code></li></ul><h2 id="四、Linux文件和文件夹操作基础"><a href="#四、Linux文件和文件夹操作基础" class="headerlink" title="四、Linux文件和文件夹操作基础"></a>四、Linux文件和文件夹操作基础</h2><h3 id="1、对比Windows目录"><a href="#1、对比Windows目录" class="headerlink" title="1、对比Windows目录"></a>1、对比Windows目录</h3><h4 id="（1）win"><a href="#（1）win" class="headerlink" title="（1）win"></a>（1）win</h4><ul><li><p>Windows的目录结构是多个<strong>并列的树状结构</strong></p><p>最顶部是不同的磁盘（分区)，如C，D文件路径都是从盘符开始</p></li><li><p>Windows文件系统里面都是文件或文件夹</p></li><li><p>Windows文件路径是大小写不区分的，层级用\表示</p></li></ul><h4 id="（2）Linux"><a href="#（2）Linux" class="headerlink" title="（2）Linux"></a>（2）Linux</h4><p>没有盘符，一切从/根目录开始，单个的树状结构</p><h3 id="2、Linux常用目录"><a href="#2、Linux常用目录" class="headerlink" title="2、Linux常用目录"></a>2、Linux常用目录</h3><ul><li><p><strong>/         Linux系统的根目录</strong></p></li><li><p><strong>==/etc==      系统管理和配置文件</strong></p><p>例如 profile就是配置文件</p></li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425095459818.png" alt="image-20240425095459818"></p><ul><li><p><strong>==/home==    用户主目录，比如jack用户的主目录就是/home/jack</strong></p><p>linux系统支持多用户，所有用户的主目录都是home</p><p>jack用户在home有jack文件夹，存放jack用户的文件</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425095732037.png" alt="image-20240425095732037"></p></li><li><p><strong>/boot     Linux系统的内核文件放在该目录下</strong></p></li><li><p><strong>==/sbin==     系统管理命令，这里存放的是系统管理员使用的管理程序</strong></p><p>bin代指binary，放的都是可执行文件，所以sbin放的是系统管理程序，每个命令对应一个可执行程序，这个可执行程序就放在这里</p></li><li><p><strong>/root     系统管理员root的家目录</strong></p><ul><li>root用户是超级管理员，它的家目录在/root；普通用户的家目录在/home/username</li><li>且超级管理员的命令提示符是#，普通用户的命令提示符是$</li></ul></li><li><p><strong>==/bin==   常用可执行文件</strong>，主要有：cat，chmod，chown， date，mv，mkdir，cp，bash等</p><p>以cat文件为例：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425100455933.png" alt="image-20240425100455933"></p><p>cat命令的可执行文件就放在这里</p></li><li><p><strong>/dev   设备文件</strong>，如/dev/cd0</p></li><li><p><strong>==/usr==   用户级应用程序和文件几乎都在这个目录下面</strong></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425100558249.png" alt="image-20240425100558249"></p></li><li><p><strong>/proc  一个虚拟文件系统</strong></p><p>放置的数据都是在内存当中，例如系统核心、进程信息（process）、设备状态及网络状态等，特点：开机就存在，关机就消失</p></li><li><p><strong>/tmp   公共的临时文件存储点，存放一些临时文件</strong></p></li><li><p><strong>/lib    一些库文件</strong></p><p>库是别人写好的现有的，成熟的，可以复用的代码</p></li></ul><h3 id="3、Linux文件名和特殊文件"><a href="#3、Linux文件名和特殊文件" class="headerlink" title="3、Linux文件名和特殊文件"></a>3、Linux文件名和特殊文件</h3><h4 id="（1）查看目录下的文件-ls"><a href="#（1）查看目录下的文件-ls" class="headerlink" title="（1）查看目录下的文件==ls=="></a>（1）查看目录下的文件==ls==</h4><ul><li><p>Linux文件名称：大小写敏感，无专用扩展名</p><p>例如：/opt/a2018和/opt/A2018是两个文件</p><p>a.txt表示整个文件名称为a.txt，非文本文件</p></li><li><p>ls命令查看某个目录下有哪些文件和目录（文件夹）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls 列出目录内容</span><br><span class="line">ls -l 以列表方式显示</span><br><span class="line">ls -al 查看该目录下所有内容（包括隐藏文件：以.或..开头的文件）</span><br><span class="line">ls -R 递归显示所有目录</span><br></pre></td></tr></tbody></table></figure></li></ul><p><code>ls</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425101235250.png" alt="image-20240425101235250" style="zoom:67%;"></p><p><code>ls -l</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425101322595.png" alt="image-20240425101322595" style="zoom:67%;"></p><p><code>ls -al</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425101605704.png" alt="image-20240425101605704" style="zoom:67%;"></p><p>  注：如何区分是目录还是文件：<strong>开头是<code>-</code>就是文件，开头是<code>d</code>就是目录</strong></p><p>  <code>ls -R</code>：递归地显示所有目录</p><p>  <img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425140406796.png" alt="image-20240425140406796" style="zoom: 80%;"></p><p>  <code>ls -R</code>和<code>tree</code>很相似</p><p>  <img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425140640049.png" alt="image-20240425140640049" style="zoom: 67%;"></p><h4 id="（2）Linux特殊文件"><a href="#（2）Linux特殊文件" class="headerlink" title="（2）Linux特殊文件"></a>（2）Linux特殊文件</h4><p>不同符号对应的文件含义：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/  表示根目录</span><br><span class="line"></span><br><span class="line">.  表示当前目录</span><br><span class="line"></span><br><span class="line">..  表示当前目录的父目录</span><br><span class="line"></span><br><span class="line">.字符串 表示隐藏文件，如“.bash_profile”文件</span><br></pre></td></tr></tbody></table></figure><h4 id="（3）删除文件或目录指令-rm"><a href="#（3）删除文件或目录指令-rm" class="headerlink" title="（3）删除文件或目录指令==rm=="></a>（3）删除文件或目录指令==rm==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm:用于删除文件或目录</span><br><span class="line">rm -f:force强制删除</span><br><span class="line">rm -r:recursive递归地删除</span><br><span class="line">rm -rf *:强制删除所有文件和目录</span><br><span class="line">或者rm -rf file1 file2 file3：一次删掉多个文件</span><br></pre></td></tr></tbody></table></figure><p>先创建data目录，并在data里创建三个文件三个目录：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425111908016.png" alt="image-20240425111908016" style="zoom:50%;"></p><p>不加参数直接删除：报错，因为目录不为空；删除文件时可以直接删，不加参数</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425111951929.png" alt="image-20240425111951929" style="zoom:67%;"></p><p><code>-r</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425112049419.png" alt="image-20240425112049419" style="zoom:67%;"></p><p>递归式的删除，需要确认每一个文件和目录</p><p><code>-f</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425112147709.png" alt="image-20240425112147709" style="zoom:67%;"></p><p>直接强制删除，不会再让user确认是否删除</p><p><code>rm -rf *</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425112830042.png" alt="image-20240425112830042" style="zoom:67%;"></p><p>删除当前下所有文件</p><h3 id="4、绝对路径与相对路径"><a href="#4、绝对路径与相对路径" class="headerlink" title="4、绝对路径与相对路径"></a>4、绝对路径与相对路径</h3><h4 id="（1）当前目录（创建删除目录命令-mkdir-、-rmdir-）"><a href="#（1）当前目录（创建删除目录命令-mkdir-、-rmdir-）" class="headerlink" title="（1）当前目录（创建删除目录命令==mkdir==、==rmdir==）"></a>（1）当前目录（创建删除目录命令==mkdir==、==rmdir==）</h4><p>就是我们（Shell）所工作的目录</p><ul><li><p>当用户刚登陆系统时，当前目录是用户的家目录/home/username，如果以超级管理员身份登录，那么当前目录就是/root</p></li><li><p>当前目录下的所有文件都可以直接访问，指令都默认作用在当前目录上</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwd:查看当前目录命令</span><br><span class="line">mkdir:创建目录</span><br><span class="line">mkdir -p:parents</span><br><span class="line">mkdir -v:verbose</span><br></pre></td></tr></tbody></table></figure><p><code>-p</code>：在没有www父目录的情况下，无法直接连创两级，但是加上-p参数之后，不会报错，会自动先创建www父目录，再创建子目录<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425110716237.png" alt="image-20240425110716237" style="zoom:80%;"></p><p><code>-v</code>：可以显示目录创建的过程</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425110940253.png" alt="image-20240425110940253" style="zoom:67%;"></p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir:删除目录，必须是空目录才能用这个命名删除,否则报错</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425111206752.png" alt="image-20240425111206752" style="zoom:67%;"></p><h4 id="（2）绝对路径"><a href="#（2）绝对路径" class="headerlink" title="（2）绝对路径"></a>（2）绝对路径</h4><p>开始于根目录，紧跟着目录树的一个个分支，一直到达所期望的目录或文件</p><h4 id="（3）相对路径（切换目录命令-cd-）"><a href="#（3）相对路径（切换目录命令-cd-）" class="headerlink" title="（3）相对路径（切换目录命令==cd==）"></a>（3）相对路径（切换目录命令==cd==）</h4><p>开始于当前目录，紧跟着目录树的一个个分支，一直到达所期望的目录或文件</p><p>“.”（点）和“..”（点点）表示当前目录和父目录</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd目录（相对路径、绝对路径)</span><br><span class="line">cd~切换到家目录</span><br><span class="line">cd ..:切换到父级目录</span><br><span class="line">cd -:2个目录之间切换</span><br></pre></td></tr></tbody></table></figure><h3 id="5、文件操作"><a href="#5、文件操作" class="headerlink" title="5、文件操作"></a>5、文件操作</h3><h4 id="（1）查看文件内容"><a href="#（1）查看文件内容" class="headerlink" title="（1）查看文件内容"></a>（1）查看文件内容</h4><h5 id="1）-cat-：适合查看短文件"><a href="#1）-cat-：适合查看短文件" class="headerlink" title="1）==cat==：适合查看短文件"></a>1）==cat==：适合查看短文件</h5><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425114246630.png" alt="image-20240425114246630" style="zoom:67%;"></p><h5 id="2）-less-：查看长文件"><a href="#2）-less-：查看长文件" class="headerlink" title="2）==less==：查看长文件"></a>2）==less==：查看长文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以通过快捷键查看翻页：</span><br><span class="line"> k向上一行</span><br><span class="line"> j向下一行</span><br><span class="line"> Page up向上一页</span><br><span class="line"> Page down向下一页</span><br><span class="line"> q退出</span><br></pre></td></tr></tbody></table></figure><h5 id="3）-head-：用于查看文件的头部n行"><a href="#3）-head-：用于查看文件的头部n行" class="headerlink" title="3）==head==：用于查看文件的头部n行"></a>3）==head==：用于查看文件的头部n行</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head -n filename看文件的前n行</span><br><span class="line">没有指定多少行的时候，默认查看10行</span><br></pre></td></tr></tbody></table></figure><p>看文件的前5行：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425114313418.png" alt="image-20240425114313418" style="zoom:67%;"></p><p>查看前5位用户：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425114448067.png" alt="image-20240425114448067" style="zoom:67%;"></p><h5 id="4）-tail-：用于查看文件的尾部n行"><a href="#4）-tail-：用于查看文件的尾部n行" class="headerlink" title="4）==tail==：用于查看文件的尾部n行"></a>4）<strong>==tail==：用于查看文件的尾部n行</strong></h5><p><code>tail -f</code> ：用于实时监控日志</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tail -n filename看文件的末尾n行</span><br><span class="line">没有指定多少行的时候，默认查看10行</span><br><span class="line"></span><br><span class="line">-f：follow实时查看文件的内容，因为某些日志文件的尾部数据会一直改变</span><br></pre></td></tr></tbody></table></figure><p>看文件后6行：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425114601527.png" alt="image-20240425114601527" style="zoom:67%;"></p><p><code>-f</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425114941164.png" alt="image-20240425114941164" style="zoom:67%;"></p><p>默认查看后10行，但区别是加了参数<code>-f</code>之后，查询结果不固定，光标一直闪烁，如果数据更新，会显示新数据</p><h4 id="（2）通配符，模糊指代"><a href="#（2）通配符，模糊指代" class="headerlink" title="（2）通配符，模糊指代"></a>（2）通配符，模糊指代</h4><p>通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件</p><div class="table-container"><table><thead><tr><th>模式</th><th>匹配对象</th></tr></thead><tbody><tr><td>*</td><td>所有文件</td></tr><tr><td>g*</td><td>文件名以g开头的文件</td></tr><tr><td>b*.txt</td><td>以b开头，中间有零个或任意多个字符，并以.txt结尾的文件</td></tr><tr><td>Data???</td><td>以Data开头，后面紧跟3个字符的文件文件名</td></tr><tr><td>[abc]*</td><td>以a，b或c开头的文件</td></tr></tbody></table></div><p>例如：</p><p>删除文件名为六个字符的文件</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ??????</span><br></pre></td></tr></tbody></table></figure><p>删除以file开头的所有文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf file*</span><br></pre></td></tr></tbody></table></figure><p>删除以test开头，中间有任意字符且以.sh结尾的文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf file*.sh</span><br></pre></td></tr></tbody></table></figure><p>删除以f或t开头的所有文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf [ft]*</span><br></pre></td></tr></tbody></table></figure><h4 id="（3）创建文件"><a href="#（3）创建文件" class="headerlink" title="（3）创建文件"></a>（3）创建文件</h4><h5 id="1）-touch"><a href="#1）-touch" class="headerlink" title="1）==touch=="></a>1）==touch==</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch /home/test/file01:在指定目录下新建空文件file01</span><br><span class="line">touch file02:在当前目录下新建空文件file02</span><br><span class="line">touch file01 file02 /home/test/file03：可以同时创建多个文件</span><br></pre></td></tr></tbody></table></figure><h5 id="2）-vi"><a href="#2）-vi" class="headerlink" title="2）==vi=="></a>2）==vi==</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi file01创建号文件后直接进入编辑模式</span><br><span class="line">insert打开插入模式</span><br><span class="line">编辑文件</span><br><span class="line">按esc进入底线模式</span><br><span class="line">:wq wirte quit保存并退出</span><br></pre></td></tr></tbody></table></figure><h5 id="3）-gt-（重定向符号）"><a href="#3）-gt-（重定向符号）" class="headerlink" title="3）==>==（重定向符号）"></a>3）==<strong>&gt;</strong>==（重定向符号）</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以通过重定向符号新建文件</span><br><span class="line"></span><br><span class="line">后面学</span><br><span class="line">比如将file01的前20行重定向到file_mini中：</span><br><span class="line">head -20 ./file01 &gt; file_mini</span><br></pre></td></tr></tbody></table></figure><h5 id="4）底线模式新建文件"><a href="#4）底线模式新建文件" class="headerlink" title="4）底线模式新建文件"></a>4）底线模式新建文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">还可以通过底线模式，将文件的某一段截取出来放到新文件里</span><br><span class="line">在底线模式下</span><br><span class="line">:2,12 w newfile</span><br><span class="line">表示将该文件的第2行到第12行的内容放入newfile文件中</span><br></pre></td></tr></tbody></table></figure><h4 id="（4）复制文件、目录-cp"><a href="#（4）复制文件、目录-cp" class="headerlink" title="（4）复制文件、目录==cp=="></a>（4）复制文件、目录==cp==</h4><ul><li><p><strong>复制文件命令：cp 源文件 目标文件</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cp file01 file01_backup</span><br><span class="line">将file01中的文件复制到file01_backup中（同一目录下不能同名）</span><br><span class="line"></span><br><span class="line">cp file01 /home/test/ </span><br><span class="line">将file01中的文件复制到/home/test目录下，默认不同目录下源文件和目标文件可以同名</span><br><span class="line"></span><br><span class="line">cp file01 /home/test/file02</span><br><span class="line">也可以指定名字</span><br><span class="line"></span><br><span class="line">cp file* /home/test</span><br><span class="line">利用通配符，可以将所有file+任意字符的所有文件一次性复制到指定目录</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>复制目录</strong></p><p>复制目录必须参数<code>-r</code>,否则报错</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复制目录</span><br><span class="line">cp -r dir01 dir02：当前目录复制，源和目标目录名称必须不同</span><br><span class="line">cp -r file01 dir01 /home/jim/dir02：源可以是多个文件、或目录，可以把多个目录或文</span><br><span class="line">件复制到目标目录中</span><br><span class="line">参数-r或-R都有效</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="（5）移动、重命名文件和目录-mv"><a href="#（5）移动、重命名文件和目录-mv" class="headerlink" title="（5）移动、重命名文件和目录==mv=="></a>（5）移动、重命名文件和目录==mv==</h4><ul><li><p><strong>重命名文件和目录</strong></p><p>mv：源地址和目的地址==相同==就是重命名</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv file01 file02#重命名文件file01为file02</span><br><span class="line">mv dir01 dir02#重命名目录dir01为dir02</span><br><span class="line">mv dir01/file01 dir01/file02#重命名文件file01为file02</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>移动文件和目录</strong></p><p>mv：源地址和目的地址==不同==就是移动</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mv file01 dir01/  </span><br><span class="line">移动file01到dir01目录</span><br><span class="line"></span><br><span class="line">mv file01 dir01/file02</span><br><span class="line">移动file01到dir01目录且重命名为file02</span><br><span class="line"></span><br><span class="line">mv file01 file02 dir01 dir02</span><br><span class="line">移动file01、file02、dir01到dir02</span><br><span class="line">(此时dir02必须存在，因为无法重命名多个文件或目录，只有移动)</span><br><span class="line">不然会报错，如下图所示</span><br><span class="line"></span><br><span class="line">mv dir01 dir02</span><br><span class="line">如果dir02不存在，则重命名，如果dir02存在，则移动目录dir01到dir02目录下</span><br></pre></td></tr></tbody></table></figure></li></ul><p>  <img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425154330400.png" alt="image-20240425154330400" style="zoom:50%;"></p><h4 id="（6）文件链接-ln"><a href="#（6）文件链接-ln" class="headerlink" title="（6）文件链接==ln=="></a>（6）文件链接==ln==</h4><h5 id="1）文件链接概念"><a href="#1）文件链接概念" class="headerlink" title="1）文件链接概念"></a>1）文件链接概念</h5><p>我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。</p><ul><li><p>用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；</p></li><li><p>元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。</p></li></ul><p>在 Linux 中，元数据中的 <strong>inode 号</strong>（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的<strong>唯一标识</strong>而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。</p><p>下图展示了程序通过文件名获取文件内容的过程。</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425155918428.png" alt="image-20240425155918428" style="zoom: 67%;"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看文件inode命令：stat或ls -i</span><br><span class="line"></span><br><span class="line">[root@localhost test]# ls -i file01</span><br><span class="line">34355716 file01</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425160200351.png" alt=""></p><h5 id="2-为什么需要链接？"><a href="#2-为什么需要链接？" class="headerlink" title="2) 为什么需要链接？"></a>2) 为什么需要链接？</h5><ul><li>实现文件的<strong>共享</strong>使用（原因:不能移动，其他文件使用时只能通过链接访问)</li><li>提供了隐藏文件路径、增加权限<strong>安全</strong>及<strong>节省存储</strong>等好处</li><li>和复制的区别:文件在磁盘中只有一个拷贝，节省磁盘空间</li></ul><h5 id="3）链接的种类与创建"><a href="#3）链接的种类与创建" class="headerlink" title="3）链接的种类与创建"></a>3）链接的种类与创建</h5><p>硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）</p><ul><li><p>创建硬链接： <code>ln filename filename-hardlink</code></p><p>硬链接和源文件属性一样</p></li><li><p>创建软链接： <code>ln -s filename filename-softlink</code></p></li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425155637496.png" style="zoom:67%;"></p><h5 id="4）软硬链接的区别"><a href="#4）软硬链接的区别" class="headerlink" title="4）软硬链接的区别"></a>4）软硬链接的区别</h5><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425160631740.png" style="zoom:67%;"></p><p>详细区别：</p><p><strong>硬链接</strong>：若—个inode号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是==同一个文件使用了多个别名==</p><ul><li><p><strong>文件有相同的inode 及 data block;</strong></p><p>查询硬链接inode号：和源文件一样，硬链接的data block保存的就是源文件的文件内容</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425160455936.png" style="zoom:67%;"></p><p>查询软连接iNode号：和源文件不一样，软链接的data block保存了源文件的路径名的指向</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425160534653.png" style="zoom:67%;"></p><p>硬链接data block大小与源文件一致，软链接则不一样</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425162215724.png" style="zoom:67%;"></p></li><li><p><strong>只能对已存在的文件进行创建;</strong></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425161954624.png"></p></li><li><p><strong>不能跨文件系统进行硬链接的创建;</strong><br>不同文件所使用的文件系统不一样,/dev使用的是devtmpfs文件系统，/dev/shm使用的则是tmpfs文件系统</p><p>查看文件系统指令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -Th</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425164719117.png" alt="image-20240425164719117" style="zoom:67%;"></p><p> 硬链接跨系统创建失败：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425164839326.png" alt="image-20240425164839326"></p><p> 软链接可以：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425164927185.png" alt="image-20240425164927185" style="zoom:67%;"></p></li><li><p><strong>不能对目录进行创建，只可对文件创建；</strong></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425164538159.png" alt="image-20240425164538159" style="zoom: 67%;"></p></li><li><p><strong>删除一个硬链接文件并不影响其他有相同 inode 号的文件</strong></p><ul><li><p>就算删掉源文件，源文件的硬链接依旧可以使用，这就达到了备份的效果</p></li><li><p>源文件删除之后，即使新建了一个同名源文件之后，由于inode号改变，新文件和源硬链接已经不存在链接关系</p></li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425165738696.png" alt="image-20240425165738696" style="zoom:67%;"></p></li></ul><p><strong>软链接（符号链接）</strong>：若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软链接。==软链接就是一个普通文件，只是数据块内容有点特殊==。类似于Windows的快捷方式</p><ul><li>软链接<u>有自己的文件属性及权限</u>等；</li><li>可对不存在的文件或目录创建软链接；</li><li>软链接可交叉文件系统；</li><li>软链接<strong>可对文件或目录创建</strong>；</li><li>创建软链接时，链接计数 i_nlink 不会增加；</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为<strong>死链接</strong>（即 <strong>dangling link</strong>（创建一个和源文件同名同地址的新文件后，<strong>死链接可恢复</strong>为正常的软链接）。</li></ul><p>对源文件的修改，软、硬链接文件内容也一样的修改，因为都是指向同一个文件的内容。</p><h5 id="5）链接文件作用"><a href="#5）链接文件作用" class="headerlink" title="5）链接文件作用"></a>5）链接文件作用</h5><ul><li>硬链接：相当于同一个文件有多个别名，每个别名背后对应的是同一个文件，inode相同，但在存储的时候，只会在磁盘上存一份（跟复制两个文件不同)，可以节约存储空间。</li><li>软链接：相当于快捷方式，软链接文件和目标文件是两个不同的文件，但软链接文件指向的是目录文件。</li></ul><h5 id="6）什么情况下需要创建链接-使用场景"><a href="#6）什么情况下需要创建链接-使用场景" class="headerlink" title="6）什么情况下需要创建链接?使用场景"></a>6）什么情况下需要创建链接?使用场景</h5><ul><li><p>硬链接<br>对于有些重要文件,为了防止被用户意外删除或出于该目录的权限考虑，可以为该文件在其他目录中建立硬链接，让其他用户访问，实现重要文件的备份和共享。</p></li><li><p>软链接<br>为了在任意目录下都可以执行python命令，可以通过两种方式实现<br>1）把/usr/local/python3/bin添加到<strong>环境变量PATH</strong>中</p><ul><li>环境变量PATH作用：在终端执行命令的时候，会从PATH环境变量的每个目录下查找命令的可执行文件，找不到就会显示commend not found<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425171704558.png" alt="image-20240425171704558" style="zoom:67%;"></li><li>把/usr/local/python3/bin添加到环境变量PATH中</li></ul><p>2）配置软链接</p><p>可以在/usr/bin目录下创建一个软链接文件python指向/usr/local/python3/bin/python3.7，<br>因为/usr/bin目录默认就是在环境变量PATH中，所以这样就可以直接执行python命令</p></li></ul><h4 id="（7）查找文件"><a href="#（7）查找文件" class="headerlink" title="（7）查找文件"></a>（7）查找文件</h4><h5 id="1）-which"><a href="#1）-which" class="headerlink" title="1）==which=="></a>1）==which==</h5><p>which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果；Linux系统中，每个命令都有可执行文件</p><p>which用来==查找可执行文件的位置==、显示命令所在路径；</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：which 系统命令</span><br><span class="line">举例：which vi</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426101041139.png" alt="image-20240426101041139" style="zoom:67%;"></p><h5 id="2）-whereis"><a href="#2）-whereis" class="headerlink" title="2）==whereis=="></a>2）==whereis==</h5><p>whereis 命令则是用来快速查找程序的==二进制文件==、==源代码==和==man手册文件==的路径；</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：whereis 系统命令</span><br><span class="line">举例：whereis vi</span><br></pre></td></tr></tbody></table></figure><p> 查找那么找到的结果就比which vi命令找到的结果多，因为which命令只会列出二进制文件路径，而whereis命令会把vi的二进制文件、源代码、帮助手册都返回</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426104901689.png" alt="image-20240426104901689"></p><h5 id="3）-find"><a href="#3）-find" class="headerlink" title="3）==find=="></a>3）==find==</h5><p>find命令会在==指定目录及其子目录下==查找符合条件的特定文件，当我们忘记文档路径时，可以使用该命令</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法：find 目录名 条件</span><br><span class="line">举例：find /home/tom -name test.sh</span><br><span class="line">     find / -name test.sh</span><br><span class="line">条件</span><br><span class="line">-name文件名</span><br><span class="line">-type文件or目录：文件用f，目录用d</span><br><span class="line">-atime -5 :5天内访问过的</span><br><span class="line">-atime +5:5天前访问过的</span><br><span class="line">-amin -5:5分钟内访问过的</span><br><span class="line">-amin +5:5分钟之前访问过的</span><br></pre></td></tr></tbody></table></figure><p>例如：在/test目录下，查找以file开头的文件</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426101619083.png" alt="image-20240426101619083" style="zoom:67%;"></p><p>在当前目录下，查找以d开头的所有<strong>目录</strong></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426101952954.png" alt="image-20240426101952954" style="zoom:67%;"></p><p>atime、amin举例</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426102608535.png" alt="image-20240426102608535" style="zoom: 67%;"></p><h4 id="（8）文本关键字搜索-grep"><a href="#（8）文本关键字搜索-grep" class="headerlink" title="（8）文本关键字搜索 ==grep=="></a>（8）文本关键字搜索 ==grep==</h4><p>一种强大的文本搜索工具，并把匹配的行打印出来。用于==查看日志==、==查看命令输出==。且grep默认<strong>关键字大小写敏感、支持正则表达式</strong>。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">命令格式：grep 要搜索的关键字 文件</span><br><span class="line">比如：grep root /var/log/message</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-c：count 只输出匹配行的行数（有多少行匹配）</span><br><span class="line">-i：ignore case不区分大小写</span><br><span class="line">-n：line-number 只显示匹配行及行号</span><br><span class="line">-v：invert-match 显示不含匹配文本的所有行</span><br><span class="line">-F：指明pattern非正则表达式</span><br><span class="line">-E：指明pattern正则表达式</span><br></pre></td></tr></tbody></table></figure><h5 id="1）参数说明"><a href="#1）参数说明" class="headerlink" title="1）参数说明"></a>1）参数说明</h5><ul><li><p>基本举例：新建一个file11，输入内容如下： </p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426105746796.png" alt="image-20240426105746796" style="zoom:67%;"></p><ul><li>用grep查找file11中包含line的内容</li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426105907240.png" alt="image-20240426105907240" style="zoom:67%;"></p></li><li><p>参数<code>-c</code>：只输出匹配行的行数（有多少行匹配）</p><ul><li>查询file11中包含line的内容有几行</li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426110206150.png" alt="image-20240426110206150" style="zoom:67%;"></p><ul><li><p>==如何统计文件里一共多少行==</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c "" file11</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426111909462.png" alt="image-20240426111909462" style="zoom:67%;"></p></li></ul></li><li><p>参数<code>-i</code>：（ignore capital）不区分大小写，默认严格区分大小写，例如，查包含line的关键词，区分大小写时有两条，不区分大小写时有六行</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426110412644.png" alt="image-20240426110412644" style="zoom:67%;"></p></li><li><p>参数<code>-n</code>：（number）只显示匹配行及行号</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426110531032.png" alt="image-20240426110531032" style="zoom: 67%;"></p></li><li><p>参数<code>-v</code>：（invert match反选）显示不含匹配文本的所有行</p><p>显示不包含line的行，且不区分line的大小写</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426110711799.png" alt="image-20240426110711799" style="zoom:50%;"></p></li><li><p>参数<code>-E</code>：指明pattern正则表达式</p><ul><li><p>==用于查看日志文件中的错误信息==</p><p>包含关键字: error或者exception或者fatal，加<code>-i</code>不区分大小写，因为有的ERROR是大写，有的是小写</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i -E "error|exception|fatal" 文件名</span><br></pre></td></tr></tbody></table></figure></li></ul><p>参数<code>-F</code>：指明pattern非正则表达式</p></li></ul><h5 id="2）grep命令特殊符例子"><a href="#2）grep命令特殊符例子" class="headerlink" title="2）grep命令特殊符例子"></a>2）grep命令特殊符例子</h5><ul><li><p>搜索以line开头的行：<code>^</code>符号</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep "^line" file11</span><br><span class="line">显示行号：grep -n "^line" file11</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426112623072.png" alt="image-20240426112623072" style="zoom:67%;"></p></li><li><p>搜索以”行”字结尾的行：<code>$</code>符号</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep "line$" file11</span><br><span class="line">显示行号：grep -n "行$" file11</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426112912986.png" alt="image-20240426112912986" style="zoom: 67%;"></p></li><li><p>搜索当前目录下以f开头的文件中，包含line关键字的所有行：<code>*</code>符号</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep "line" ./f*</span><br><span class="line">显示行号且不区分大小写：grep -n -i "line" ./f*</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426113303223.png" alt="image-20240426113303223" style="zoom:67%;"></p></li><li><p>在目录及子目录下查找包含关键字的行：<code>-r</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n -i "line" -r ./dir0</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426114227362.png" alt="image-20240426114227362" style="zoom:67%;"></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426114410375.png" alt="image-20240426114410375" style="zoom:67%;"></p></li><li><p>grep最常用的用法，查看某个进程，比如查看tomcat、nginx进程</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep tomcat</span><br><span class="line">-ef:-e查看所有进程; -f明确显示格式</span><br><span class="line">| :管道符</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426114636422.png" alt="image-20240426114636422" style="zoom:50%;"></p></li></ul><h4 id="（9）统计文件内容-wc"><a href="#（9）统计文件内容-wc" class="headerlink" title="（9）统计文件内容==wc=="></a>（9）统计文件内容==wc==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wc 参数 文件</span><br><span class="line">参数：</span><br><span class="line">-l多少行: wc -l ./file02：统计当前目录下file02文件有多少行</span><br><span class="line">-c多少个字节: wc -c /etc/passwd：统计/etc/passwd文件有多少个字节</span><br><span class="line">通常带着管道符一起使用：</span><br><span class="line">例如：统计有多少进程正在运行</span><br><span class="line">ps -ef |wc -l</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426140638480.png" alt="image-20240426140638480" style="zoom:67%;"></p><p>统计root下有多少进程正在运行：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426140916165.png" alt="image-20240426140916165" style="zoom: 80%;"></p><h4 id="（10）查看目录-文件占用的磁盘空间-du、df"><a href="#（10）查看目录-文件占用的磁盘空间-du、df" class="headerlink" title="（10）查看目录/文件占用的磁盘空间 ==du、df=="></a>（10）查看目录/文件占用的磁盘空间 ==du、df==</h4><p>1）<code>du</code>命令是查看==文件或目录的磁盘使用空间==，即占用磁盘大小</p><p>2）<code>du</code>使用的情形：比如，服务器磁盘空间不够用了，已经被占用了80%以上，就会出现服务器响应速度很慢，需要清理磁盘空间</p><p>具体操作：</p><ul><li><p>用<code>df</code>查看==文件系统==的磁盘使用情况，比如总空间多大、使用了多少，可用空间多少、使用率等信息；</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df</span><br><span class="line">参数</span><br><span class="line">-T：显示文件类型</span><br><span class="line">-h：可读</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426142338539.png" alt="image-20240426142338539" style="zoom:67%;"></p><p>加参数<code>-T</code>：会显示type，文件类型</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426143258411.png" alt="image-20240426143258411" style="zoom:67%;"></p><p>加参数<code>-h</code>：可读，发现根目录下占用磁盘空间最大，所以<code>cd /</code>，进入磁盘，查看情况</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426143410604.png" alt="image-20240426143410604" style="zoom: 50%;"></p></li><li><p>进入占用磁盘空间最大的目录，用<code>du -sh ./*</code>统计来排查到底是那个文件，然后进入这个文件进一步查看，可以再进<code>./local</code>，再又用<code>du -sh ./*</code></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426143655028.png" alt="image-20240426143655028" style="zoom:67%;"></p></li><li><p>最后通过<code>rm -rf 文件</code></p></li></ul><p>3）语法和参数</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：du -sh 文件名或者目录名</span><br><span class="line">参数：</span><br><span class="line">-a：统计所有文件或目录</span><br><span class="line">-h：human-readable，在打印文件大小时，用k，m，g等可读方式展示</span><br><span class="line">-s：summarize</span><br></pre></td></tr></tbody></table></figure><ul><li><p>参数<code>-a</code>：展示当前目录下所有文件和目录的大小</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426141550025.png" alt="image-20240426141550025" style="zoom:67%;"></p></li><li><p>参数<code>-h</code>：以<strong>可读</strong>方式展现所占内存大小</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426141513769.png" alt="image-20240426141513769" style="zoom:67%;"></p></li><li><p>参数<code>-s</code>：当前目录总的大小为44</p></li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426141442627.png" alt="image-20240426141442627" style="zoom: 67%;"></p><h3 id="6、Linux文本编辑器-vi"><a href="#6、Linux文本编辑器-vi" class="headerlink" title="6、Linux文本编辑器==vi=="></a>6、Linux文本编辑器==vi==</h3><h4 id="（1）vi-vim概述"><a href="#（1）vi-vim概述" class="headerlink" title="（1）vi/vim概述"></a>（1）vi/vim概述</h4><ul><li>vi/vim是所有Linux系统都提供的文本编辑器，它提供了一个窗口，通过它可以编辑文件；</li><li>vim是vi的增强版本，支持vi的全部功能<ul><li>vim命令更多</li><li>vim有增强功能包括颜色标记功能，更方便</li></ul></li></ul><h4 id="（2）vi格式"><a href="#（2）vi格式" class="headerlink" title="（2）vi格式"></a>（2）vi格式</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi  文件名</span><br><span class="line">vim 文件名</span><br></pre></td></tr></tbody></table></figure><p>如果文件已存在，则打开并编辑文件，底部提示文件多少行，多少字节</p><p>如果文件不存在，则新建并编辑文件，底部提示new file</p><p>常用操作：</p><h5 id="1）修改环境变量："><a href="#1）修改环境变量：" class="headerlink" title="1）修改环境变量："></a>1）修改环境变量：</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">shift +g快速移动到最后一行</span><br><span class="line">insert进入插入模式</span><br><span class="line">编辑文件，例如：export PATH=$PATH:/home/test</span><br><span class="line">ESC到底线模式</span><br><span class="line">：wq保存退出</span><br></pre></td></tr></tbody></table></figure><h5 id="2）修改tomcat、Nginx配置文件"><a href="#2）修改tomcat、Nginx配置文件" class="headerlink" title="2）修改tomcat、Nginx配置文件"></a>2）修改tomcat、Nginx配置文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim application.yml 进入配置文件</span><br><span class="line">:/port 定位到port，输入n可以下移，找到要修改的port</span><br><span class="line">i 进入插入模式</span><br><span class="line">编辑文件，修改port</span><br><span class="line">ESC到底线模式</span><br><span class="line">：wq保存退出</span><br></pre></td></tr></tbody></table></figure><h5 id="3）启动时报错，如何修改报错代码"><a href="#3）启动时报错，如何修改报错代码" class="headerlink" title="3）启动时报错，如何修改报错代码"></a>3）启动时报错，如何修改报错代码</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim application.yml</span><br><span class="line">:20进入底线模式，定位到第20行（假设第20行报错）</span><br><span class="line">insert进入插入模式</span><br><span class="line">修改报错代码</span><br><span class="line">ESC到底线模式</span><br><span class="line">：wq保存退出</span><br></pre></td></tr></tbody></table></figure><h4 id="（3）三种模式"><a href="#（3）三种模式" class="headerlink" title="（3）三种模式"></a>（3）三种模式</h4><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426150327095.png" alt="image-20240426150327095" style="zoom:67%;"></p><h5 id="1）命令模式command-mode"><a href="#1）命令模式command-mode" class="headerlink" title="1）命令模式command mode"></a>1）命令模式command mode</h5><ul><li><p>刚进入时的默认模式就是命令模式</p></li><li><p>命令模式的特点：</p><ul><li><p>此时不可以直接添加文字</p></li><li><p>不能用退格删除文字</p></li><li><p><strong>==控制光标的快速移动==</strong></p><ul><li>快速移动到最后一行的行首：==<code>shift+G</code>==</li><li>快速移动到第一行行首：==<code>GG</code>==</li><li>移动光标到当前行的行尾：==<code>shift+$</code>==</li><li>移动光标到当前行的行首：==<code>shift+^</code>==</li></ul></li><li><p><strong>可以进行字符的删除、复制、粘贴</strong></p><p><code>x</code>：删除</p><ul><li><p>x是往后删，相当于delete键，X是往前删，相当于Backspace键</p></li><li><p>3x表示删除光标所在位置开始的3个字符，包括光标所在位置</p></li><li><p>如果输入命令错误，可以按Esc键取消</p></li></ul><p><code>dw</code>：删除光标所在处直到词尾的内容</p><p><code>dd</code>：删除光标所在行</p><ul><li>3dd表示删除从光标所在行开始的3行，包括光标所在行</li></ul><p><code>yw</code>：复制光标所在处到词尾的内容</p><p><code>yy</code>：复制光标所在行</p><ul><li>3yy表示复制3行</li></ul><p><code>p</code>：粘贴</p></li><li><p><strong>替换、撤销</strong></p><p><code>r</code>：替换光标所在处的字符</p><p><code>shift + r</code>：连续替换字符直到按ESC为止</p><p><code>u</code>：假如误操作一个命令，可以马上按u进行撤销，可以连续按u撤销多个之前做出的操作（等于Windows下的ctrl + z）</p><p><code>Ctrl + r</code>：反撤销</p></li></ul></li></ul><h5 id="2）底线模式"><a href="#2）底线模式" class="headerlink" title="2）底线模式"></a>2）底线模式</h5><p>在命令模式下输入冒号进入底线模式</p><p>==<strong>1))、查找、定位</strong>==</p><ul><li>==<code>:set nu</code>== 在每一行的行首显示行号</li><li>==<code>:set nonu</code>== 关闭显示行号</li><li>==<code>:n</code>== n是你要输入的数字，再按回车，光标将跳转到数字指定的行</li><li>==<code>:/关键字</code>==先按/，再输入你要查找的字符<ul><li>找到所有关键字后，光标默认指向第一个，可以输入<code>n</code>（next），向下继续查找</li><li><code>shift+n</code>是往上查找</li><li><code>set ic</code>：查找关键字时，设置忽略大小写（ignore capital）</li><li><code>set noic</code>：查找关键字时，设置不忽略大小写（not ignore capital）</li></ul></li></ul><p>==<strong>2))、字符替换</strong>==</p><ul><li>在底线模式下输入<code>1,$s/oldstring/newstring/g</code>会将全文的oldstring字符串替换成newstring字符串<ul><li>1,$表示从第一行到最后一行</li><li>s表示替换</li><li>g表示每行全部替换</li></ul></li></ul><p>或者简写成：<code>%s/oldstring/newstring/g</code></p><p>eg.将文件里的LINE全部替换为line</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426153805604.png" alt="image-20240426153805604" style="zoom:67%;"></p><ul><li><p>指定行：</p><p><code>:1,20s/oldstring/newstring/g</code>将1至20行间的oldstring替换成newstring字符串</p></li></ul><p><strong>3))、编辑完成之后的==保存、退出==</strong></p><ul><li><code>:起始行号,结尾行号 w 文件名</code> 如果你想摘取文件的某一段，存为另一个文件，可以使用这个指令，例如：<code>30,50 w nice</code>代表将30到50行摘录下来，并另存为nice文件</li><li><code>:w</code> 新文件名 将文件<strong>另存为</strong>新文件</li><li><code>:wq</code> <strong>保存</strong>并退出</li><li><code>:q!</code> 强制退出vi并<strong>不保存</strong>当前的修改内容</li></ul><h5 id="3）插入模式"><a href="#3）插入模式" class="headerlink" title="3）插入模式"></a>3）插入模式</h5><p>进入插入模式：insert、i、a、o都可以进入</p><p>三者的区别在于：insert和i进入插入模式，光标不会移动；a进入插入模式，光标向后移动一位；o进入插入模式，光标向下移动一行</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、操作系统&quot;&gt;&lt;a href=&quot;#一、操作系统&quot; class=&quot;headerlink&quot; title=&quot;一、操作系统&quot;&gt;&lt;/a&gt;一、操作系统&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;操作系统（Operating System，OS）：管理硬件和应用程序的一套==系统软件==。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作系统的作用： CPU管理、内存管理、文件系统管理、进程管理、外设管理、用户管理…（&lt;em&gt;理解：表现出来就是让CPU可以开始判断逻辑与运算数值，让内存可以开始加载/读出数据与程序代码，让硬盘可以开始被访问，让网卡可以开始传输数据，让所有周边设备可以开始运转等，总之硬件的所有操作都必须要通过操作系统来完成。&lt;/em&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个操作系统的核心叫==内核==，操作系统的各项功能都是通过内核实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424195236588-1714013539134.png&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1、常见的操作系统：&quot;&gt;&lt;a href=&quot;#1、常见的操作系统：&quot; class=&quot;headerlink&quot; title=&quot;1、常见的操作系统：&quot;&gt;&lt;/a&gt;1、常见的操作系统：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DoS：个人电脑；&lt;/li&gt;
&lt;li&gt;Windows：个人电脑，Windows7、Windows10、WindowsServer；&lt;/li&gt;
&lt;li&gt;Mac OS X：MacBook系列笔记本；&lt;/li&gt;
&lt;li&gt;Android：安卓手机、平板、机顶盒、智能电视机、手环；&lt;/li&gt;
&lt;li&gt;ios：iPhone、iPad、iWatch、iPod等；&lt;/li&gt;
&lt;li&gt;Unix（服务器）&lt;/li&gt;
&lt;li&gt;Linux：免费、可靠、安全、稳定、多平台；（服务器）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2、操作系统之间的关系&quot;&gt;&lt;a href=&quot;#2、操作系统之间的关系&quot; class=&quot;headerlink&quot; title=&quot;2、操作系统之间的关系&quot;&gt;&lt;/a&gt;2、操作系统之间的关系&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424195349886.png&quot; alt=&quot;image-20240424195349886&quot; style=&quot;zoom:67%;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;3、主要学习Linux原因：&quot;&gt;&lt;a href=&quot;#3、主要学习Linux原因：&quot; class=&quot;headerlink&quot; title=&quot;3、主要学习Linux原因：&quot;&gt;&lt;/a&gt;3、主要学习Linux原因：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;大部分软件都运行在Linux上&lt;ul&gt;
&lt;li&gt;Linux作为服务器的操作系统，大部分软件都运行在Linux操作系统上;&lt;/li&gt;
&lt;li&gt;互联网Web服务、物联网、车联网、大数据、云计算服务、人工智能、智能运维等各个方面都广泛应用;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工作中要用Linux&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Linux" scheme="https://laylaycjl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>测试报告</title>
    <link href="https://laylaycjl.github.io/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/"/>
    <id>https://laylaycjl.github.io/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/</id>
    <published>2024-04-24T10:50:21.000Z</published>
    <updated>2024-04-24T12:16:00.928Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>什么是测试报告？</p><p>测试报告是测试人员在<strong>完成整个系统的测试工作之后</strong>所撰写的文档，该文档可以反映测试<strong>过程</strong>与测试<strong>结果</strong>，是对阶段性测试任务的<u>总结</u>。</p></li><li><p>测试报告作用？</p><ul><li>可以评估项目当前状态和产品质量</li><li>确定产品是否准备好发布的最终文档</li></ul></li></ul><h2 id="一、测试报告的几大要素"><a href="#一、测试报告的几大要素" class="headerlink" title="一、测试报告的几大要素"></a>一、测试报告的几大要素</h2><h3 id="1、人力投入"><a href="#1、人力投入" class="headerlink" title="1、人力投入"></a>1、人力投入</h3><p>对不同测试阶段所花的时间有清晰记录</p><p>eg. 测试用例编写：人员、工作量</p><p>测试执行：人员、工作量</p><h3 id="2、用例覆盖度"><a href="#2、用例覆盖度" class="headerlink" title="2、用例覆盖度"></a>2、用例覆盖度</h3><p>==用例覆盖率=（pass+fail）/总用例数==</p><p>用例状态：pass（通过）、fail（未通过）、NT（not test尚未测试）、block（阻塞，暂时没有条件执行）、investigate（观察中，正在测试）</p><p>eg.pass和fail一共251，总用例263个</p><p>用例覆盖率=251/263=95%</p><h3 id="3、缺陷统计"><a href="#3、缺陷统计" class="headerlink" title="3、缺陷统计"></a>3、缺陷统计</h3><ul><li><p>bug严重等级：其中致命bug少的原因——开发自测和冒烟测试已经筛掉了大部分致命bug</p></li><li><p>功能型bug最多</p></li><li><p>bug状态：激活、已解决、已关闭</p><p>==缺陷遗留率=（激活+已解决）/总bug数==</p><p>只认准已关闭的bug为已解决</p></li><li><p>bug来源：一般是需求、编码类bug较多</p></li></ul><h3 id="4、缺陷遗留问题"><a href="#4、缺陷遗留问题" class="headerlink" title="4、缺陷遗留问题"></a>4、缺陷遗留问题</h3><p>缺陷遗留率：是否达标? 3%、一般、提示没有关闭的缺陷数/缺陷总数</p><ul><li>对于影响大的问题，不能遗留，需要在当前版本立马解决</li><li>对于某些兼容性问题且只有ie6浏览器会出现问题时，可以忽略，因为有规避措施，换浏览器就可以解决</li></ul><span id="more"></span><h3 id="5、测试结论"><a href="#5、测试结论" class="headerlink" title="5、测试结论"></a>5、测试结论</h3><p>测试结论应该明确</p><h2 id="二、测试报告书写格式"><a href="#二、测试报告书写格式" class="headerlink" title="二、测试报告书写格式"></a>二、测试报告书写格式</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1编写目的"><a href="#1-1编写目的" class="headerlink" title="1.1编写目的"></a>1.1编写目的</h4><p>1）本报告按照<strong>项目的技术要求反映</strong>项目的测试结果。</p><p>2）阅读对象为项目组所有成员及其相关授权的人员。</p><h4 id="1-2项目背景"><a href="#1-2项目背景" class="headerlink" title="1.2项目背景"></a>1.2项目背景</h4><p><strong>项目背景</strong>:这里简单介绍该项目产生的背景，可以把该项目的《需求说明书》中的“项目背景”部分摘抄到这里。<br><strong>系统简介</strong>:这里简单介绍该系统的实际使用场景，需要提供的功能等信息，可以把该项目的《需求说明书》中的“系统简介”部分摘抄到这里。<br><strong>测试目标</strong>:配合开发部，使该项目最终产品达到商用标准。</p><h4 id="1-3参考文档"><a href="#1-3参考文档" class="headerlink" title="1.3参考文档"></a>1.3参考文档</h4><p><img src="/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.assets/image-20240424201439051.png" alt="image-20240424201439051" style="zoom:67%;"></p><h3 id="2、测试设计简介"><a href="#2、测试设计简介" class="headerlink" title="2、测试设计简介"></a>2、测试设计简介</h3><h4 id="2-1-测试用例设计"><a href="#2-1-测试用例设计" class="headerlink" title="2.1 测试用例设计"></a>2.1 测试用例设计</h4><p>设计测试用例点xx个</p><p>把每个模块设计的用例记录下来</p><p><img src="/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.assets/image-20240424201427523.png" alt="image-20240424201427523" style="zoom:67%;"></p><h4 id="2-2-测试环境与配置"><a href="#2-2-测试环境与配置" class="headerlink" title="2.2 测试环境与配置"></a>2.2 测试环境与配置</h4><p><img src="/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.assets/image-20240424201416838.png" alt="image-20240424201416838"></p><h4 id="2-3-测试方法与工具"><a href="#2-3-测试方法与工具" class="headerlink" title="2.3 测试方法与工具"></a>2.3 测试方法与工具</h4><ul><li><p>测试方法：手工测试</p></li><li><p>测试工具：</p><p>xmind：设计测试用例；</p><p>word：编写测试计划、测试报告；</p><p>excel：编写测试用例；</p><p>禅道：管理测试用例与缺陷；</p><p>自动化测试: Selenium、requests；</p><p>接口测试：JMeter、Postman；</p><p>性能测试：JMeter；</p><p>APP专项测试:Monkey、PerfDog、QNET、Fiddlerk、Wetest、手机助手；</p></li></ul><h3 id="3、测试结果及分析"><a href="#3、测试结果及分析" class="headerlink" title="3、测试结果及分析"></a>3、测试结果及分析</h3><h4 id="3-1-测试执行情况与记录"><a href="#3-1-测试执行情况与记录" class="headerlink" title="3.1 测试执行情况与记录"></a>3.1 测试执行情况与记录</h4><p><img src="/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.assets/image-20240424201416838.png" alt="image-20240424201416838" style="zoom:80%;"></p><h4 id="3-2-缺陷汇总"><a href="#3-2-缺陷汇总" class="headerlink" title="3.2 缺陷汇总"></a>3.2 缺陷汇总</h4><p><img src="/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.assets/image-20240424201346968.png" alt="image-20240424201346968" style="zoom:67%;"></p><p>测试中发现致命问题：XX ;严重问题:XX众;一般问:XX众;提示问题:XX个。</p><p>Postponed:因为不是很重要或技术难度过大或需求不明确，可推迟到下一个版本再解决。</p><p>Fixed:已被开发人员找到原因并修复的缺陷。</p><p>Closed:测试人员在修复的版本中验证该问题确实已修复。</p><p>Open:测试人员发现并提交的 bug。</p><p>New:测试人员发现并新建了bug 单。</p><p>这里说明在测试过程中总共提交了多少bug，其中有效bug数为多分，无效 bug数为多少，已修改bug数为多少，遗留bug数为多少。</p><p>==管理可以通过缺陷汇总来判断：==</p><ul><li><strong>缺陷密度</strong>是否正常：</li><li><strong>缺陷的遗留率</strong>是否正常：一般和提示问题数量/缺陷总数</li><li><strong>缺陷修复率</strong>是否达标：已经修复并关闭的缺陷数量/缺陷总数</li></ul><h4 id="3-3-测试覆盖率"><a href="#3-3-测试覆盖率" class="headerlink" title="3.3 测试覆盖率"></a>3.3 测试覆盖率</h4><p>覆盖率=（pass+fail）/总用例数</p><h4 id="3-4-结论"><a href="#3-4-结论" class="headerlink" title="3.4 结论"></a>3.4 结论</h4><p>用一段简洁明了的文字，总结测试的质量。<br>例如：所有的功能已经实现，基本稳定，性能已经达标；</p><ul><li>以科睿项目为例：用户管理模块，导出用户功能不可用，同时添加和修改用户时对账号、密码等输入没有进行校验，不合理的输入也能添加或修改，其他功能已经实现且比较稳定。</li></ul><p>如果不稳定，存在XXX问题。<br>但还存在以下问题（在表格中把遗留问题逐一列举，并对问题根因进行说明)</p><p><img src="/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.assets/image-20240424201052974.png" alt="image-20240424201052974" style="zoom:50%;"></p><h4 id="3-5-建议"><a href="#3-5-建议" class="headerlink" title="3.5 建议"></a>3.5 建议</h4><p>对遗留问题对系统商用进行简单评估，给出是否可以商用的建议。<br>缺陷遗留比较多，还有XXX严重问题没解决，建议修改后回归测试再评估。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是测试报告？&lt;/p&gt;
&lt;p&gt;测试报告是测试人员在&lt;strong&gt;完成整个系统的测试工作之后&lt;/strong&gt;所撰写的文档，该文档可以反映测试&lt;strong&gt;过程&lt;/strong&gt;与测试&lt;strong&gt;结果&lt;/strong&gt;，是对阶段性测试任务的&lt;u&gt;总结&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试报告作用？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以评估项目当前状态和产品质量&lt;/li&gt;
&lt;li&gt;确定产品是否准备好发布的最终文档&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一、测试报告的几大要素&quot;&gt;&lt;a href=&quot;#一、测试报告的几大要素&quot; class=&quot;headerlink&quot; title=&quot;一、测试报告的几大要素&quot;&gt;&lt;/a&gt;一、测试报告的几大要素&lt;/h2&gt;&lt;h3 id=&quot;1、人力投入&quot;&gt;&lt;a href=&quot;#1、人力投入&quot; class=&quot;headerlink&quot; title=&quot;1、人力投入&quot;&gt;&lt;/a&gt;1、人力投入&lt;/h3&gt;&lt;p&gt;对不同测试阶段所花的时间有清晰记录&lt;/p&gt;
&lt;p&gt;eg. 测试用例编写：人员、工作量&lt;/p&gt;
&lt;p&gt;测试执行：人员、工作量&lt;/p&gt;
&lt;h3 id=&quot;2、用例覆盖度&quot;&gt;&lt;a href=&quot;#2、用例覆盖度&quot; class=&quot;headerlink&quot; title=&quot;2、用例覆盖度&quot;&gt;&lt;/a&gt;2、用例覆盖度&lt;/h3&gt;&lt;p&gt;==用例覆盖率=（pass+fail）/总用例数==&lt;/p&gt;
&lt;p&gt;用例状态：pass（通过）、fail（未通过）、NT（not test尚未测试）、block（阻塞，暂时没有条件执行）、investigate（观察中，正在测试）&lt;/p&gt;
&lt;p&gt;eg.pass和fail一共251，总用例263个&lt;/p&gt;
&lt;p&gt;用例覆盖率=251/263=95%&lt;/p&gt;
&lt;h3 id=&quot;3、缺陷统计&quot;&gt;&lt;a href=&quot;#3、缺陷统计&quot; class=&quot;headerlink&quot; title=&quot;3、缺陷统计&quot;&gt;&lt;/a&gt;3、缺陷统计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;bug严重等级：其中致命bug少的原因——开发自测和冒烟测试已经筛掉了大部分致命bug&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;功能型bug最多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bug状态：激活、已解决、已关闭&lt;/p&gt;
&lt;p&gt;==缺陷遗留率=（激活+已解决）/总bug数==&lt;/p&gt;
&lt;p&gt;只认准已关闭的bug为已解决&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bug来源：一般是需求、编码类bug较多&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4、缺陷遗留问题&quot;&gt;&lt;a href=&quot;#4、缺陷遗留问题&quot; class=&quot;headerlink&quot; title=&quot;4、缺陷遗留问题&quot;&gt;&lt;/a&gt;4、缺陷遗留问题&lt;/h3&gt;&lt;p&gt;缺陷遗留率：是否达标? 3%、一般、提示没有关闭的缺陷数/缺陷总数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于影响大的问题，不能遗留，需要在当前版本立马解决&lt;/li&gt;
&lt;li&gt;对于某些兼容性问题且只有ie6浏览器会出现问题时，可以忽略，因为有规避措施，换浏览器就可以解决&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试基础" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>测试用例设计</title>
    <link href="https://laylaycjl.github.io/2024/03/27/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
    <id>https://laylaycjl.github.io/2024/03/27/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-03-27T07:33:18.000Z</published>
    <updated>2024-03-27T07:35:56.750Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;</summary>
      
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试基础" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>测试需求</title>
    <link href="https://laylaycjl.github.io/2024/03/27/%E6%B5%8B%E8%AF%95%E9%9C%80%E6%B1%82/"/>
    <id>https://laylaycjl.github.io/2024/03/27/%E6%B5%8B%E8%AF%95%E9%9C%80%E6%B1%82/</id>
    <published>2024-03-27T07:32:39.000Z</published>
    <updated>2024-03-30T01:52:58.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、测什么？"><a href="#一、测什么？" class="headerlink" title="一、测什么？"></a>一、测什么？</h1><p>测试点思路步骤如下：正常+异常</p><p>1、正常功能：单个功能冒烟、看正常功能是否可以使用。</p><p>2、单个功能项验证是否异常（从上到下对每一个输入项进行验证，避免遗漏）</p><p>从三个方面考虑：</p><ul><li><strong>数据长度、数据类型、是否为必填、是否可重复</strong></li><li><strong>限制约束验证（看需求规格说明书中是否对该输入项有相关规则和约束）</strong></li><li><strong>隐性需求（根据个人经验或对比同类产品，发掘隐性需求）</strong></li></ul><p>3、功能交互验证<br>模块之间传递的信息和数据，对存在功能交互的功能项</p><p>4、非功能性测试:<br>界面、易用性、兼容性、安全性、性能压力</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、测什么？&quot;&gt;&lt;a href=&quot;#一、测什么？&quot; class=&quot;headerlink&quot; title=&quot;一、测什么？&quot;&gt;&lt;/a&gt;一、测什么？&lt;/h1&gt;&lt;p&gt;测试点思路步骤如下：正常+异常&lt;/p&gt;
&lt;p&gt;1、正常功能：单个功能冒烟、看正常功能是否可以使用。&lt;/p&gt;
&lt;p&gt;2、单个功能项验证是否异常（从上到下对每一个输入项进行验证，避免遗漏）&lt;/p&gt;
&lt;p&gt;从三个方面考虑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据长度、数据类型、是否为必填、是否可重复&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;限制约束验证（看需求规格说明书中是否对该输入项有相关规则和约束）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐性需求（根据个人经验或对比同类产品，发掘隐性需求）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、功能交互验证&lt;br&gt;模块之间传递的信息和数据，对存在功能交互的功能项&lt;/p&gt;
&lt;p&gt;4、非功能性测试:&lt;br&gt;界面、易用性、兼容性、安全性、性能压力&lt;/p&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试基础" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>互斥访问临界区的软/硬件实现方法</title>
    <link href="https://laylaycjl.github.io/2022/07/01/%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E8%BD%AF-%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>https://laylaycjl.github.io/2022/07/01/%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E8%BD%AF-%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</id>
    <published>2022-07-01T10:35:54.000Z</published>
    <updated>2024-03-06T04:36:50.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、软件实现"><a href="#一、软件实现" class="headerlink" title="一、软件实现"></a>一、软件实现</h1><h2 id="1、单标志法"><a href="#1、单标志法" class="headerlink" title="1、单标志法"></a>1、单标志法</h2><p>​        <strong>直接上锁</strong><br>​        （1）理解：A，B共用一个标志flag，比如为0就是A用，为1就是B用，用完之后主动把flag设置为对方使用的状态。<br>​        （2）违反 “空闲让进” 原则：限制了只能轮流使用临界资源，只能A用完B用，而不能A用完之后（B不用的情况下）A再用一次。主要原因是只有一个标志，且每次使用后都要把标志换成对方用，这就导致标志不可能连续是1，或者连续是0。</p><h2 id="2、双标志法先检查"><a href="#2、双标志法先检查" class="headerlink" title="2、双标志法先检查"></a>2、双标志法先检查</h2><p>​        <strong>先检查再上锁</strong><br>​        （1）理解：A，B两个进程各一个标志，表示是否上锁（这里上锁指的是有访问临界资源的意愿），A先检查B有没有上锁，B没有的话，A就上锁，然后访问。B先检查A有没有上锁，A没有的话，B就上锁，然后访问。<br>​        （2）违反 “忙则等待” 原则：在A检查完之后，发生中断还没来得及上锁，B此时就可以检查然后上锁，再返回A，虽然B此时已经上锁，但A已经检查完了，不知道B后来又上锁了，A也上个锁，就导致AB同时访问了。主要原因就是检查和上锁不是原子操作，不能一气呵成，很容易卡bug同时访问临界资源</p><span id="more"></span><h2 id="3、双标志法后检查"><a href="#3、双标志法后检查" class="headerlink" title="3、双标志法后检查"></a>3、双标志法后检查</h2><p>​        <strong>先上锁再检查</strong><br>​        （1）理解：A，B两个进程各一个标志，表示是否上锁（这里上锁指的是有访问临界资源的意愿）A先上锁表明自己想访问，再检查B有没有上锁，B没有的话，A就访问。B先上锁表明自己想访问，再检查A有没有上锁，A没有的话，B就访问。<br>​        （2）违反 “有限等待” 和 “空闲让进” 原则：A如果先上了锁，然后发生中断，B也上锁，然后B检查A的情况就会发现A已经上锁了，就等待A进程使用结束再使用，此时回到A进程，A发现B也上锁，就等待B解锁，此时就形成了A、B相互等待对方释放资源。</p><h2 id="4、Peterson’s-Alogorithm"><a href="#4、Peterson’s-Alogorithm" class="headerlink" title="4、Peterson’s Alogorithm"></a>4、Peterson’s Alogorithm</h2><p>​        <strong>单标志和双标志法后检查的结合</strong><br>​        （1）理解：A，B两个进程各一个标志，外加一个turn标志指示谁更优先，只有上锁且turn为自己优先时才能使用临界资源。A先上锁，然后将对方（B）设置为更优先，只有当B没有上锁或者A自身优先级更高时才会使用临界资源。B先上锁，然后将对方（A）设置为更优先，只有当A没有上锁或者B自身优先级更高时才会使用临界资源。<br>​        （2）违反 “让权等待” 原则：因为算法里等待是执行while空循环直到对方让出资源，也就是一直霸占着CPU执行while循环，而不是交出处理机资源，让权等待。</p><h1 id="二、硬件实现（低级方法）（元方法）"><a href="#二、硬件实现（低级方法）（元方法）" class="headerlink" title="二、硬件实现（低级方法）（元方法）"></a>二、硬件实现（低级方法）（元方法）</h1><h2 id="1、中断屏蔽法"><a href="#1、中断屏蔽法" class="headerlink" title="1、中断屏蔽法"></a>1、中断屏蔽法</h2><p>用开关中断来实现临界区访问的排他性与原子性</p><p>违反 “让权等待” 原则</p><p>缺点是：<br>①限制了处理机交替执行程序的能力<br>②且开关中断属于特权指令，要在内核态才能运行，所以这个方法只适合内核进程，用户进程如果能随意开关中断会让系统很危险<br>③对多处理机系统无效，开关中断只限制了一个处理机只能有一个进程访问临界资源，当有多个处理机的时候很有可能导致不同处理机的多个进程同时访问临界资源        </p><h2 id="2、硬件指令法"><a href="#2、硬件指令法" class="headerlink" title="2、硬件指令法"></a>2、硬件指令法</h2><h3 id="（1）TestAndSet指令（TS指令）（TSL指令）"><a href="#（1）TestAndSet指令（TS指令）（TSL指令）" class="headerlink" title="（1）TestAndSet指令（TS指令）（TSL指令）"></a>（1）TestAndSet指令（TS指令）（TSL指令）</h3><p>TSL = TestSetLock<br>实质上和软件实现的 “双标志先检查” 一样，只不过这个是用硬件实现，保证了过程的原子性，不会被中断</p><h3 id="（2）Swap指令（Exchange指令）（XCHG指令）"><a href="#（2）Swap指令（Exchange指令）（XCHG指令）" class="headerlink" title="（2）Swap指令（Exchange指令）（XCHG指令）"></a>（2）Swap指令（Exchange指令）（XCHG指令）</h3><p>违反 “让权等待” 原则</p><p>和TestAndSet指令逻辑一样，只是具体实现方法上有差别<br>适合多处理机，实现简单</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、软件实现&quot;&gt;&lt;a href=&quot;#一、软件实现&quot; class=&quot;headerlink&quot; title=&quot;一、软件实现&quot;&gt;&lt;/a&gt;一、软件实现&lt;/h1&gt;&lt;h2 id=&quot;1、单标志法&quot;&gt;&lt;a href=&quot;#1、单标志法&quot; class=&quot;headerlink&quot; title=&quot;1、单标志法&quot;&gt;&lt;/a&gt;1、单标志法&lt;/h2&gt;&lt;p&gt;​        &lt;strong&gt;直接上锁&lt;/strong&gt;&lt;br&gt;​        （1）理解：A，B共用一个标志flag，比如为0就是A用，为1就是B用，用完之后主动把flag设置为对方使用的状态。&lt;br&gt;​        （2）违反 “空闲让进” 原则：限制了只能轮流使用临界资源，只能A用完B用，而不能A用完之后（B不用的情况下）A再用一次。主要原因是只有一个标志，且每次使用后都要把标志换成对方用，这就导致标志不可能连续是1，或者连续是0。&lt;/p&gt;
&lt;h2 id=&quot;2、双标志法先检查&quot;&gt;&lt;a href=&quot;#2、双标志法先检查&quot; class=&quot;headerlink&quot; title=&quot;2、双标志法先检查&quot;&gt;&lt;/a&gt;2、双标志法先检查&lt;/h2&gt;&lt;p&gt;​        &lt;strong&gt;先检查再上锁&lt;/strong&gt;&lt;br&gt;​        （1）理解：A，B两个进程各一个标志，表示是否上锁（这里上锁指的是有访问临界资源的意愿），A先检查B有没有上锁，B没有的话，A就上锁，然后访问。B先检查A有没有上锁，A没有的话，B就上锁，然后访问。&lt;br&gt;​        （2）违反 “忙则等待” 原则：在A检查完之后，发生中断还没来得及上锁，B此时就可以检查然后上锁，再返回A，虽然B此时已经上锁，但A已经检查完了，不知道B后来又上锁了，A也上个锁，就导致AB同时访问了。主要原因就是检查和上锁不是原子操作，不能一气呵成，很容易卡bug同时访问临界资源&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://laylaycjl.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="互斥访问临界区" scheme="https://laylaycjl.github.io/tags/%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>经典同步问题</title>
    <link href="https://laylaycjl.github.io/2022/06/25/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://laylaycjl.github.io/2022/06/25/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</id>
    <published>2022-06-25T12:23:39.000Z</published>
    <updated>2022-06-25T12:52:03.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h1><h2 id="一、生产者消费者问题（最常见的同步互斥问题）"><a href="#一、生产者消费者问题（最常见的同步互斥问题）" class="headerlink" title="一、生产者消费者问题（最常见的同步互斥问题）"></a>一、生产者消费者问题（最常见的同步互斥问题）</h2><h3 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h3><p>主要难点是：互斥和同步关系同时存在的问题，主要是分析同步问题<br>（1）同步操作<br>    生产者要生产数据，也就是把数据写入缓冲区，需要使用的是空缓冲区资源，用empty这个信号量来记录空缓冲区资源。（生产者写的前提是有空缓冲区资源）</p><ul><li>初始时，缓冲区全部为空，也就是空缓冲区的数目为n个</li><li>生产者在写入缓冲区之前，要申请空缓冲区资源，即P（empty）</li><li>生产者在写完之后，要让满缓冲区资源加1，因为写完了一个，满缓冲区资源多了一个</li></ul><span id="more"></span><p>消费者要消费数据，也就是将生产者写入缓冲区的资源读出，用full这个信号量来记录已写满的满缓冲区资源。<br>（消费者读的前提是有满缓冲区资源）</p><ul><li>初始时，缓冲区全部为空，也就是满缓冲区的数目为0个</li><li>消费者在读出缓冲区内容之前，要申请满缓冲区资源，即P（full）</li><li>消费者在读完之后，要让空缓冲区资源加1，因为读完了一个，空缓冲区资源多了一个</li></ul><p>（2）互斥操作<br>      由于缓冲区是临界资源，所以缓冲区的访问也是需要申请的，申请访问缓冲区的操作是互斥访问，所以直接先P（mutex）然后访问完释放P（mutex）即可</p><h3 id="2、伪代码"><a href="#2、伪代码" class="headerlink" title="2、伪代码"></a>2、伪代码</h3><p><img src="/images/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/image-20220625203529953.png" alt="image-20220625203529953"></p><h3 id="3、要注意的关键点"><a href="#3、要注意的关键点" class="headerlink" title="3、要注意的关键点"></a>3、要注意的关键点</h3><h4 id="（1）P操作的先后顺序问题"><a href="#（1）P操作的先后顺序问题" class="headerlink" title="（1）P操作的先后顺序问题"></a>（1）P操作的先后顺序问题</h4><p>​    问题理解：因为无论是生产者还是消费者都需要申请两个资源，一个是mutex（申请使用缓冲区这个临界资源），一个是empty（生产者申请在空缓冲区内写入数据）/或者是full（消费者申请在满缓冲区内读出数据），所以有两个P操作，P（mutex）和 P（empty）/ P（full）<br>​    理由（以生产者为例）：如果把申请mutex放在前边，那么如果此时缓冲区是满的，但是消费者又没有申请使用缓冲区，也就是说此时生产者是可以申请到缓冲区的使用权的，但申请到了使用权之后，发现缓冲区为满，需要等待消费者取出数据之后再访问，也就是会出现霸占缓冲区等待。此时，消费者无法访问缓冲区，生产者又在等待消费者取出缓冲区内的数据，时进程陷入死锁</p><h4 id="（2）V操作的先后问题"><a href="#（2）V操作的先后问题" class="headerlink" title="（2）V操作的先后问题"></a>（2）V操作的先后问题</h4><p>结论：V操作是释放资源，无论什么时候释放都一样，所以V操作顺序无所谓</p><h4 id="（3）消费者使用数据是否能放在访问缓冲区中间？"><a href="#（3）消费者使用数据是否能放在访问缓冲区中间？" class="headerlink" title="（3）消费者使用数据是否能放在访问缓冲区中间？"></a>（3）消费者使用数据是否能放在访问缓冲区中间？</h4><p>​        可以，但是不建议，因为如果只是在缓冲区内取数据，取完就释放缓冲区的话，进程霸占缓冲区内时间就会减少，如果取完还要在缓冲区里处理数据，进程就会长时间霸占缓冲区，这样会使计算机效率变低        </p><h2 id="二、读者写者问题（复杂的互斥问题）"><a href="#二、读者写者问题（复杂的互斥问题）" class="headerlink" title="二、读者写者问题（复杂的互斥问题）"></a>二、读者写者问题（复杂的互斥问题）</h2><h3 id="1、思路-1"><a href="#1、思路-1" class="headerlink" title="1、思路"></a>1、思路</h3><p>​    主要难点是：如何实现多个读者可以同时读，但写者和读者又必须互斥访问<br>​    关键就在于实现多个读者可以同时读，思路就是借用一个变量count记录有多少个读者正在读，只用在第一个读者读的时候用P原语加锁申请读，只要第一个读者还在读，后续进来的读者就不用申请加锁，直接就可以读取。当所有读者都读完才用V原语解锁，这就限制了写者和读者互斥访问，同时使读者可以同时读</p><h3 id="2、伪代码-1"><a href="#2、伪代码-1" class="headerlink" title="2、伪代码"></a>2、伪代码</h3><p><img src="/images/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/image-20220625204228499.png" alt="image-20220625204228499">        </p><h3 id="3、要注意的关键点-1"><a href="#3、要注意的关键点-1" class="headerlink" title="3、要注意的关键点"></a>3、要注意的关键点</h3><h4 id="（1）理解count是如何实现读者可同时访问的"><a href="#（1）理解count是如何实现读者可同时访问的" class="headerlink" title="（1）理解count是如何实现读者可同时访问的"></a>（1）理解count是如何实现读者可同时访问的</h4><p>①count判断与count++在对读取临界资源进行P操作加锁之前，需要判断这个读进程是不是第一个进行读操作的进程，如果是（也就是count == 0）那么可以直接P操作加锁，然后count++，此时count=1，后序如果再来一个读进程，count=1，说明不是第一个读进程，此时再判断，不符合if（count == 0）的条件，就跳过了加锁这个过程，可以直接读，也就是实现了读者可以不互斥的访问临界资源<br>②count—与count判断<br>在读完之后，读进程退出临界资源，此时count—，如果这已经是最后一个读进程，那么它退出之后，此时count == 0，说明所有读进程都读完了，此时符合if（count==0）的条件，进行V操作释放资源进行解锁</p><h4 id="（2）为什么要在判断count与count-操作前后使用P-mutex-和V-mutex-加以限制"><a href="#（2）为什么要在判断count与count-操作前后使用P-mutex-和V-mutex-加以限制" class="headerlink" title="（2）为什么要在判断count与count++操作前后使用P(mutex)和V(mutex)加以限制"></a>（2）为什么要在判断count与count++操作前后使用P(mutex)和V(mutex)加以限制</h4><p>新增一个mutex信号量来控制原子执行 “count判断与count++” 与 “count—与count判断” 的原因：<br>（以   count判断与count++  为例进行说明，另一个同理）<br>①首先明确count的作用，count是为了判断是不是第一个读的进程，是就加锁，不是就不用加锁，因为第一个进程已经加过锁了<br>②假设一种情况：<br>第一个读进程刚判断完if（count==0），显然它是第一个进程，符合if判断条件，进行了P操作加锁，此时还没来得及count++，第二个读进程以中断方式打断第一个读进程，并开始执行，此时count因为没来得及加 1 ，所以它的值依旧是0，即使这是第二个读进程，系统也把它当成了第一个读进程，判断它符合if判断条件，进行P操作加锁，但刚刚第一个读进程已经加锁了，第二个读进程需要等待第一个读进程V操作释放，但第一个读进程却在中断等待第二个读进程结束，系统陷入死锁<br>③所以，需要将count的判断和count++设置为原子操作，中间不能中断，引入mutex信号量来控制操作的原子性</p><h4 id="（3）如何解决读进程优先，写进程面临饿死的局面"><a href="#（3）如何解决读进程优先，写进程面临饿死的局面" class="headerlink" title="（3）如何解决读进程优先，写进程面临饿死的局面"></a>（3）如何解决读进程优先，写进程面临饿死的局面</h4><p>​    思路：再加入一个w信号量控制写进程优先，在进行读操作，或者是写操作之前必须进行P(w)进行申请，w初始为1，关键在于这个V(w)放在什么位置，既要限制写进程优先，又不能阻塞多个读进程进行读操作：</p><ul><li>①写进程就正常放在末尾</li><li>②读进程放在读取操作之前， count判断与count++之后，这样就会在每个读进程读之前就解锁，以免将下一个读进程阻塞。这样如果有写进程到来的话，下一个读进程就必须等待写进程 V(w) 解锁释放w才能接着读</li></ul><p>​    但是这个方法不是真正意义上的“写进程优先”，更贴切的讲是“读写公平算法”，只是不让写进程陷入无线等待而饿死，但并没有实现写进程绝对优先于读进程</p><h2 id="三、哲学家就餐问题"><a href="#三、哲学家就餐问题" class="headerlink" title="三、哲学家就餐问题"></a>三、哲学家就餐问题</h2><h3 id="1、思路-2"><a href="#1、思路-2" class="headerlink" title="1、思路"></a>1、思路</h3><p>​        主要难点是：每个哲学家都需要两个临界资源才能正常执行，避免死锁成了主要问题</p><h3 id="2、伪代码（哲学家和筷子的编号都从0开始）"><a href="#2、伪代码（哲学家和筷子的编号都从0开始）" class="headerlink" title="2、伪代码（哲学家和筷子的编号都从0开始）"></a>2、伪代码（哲学家和筷子的编号都从0开始）</h3><p>（3种实现方式）<br>策略1：只能同时拿左筷子和右筷子</p><p><img src="/images/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/image-20220625204611824.png" alt="image-20220625204611824" style="zoom:50%;"><img src="/images/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/image-20220625204623135.png" alt="image-20220625204623135"></p><p>策略2：最多四个哲学家拿筷子</p><p><img src="/images/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/image-20220625204623135.png" alt="image-20220625204623135"></p><p>策略3        限定奇哲学家拿左边筷子，偶哲学家拿右边的筷子</p><p><img src="/images/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/image-20220625204639470.png" alt="image-20220625204639470" style="zoom:50%;"></p><h3 id="3、要注意的关键点-2"><a href="#3、要注意的关键点-2" class="headerlink" title="3、要注意的关键点"></a>3、要注意的关键点</h3><h4 id="策略1：只有当两个筷子可以同时拿到时才给他分配筷子"><a href="#策略1：只有当两个筷子可以同时拿到时才给他分配筷子" class="headerlink" title="策略1：只有当两个筷子可以同时拿到时才给他分配筷子"></a>策略1：只有当两个筷子可以同时拿到时才给他分配筷子</h4><p>设置mutex信号量，利用P（mutex）和V（mutex）将取左边筷子和右边筷子设为原子操作，要么都做要么都不做，这样也能避免死锁</p><h4 id="策略2：每次最多只有四个哲学家能拿起筷子"><a href="#策略2：每次最多只有四个哲学家能拿起筷子" class="headerlink" title="策略2：每次最多只有四个哲学家能拿起筷子"></a>策略2：每次最多只有四个哲学家能拿起筷子</h4><p><img src="/images/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/image-20220625204707467.png" alt="image-20220625204707467" style="zoom:40%;"></p><p>避免了死锁，一定会有一个哲学家可以拿起两只筷子，例如，当每个哲学家都想拿起自己右手边的筷子时，到如果E拿起了4号筷子，就陷入了死锁，此时，限制了只有4个哲学家能拿筷子，E就没有资格拿起筷子，所以会让A拿起左边的筷子，而不是E，这样就避免了死锁</p><h4 id="策略3：让奇数哲学家只能拿左边的筷子，偶数哲学界只能先拿右边的筷子"><a href="#策略3：让奇数哲学家只能拿左边的筷子，偶数哲学界只能先拿右边的筷子" class="headerlink" title="策略3：让奇数哲学家只能拿左边的筷子，偶数哲学界只能先拿右边的筷子"></a>策略3：让奇数哲学家只能拿左边的筷子，偶数哲学界只能先拿右边的筷子</h4><p><img src="/images/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/image-20220625204722458.png" alt="image-20220625204722458" style="zoom:50%;"></p><p>以A、B为例，当A想要吃饭，A是0号为偶哲学家，先拿起右边的筷子，再拿起左边的筷子，此时如果B想要吃饭，他就只能先拿他左手边的筷子，但此时他左手边的筷子已经被A拿走了，所以B只能阻塞等待A，而不能拿他右手边空闲的筷子，这样就打破了死锁</p><h2 id="四、吸烟者问题（复杂的同步互斥问题）"><a href="#四、吸烟者问题（复杂的同步互斥问题）" class="headerlink" title="四、吸烟者问题（复杂的同步互斥问题）"></a>四、吸烟者问题（复杂的同步互斥问题）</h2><h3 id="1、思路-3"><a href="#1、思路-3" class="headerlink" title="1、思路"></a>1、思路</h3><p>多个消费者对应一个生产者的问题（if - else if - else），主要难点是如何控制轮流访问 ———— 用取余操作（比较难想）</p><h3 id="2、伪代码-2"><a href="#2、伪代码-2" class="headerlink" title="2、伪代码"></a>2、伪代码</h3><p>​        <img src="/images/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/image-20220625205024421.png" alt="image-20220625205024421" style="zoom:80%;"></p><h3 id="3、要注意的关键点-3"><a href="#3、要注意的关键点-3" class="headerlink" title="3、要注意的关键点"></a>3、要注意的关键点</h3><p>（1）如何控制轮流消费<br>        1）如何控制轮流给材料<br>            先用num++与num=num%3控制num在0,1,2这三个数里循环 ，再用if（num == 0） 访问一号消费者，else if（num == 1） 访问二号消费者，else 访问三号消费者<br>        2）如何控制没有材料就不准消费<br>            ①三个消费者所需的材料各不相同，有三种组合，设置三个信号量offer1、offer2、offer3<br>            ②在消费之前必须申请offer信号量，否则阻塞等待。而offer是用前面的num和if else语句控制，一个个按                  顺序释放，只有轮到自己了才有V操作释放所需材料，此时才能消费<br>（2）如何控制只有前一个消费者消费之后，下一个才能消费（互斥问题）<br>    设置finish信号量，在生产者提供完一次材料之后，会申请finish，如果申请不到finish就阻塞等待finish的释放。finish只有在消费者消费完之后才会进行V操作进行释放</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;经典同步问题&quot;&gt;&lt;a href=&quot;#经典同步问题&quot; class=&quot;headerlink&quot; title=&quot;经典同步问题&quot;&gt;&lt;/a&gt;经典同步问题&lt;/h1&gt;&lt;h2 id=&quot;一、生产者消费者问题（最常见的同步互斥问题）&quot;&gt;&lt;a href=&quot;#一、生产者消费者问题（最常见的同步互斥问题）&quot; class=&quot;headerlink&quot; title=&quot;一、生产者消费者问题（最常见的同步互斥问题）&quot;&gt;&lt;/a&gt;一、生产者消费者问题（最常见的同步互斥问题）&lt;/h2&gt;&lt;h3 id=&quot;1、思路&quot;&gt;&lt;a href=&quot;#1、思路&quot; class=&quot;headerlink&quot; title=&quot;1、思路&quot;&gt;&lt;/a&gt;1、思路&lt;/h3&gt;&lt;p&gt;主要难点是：互斥和同步关系同时存在的问题，主要是分析同步问题&lt;br&gt;（1）同步操作&lt;br&gt;    生产者要生产数据，也就是把数据写入缓冲区，需要使用的是空缓冲区资源，用empty这个信号量来记录空缓冲区资源。（生产者写的前提是有空缓冲区资源）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始时，缓冲区全部为空，也就是空缓冲区的数目为n个&lt;/li&gt;
&lt;li&gt;生产者在写入缓冲区之前，要申请空缓冲区资源，即P（empty）&lt;/li&gt;
&lt;li&gt;生产者在写完之后，要让满缓冲区资源加1，因为写完了一个，满缓冲区资源多了一个&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://laylaycjl.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="进程与线程" scheme="https://laylaycjl.github.io/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>有关全排列问题</title>
    <link href="https://laylaycjl.github.io/2022/03/14/%E6%9C%89%E5%85%B3%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>https://laylaycjl.github.io/2022/03/14/%E6%9C%89%E5%85%B3%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-14T00:20:59.000Z</published>
    <updated>2022-03-14T03:16:05.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、递归分治法"><a href="#1、递归分治法" class="headerlink" title="1、递归分治法"></a>1、递归分治法</h1><span id="more"></span><p>代码实现（C语言）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ARRAY_LEN(array,len) {len = (sizeof(array) / sizeof(array[0]));}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> k)</span> </span>{</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">4</span>) {</span><br><span class="line">GET_ARRAY_LEN(arr,len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=len+<span class="number">1</span>;j++)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,arr[j]); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;<span class="number">4</span>;i++) {</span><br><span class="line"><span class="keyword">int</span> t = arr[i];</span><br><span class="line">arr[i] = arr[k];</span><br><span class="line">arr[k] = t;</span><br><span class="line"></span><br><span class="line">f(arr, k+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">t = arr[i];</span><br><span class="line">arr[i] = arr[k];</span><br><span class="line">arr[k] = t;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> arr[] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">f(arr,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、递归分治法&quot;&gt;&lt;a href=&quot;#1、递归分治法&quot; class=&quot;headerlink&quot; title=&quot;1、递归分治法&quot;&gt;&lt;/a&gt;1、递归分治法&lt;/h1&gt;</summary>
    
    
    
    <category term="JavaA组" scheme="https://laylaycjl.github.io/categories/JavaA%E7%BB%84/"/>
    
    
    <category term="算法" scheme="https://laylaycjl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯2013</title>
    <link href="https://laylaycjl.github.io/2022/02/26/%E8%93%9D%E6%A1%A5%E6%9D%AF2013A/"/>
    <id>https://laylaycjl.github.io/2022/02/26/%E8%93%9D%E6%A1%A5%E6%9D%AF2013A/</id>
    <published>2022-02-26T08:28:48.000Z</published>
    <updated>2022-03-13T14:28:01.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、世纪末问题（calendar-API）"><a href="#1、世纪末问题（calendar-API）" class="headerlink" title="1、世纪末问题（calendar API）"></a>1、世纪末问题（calendar API）</h2><blockquote><p>1999年的12月31日是星期五，请问:未来哪一个离我们最近的一个世纪末年〈即xx99年）的12月31日正好是星期天（即星期日)?<br>请回答该年份(只写这个4位整数，不要写12月31等多余信息)</p></blockquote><p>思路：</p><p>关键在于是否知道calendar类的存在，直接调用这个类，设定好年份月份日期再获取这一天是星期几就可以了</p><span id="more"></span><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">声明calendar类：</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">设置好年月日：</span><br><span class="line">    c.set(Calendar.YEAR,year);</span><br><span class="line">    c.set(Calendar.MONTH,<span class="number">11</span>);</span><br><span class="line">    c.set(Calendar.DAY_OF_MONTH,<span class="number">31</span>);</span><br><span class="line">获取当前年月日所在的星期：</span><br><span class="line">    <span class="keyword">int</span> dd = c.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">是星期天就输出：</span><br><span class="line">    <span class="keyword">if</span>(dayOfWeek==<span class="number">1</span>) {</span><br><span class="line">    System.out.println(year);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">完整代码：</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheEndDay01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="comment">//定义年份</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="comment">//声明类</span></span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    <span class="keyword">for</span>(year=<span class="number">2099</span>;year&lt;=<span class="number">10000</span>;year+=<span class="number">100</span>) {</span><br><span class="line">        <span class="comment">//给calendar赋值年月日</span></span><br><span class="line">    <span class="comment">//calendar.set(year,11,31);</span></span><br><span class="line">    calendar.set(Calendar.YEAR, year);</span><br><span class="line">    calendar.set(Calendar.MONTH, <span class="number">11</span>);</span><br><span class="line">    calendar.set(Calendar.DAY_OF_MONTH, <span class="number">31</span>);</span><br><span class="line">    <span class="comment">//获取这一天是星期几</span></span><br><span class="line">    <span class="keyword">int</span> dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">    <span class="keyword">if</span>(dayOfWeek==<span class="number">1</span>) {</span><br><span class="line">    System.out.println(year);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><p>Calendar类里边：</p><p><code>Calendar.YEAR</code> 只能在1970年以后</p><p><code>Calendar.MONTH</code> 从0开始计数，0代表1月，1代表2月</p><p><code>Calendar.DAY_OF_MONTH</code> 正常计数</p><p><code>Calendar.DAY_OF_WEEK</code>从星期天开始计数，1代表周日，2代表周一，3代表周二 </p><h2 id="2、走格子（dfs——深度优先算法）"><a href="#2、走格子（dfs——深度优先算法）" class="headerlink" title="2、走格子（dfs——深度优先算法）"></a>2、走格子（dfs——深度优先算法）</h2><blockquote><p>从我做起振</p><p>我做起振兴</p><p>做起振兴中</p><p>起振兴中华</p><p>比赛时，先站在左上角的写着”从””字的格子里，可以横向或纵向跳到相邻的格子里，但不能跳到对角的格子或其它位置一直要跳到“华”字结束。要求跳过的路线刚好构成“从我做起振兴中华”这句话。<br>请你帮助小明算一算他一共有多少种可能的跳跃路线呢?<br>答案是一个整数，请通过浏览器直接提交该数字。<br>注意:不要提交解答过程，或其它辅助说明类的内容。</p></blockquote><p><img src="/images/%E8%93%9D%E6%A1%A5%E6%9D%AF2013A/image-20220226163706673.png" alt="image-20220226163706673" style="zoom:33%;"></p><p>思路：小明无论站在哪个位置都有向下和向右两种走法，是典型的深度优先算法，用递归来解决。递归三要素就是重复、变化、边界。<strong>重复</strong>是每次不断重复的向下or向右，<strong>变化</strong>是坐标不断变化i++，j++，<strong>边界</strong>是i=3，j=4时到最右下角不能走了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">完整代码：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFS</span> </span>{</span><br><span class="line"><span class="comment">//编写递归函数f</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>{</span><br><span class="line"><span class="comment">//边界就是最右下角的位置，即i为3，j为4的位置</span></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">3</span> || j == <span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//将两种可能的情况相加，要么向右走，即j+1，要么向下走，i+1</span></span><br><span class="line"><span class="keyword">return</span> f(i+<span class="number">1</span>, j)+f(i, j+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ans = f(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3、梅森素数（BigInteger-API）"><a href="#3、梅森素数（BigInteger-API）" class="headerlink" title="3、梅森素数（BigInteger API）"></a>3、梅森素数（BigInteger API）</h2><blockquote><p>截止2013年2月，一共只找到了48个梅森素数。新近找到的梅森素数太大，以至于难于用一般的编程思路窥其全貌，所以我们把任务的难度降低一点:<br>1963年，美国伊利诺伊大学为了纪念他们找到的第23个梅森素数n=11213，在每个寄出的信封上都印上了“2^11213-1是素数””的字样。<br>2^11213- 1这个数字已经很大(有3000多位)，请你编程求出这个素数的十进制表示的最后100位。</p></blockquote><p>思路：熟悉BigInteger这个API就简单了，首先用BigInteger的自带方法表示出2^11213-1这个数字，然后把这个数转为字符串，再截取这个字符串的后100位数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">完整代码：</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">//import sun.security.util.Length;</span></span><br><span class="line"><span class="comment">//这里不注释掉会报错，具体原因应该是jdk配置问题</span></span><br><span class="line"><span class="comment">/*截止2013年2月，一共只找到了48个梅森素数。新近找到的梅森素数太大，以至于难于用一般的编程思路窥其全貌，</span></span><br><span class="line"><span class="comment"> * 所以我们把任务的难度降低一点:</span></span><br><span class="line"><span class="comment">1963年，美国伊利诺伊大学为了纪念他们找到的第23个梅森素数n=11213，在每个寄出的信封上都印上了“2^11213-1是素数""的字样。</span></span><br><span class="line"><span class="comment">2^11213- 1这个数字已经很大(有3000多位)，请你编程求出这个素数的十进制表示的最后100位。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigIntegerAPI</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"><span class="comment">//因为整个num是用BigInteger类型的，所以后边这个底数2也要调用valueOf把它变成BigInteger类型</span></span><br><span class="line"><span class="comment">//然后调用pow函数表示2^11213，再用BigInteger常量BigInteger.ONE来表示1</span></span><br><span class="line"><span class="comment">//最后调用subtract函数表示减</span></span><br><span class="line">BigInteger num = BigInteger.valueOf(<span class="number">2</span>).pow(<span class="number">11213</span>).subtract(BigInteger.ONE);</span><br><span class="line"><span class="comment">//再把num转化为字符串类型</span></span><br><span class="line">String snum =num.toString();</span><br><span class="line"><span class="keyword">int</span> Length = snum.length();</span><br><span class="line">String ans = snum.substring(Length-<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"length is"</span> + Length + <span class="string">"last 100 num is"</span>+ans);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4、颠倒的价格牌"><a href="#4、颠倒的价格牌" class="headerlink" title="4、颠倒的价格牌"></a>4、颠倒的价格牌</h2><blockquote><p>标题:颠倒的价牌<br>小李的店里专卖其它店中下架的样品电视机，可称为:样品电视专卖店。<br>其标价都是4位数字《即千元不等)。<br>小李为了标价清晰、方便，使用了预制的类似数码管的标价签，只要用颜色笔涂数字就可以了<br>这种价牌有个特点，对一些数字，倒过来看也是合理的数字。如:1256890都可以。这样一来，如果牌子挂倒了，有可能完全变成了另一个价格,比如:1958倒着挂就是:8561，差了几千元啊!!<br>当然，多数情况不能倒读，比如，1110就不能倒过来，因为0不能作为开始数字。<br>有一天，悲剧终于发生了。某个店员不小心把店里的某两个价格牌给挂倒了。并且这两个价格牌的电视机都卖出去了!庆幸的是价格出入不大，其中一个价牌赔了2百多，另一个价牌却赚了8百多，综合起来，反而多赚了558元。<br>请根据这些信息计算:赔钱的那个价牌正确的价格应该是多少?</p></blockquote><p>思路：在循环中遍历所有4位数，编写reverse函数翻转价牌，将亏200多的放在一个数组里，将赚800多的放在一个数组里，再写一个循环找出价差为558的</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceReverse</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Price</span></span>{</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"><span class="keyword">int</span> plus;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Price</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> plus)</span> </span>{</span><br><span class="line"><span class="keyword">this</span>.p = p;</span><br><span class="line"><span class="keyword">this</span>.plus = plus;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将数字旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">Reverse</span><span class="params">(String s)</span> </span>{</span><br><span class="line"><span class="keyword">char</span>[] ans = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) {</span><br><span class="line"><span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line"><span class="comment">//几个数字里只有6和9会发生改变</span></span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'6'</span>) ans[i]=<span class="string">'9'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'9'</span>) ans[i]=<span class="string">'6'</span>;</span><br><span class="line"><span class="keyword">else</span> ans[i] = c;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(ans);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">ArrayList&lt;Price&gt; a1 = <span class="keyword">new</span> ArrayList&lt;Price&gt;();</span><br><span class="line">ArrayList&lt;Price&gt; a2 = <span class="keyword">new</span> ArrayList&lt;Price&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>;i&lt;<span class="number">10000</span>;i++) {</span><br><span class="line"><span class="comment">//整型变为字符串</span></span><br><span class="line">String s = <span class="string">""</span> +i;</span><br><span class="line"><span class="keyword">if</span>(s.contains(<span class="string">"3"</span>)||s.contains(<span class="string">"4"</span>)||s.contains(<span class="string">"7"</span>)) {</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line">String re_s = Reverse(s);</span><br><span class="line"><span class="comment">//字符串变为整型</span></span><br><span class="line"><span class="keyword">int</span> i1 = Integer.parseInt(re_s);</span><br><span class="line"><span class="keyword">int</span> plus = i1-i;</span><br><span class="line"><span class="comment">//记录下颠倒后的价差和颠倒前的价格</span></span><br><span class="line"><span class="keyword">if</span>(plus&lt;-<span class="number">200</span> &amp;&amp; plus&gt;-<span class="number">300</span>) a1.add(<span class="keyword">new</span> Price(i,plus));</span><br><span class="line"><span class="keyword">if</span>(plus&lt;<span class="number">900</span> &amp;&amp; plus&gt;<span class="number">800</span>) a2.add(<span class="keyword">new</span> Price(i,plus));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Price p1:a1) {</span><br><span class="line"><span class="keyword">for</span>(Price p2:a2) {</span><br><span class="line"><span class="comment">//将两个价差相加，筛选出所有结果为558的两个价格</span></span><br><span class="line">    <span class="keyword">if</span>(p1.plus + p2.plus == <span class="number">558</span>) {</span><br><span class="line">    System.out.println(p1.p+<span class="string">""</span>+p1.plus);</span><br><span class="line">    System.out.println(p2.p+<span class="string">""</span>+p2.plus);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>wrong answer：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePrice</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> price)</span> </span>{</span><br><span class="line">String str = String.valueOf(price);}</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">str = str.replace(<span class="string">'6'</span>, <span class="string">'t'</span>);</span><br><span class="line">str = str.replace(<span class="string">'9'</span>, <span class="string">'6'</span>);</span><br><span class="line">str = str.replace(<span class="string">'t'</span>, <span class="string">'9'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">3</span>;q&gt;=<span class="number">0</span>;q--) {</span><br><span class="line">buffer.append(str.charAt(q));</span><br><span class="line">}</span><br><span class="line">String str2 = buffer.toString();</span><br><span class="line"><span class="keyword">int</span> reverse = Integer.parseInt(str2);</span><br><span class="line"><span class="keyword">return</span> reverse;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"><span class="keyword">int</span>[] arr200 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span>[] arr800 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> formerPrice;</span><br><span class="line"><span class="keyword">int</span> reversePrice;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;i&lt;=<span class="number">9999</span>;i++) {</span><br><span class="line">formerPrice = i;</span><br><span class="line">reversePrice = reverse(formerPrice);</span><br><span class="line"><span class="keyword">if</span>(reversePrice-formerPrice&lt;-<span class="number">200</span>&amp;&amp;reversePrice-formerPrice&gt;-<span class="number">300</span>) {</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">20</span>) <span class="keyword">break</span>;</span><br><span class="line">arr200[j] = formerPrice;</span><br><span class="line">j++;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(reversePrice-formerPrice&lt;<span class="number">900</span>&amp;&amp;reversePrice-formerPrice&gt;<span class="number">800</span>) {</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">20</span>) <span class="keyword">break</span>;</span><br><span class="line">arr800[k] = formerPrice;</span><br><span class="line">k++;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;=<span class="number">19</span>;m++) {</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;=<span class="number">19</span>;n++) {</span><br><span class="line"><span class="keyword">int</span> out =reverse(arr200[m]) - arr200[m];</span><br><span class="line"><span class="keyword">int</span> in = reverse(arr800[n]) - arr800[n];</span><br><span class="line"><span class="keyword">int</span> gap = in + out;</span><br><span class="line"><span class="keyword">if</span>(gap==<span class="number">558</span>) {</span><br><span class="line">System.out.println(arr200[m]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="5、三部排序"><a href="#5、三部排序" class="headerlink" title="5、三部排序"></a>5、三部排序</h2><blockquote><p>标题:三部排序<br>一般的排序有许多经典算法，如快速排序、希尔排序等。<br>但实际应用时，经常会或多或少有一些特殊的要求。我们没必要套用那些经典算法，可以根据实际情况建立更好的解法。比如，对一个整型数组中的数字进行分类排序;<br>使得负数都靠左端，正数都靠右端，0在中部。注意问题的特点是:负数区域和正数区域内并不要求有序。可以利用这个特点通过1次线性扫描就结束战斗!!<br>以下的程序实现了该目标。</p><p>如果给定数组:<br>25,18,-2,0,16,-5,33,21,0,19,-16,25,-3,0</p><p>则排序后为:<br>-3,-2,-16,-5,0,0,0,21,19,33,25,16,18,25<br>请分析代码逻辑，并推测划线处的代码，通过网页提交<br>注意︰仅把缺少的代码作为答案，千万不要填写多余的代码、符号或说明文字!</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = x.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&lt;=right){</span><br><span class="line">        <span class="keyword">if</span>(x[p]&lt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> t = x[left];</span><br><span class="line">            x[left] = x[p];</span><br><span class="line">            x[p] = t;</span><br><span class="line">            left++;</span><br><span class="line">            p++;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(x[p]&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> t = x[right];</span><br><span class="line">            x[right] = x[p];</span><br><span class="line">            x[p] = t;</span><br><span class="line">            right--;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//填空：</span></span><br><span class="line">            p++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分析如下：</p><p><img src="/images/%E8%93%9D%E6%A1%A5%E6%9D%AF2013A/2013-5.jpg" style="zoom:50%;"></p><h2 id="6、逆波兰表达式"><a href="#6、逆波兰表达式" class="headerlink" title="6、逆波兰表达式"></a>6、逆波兰表达式</h2><blockquote><p>正常的表达式称为中缀表达式，运算符在中间，主要是给人阅读的，机器求解并不方便。<br>例如∶3+5 * (2+ 6) - 1<br>而且，常常需要用括号来改变运算次序。<br>相反，如果使用逆波兰表达式(前缀表达式)表示，上面的算式则表示为: </p><p>-+3<em> 5+2 6 1<br>不再需要括号，机器可以用递归的方法很方便地求解。<br>为了简便，我们假设∶<br>1，只有＋-</em>三种运算符<br>2．每个运算数都是一个小于10的非负整数<br>下面的程序对—个逆波兰表示串进行求值。<br>其返回值为一个数组∶其中第一元素表示求值结果，第二个元素表示它已解析的字符数。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] evaluate(String x){</span><br><span class="line">    <span class="keyword">if</span>(x.length()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] {<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">char</span> c = x.charAt(<span class="number">0</span>); <span class="comment">//获得第一个字符</span></span><br><span class="line">    <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)  <span class="comment">//如果获得的这个字符是0~9</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] {c-<span class="string">'0'</span>,<span class="number">0</span>}; </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span>[] v1 = evaluate(x.substring(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span>[] v2 = ____________________;<span class="comment">//填空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> v = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">'+'</span>) v = v1[<span class="number">0</span>]+v2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">'*'</span>) v = v1[<span class="number">0</span>]*v2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">'-'</span>) v = v1[<span class="number">0</span>]-v2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]{v,<span class="number">1</span>+v1[<span class="number">1</span>]+v2[<span class="number">1</span>]};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分析如下：</p><p>递归函数，前边两个if语句是为了排除输入的不是逆波兰表达式的情况，第一个if排除输入字符串为空的情况，第二个if排除第一个字符为数字的情况，因为逆波兰表达式第一个字符应该是运算符。</p><p>题目给了一个例子：-+3<em> 5+2 6 1 转换为 3+5 </em> (2+ 6) - 1 </p><p>结合代码分析，输入string x = -+3* 5+2 6 1  ,截取字符串x的第一个字符，也就是“ - ”，然后声明了一个数组 <code>v1</code> 进入递归，这个 <code>v1</code> 存的是字符串 x 除开第一位之后的子串经过evaluate函数递归处理后的式子，结合后来的</p><p><code>if(c=='-') v = v1[0]-v2[0];</code> </p><p>我们可以猜测这里 <code>v1[0]</code> 代表的是3+5 <em> (2+ 6)，<code>v1[2]</code>代表的是1。这样组合起来就是 3+5 </em> (2+ 6) - 1 </p><p>再推测当递归进行到最后一层的时候 <code>v1</code> 存的是逆波兰表达式解析后原式要进行的第一层运算的前半部分，<code>v2</code>存第一层运算的后半部分，<code>c</code>代表的就是运算符。</p><p>那么如何得到 <code>v2</code> 呢？</p><p><img src="/images/%E8%93%9D%E6%A1%A5%E6%9D%AF2013A/image-20220305214907458.png" alt="image-20220305214907458" style="zoom: 50%;"></p><h2 id="7、错误票据"><a href="#7、错误票据" class="headerlink" title="7、错误票据"></a>7、错误票据</h2><blockquote><p>某涉密单位下发了某种票据，并要在年终全部收回。</p><p>每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。</p><p>因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。</p><p>你的任务是通过编程，找出断号的ID和重号的ID。</p><p>假设断号不可能发生在最大和最小号。</p><p>要求程序首先输入一个整数N(N&lt;100)表示后面数据行数。<br>接着读入N行数据。<br>每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000）<br>每个整数代表一个ID号。</p><p>要求程序输出1行，含两个整数m n，用空格分隔。<br>其中，m表示断号ID，n表示重号ID</p><p>例如：<br>用户输入：<br>2<br>5 6 8 11 9<br>10 12 9</p><p>则程序输出：<br>7 9</p><p>再例如：<br>用户输入：<br>6<br>164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196<br>172 189 127 107 112 192 103 131 133 169 158<br>128 102 110 148 139 157 140 195 197<br>185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190<br>149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188<br>113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119</p><p>则程序输出：<br>105 120</p><p>资源约定：<br>峰值内存消耗 &lt; 64M<br>CPU消耗 &lt; 1000ms</p></blockquote><p>思路：</p><p>将每一行用<code>nextline</code>读入，然后每一行接着用<code>split</code>进行以空格为标志进行分割，把分割好的数据装到arrylist的动态数组里，再对这个数据进行排序，<code>collations</code>类的<code>sort</code>方法实现了排序这一操作，排完序就遍历找出前后相等的，也就是重复的，以及前后相差为2的，也就是断号的。</p><p>要点：</p><p>1、因为只知道有n行，不知道每一行有多少个数据，所以应该用动态数组来装分割好的数据（刚分割出来的是字符串，要转化为int类型）</p><p>2、每一行结尾都有分隔符，所以要用<code>nextline</code>把这个分隔符读走</p><p>3、为什么要用<code>collations</code>类的<code>sort</code>方法来实现排序？这个还不是很清楚。</p><p>找到一张关系图，解释了<code>ArrayList</code>和<code>List</code>关系，所以<code>ArrayList</code>是可以用<code>collations</code>类的<code>sort</code>方法的，但具体为什么不能直接用<code>ArrayList.sort</code>呢？</p><p><code>ArrayList</code> 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。<code>ArrayList</code>继承了 <code>AbstractList</code>，并实现了 List 接口。</p><p><img src="/images/%E8%93%9D%E6%A1%A5%E6%9D%AF2013A/ArrayList.png" style="zoom:70%;"></p><p>4、细节</p><p>最后比较排好序的list里的元素大小的时候，要注意的是，list为集合，直接这样<code>list.get(k)</code>取出来的是对象，所以比较大小应该用<code>equals</code>,这样直接比比的是地址而不是元素大小。虽然不会报错，最后结果也是正确的，但是提交到系统后会扣分。</p><p>而<code>list.get(k)-list.get(k-1)==2</code>可以直接这样写，是因为做了运算，java会自动转换数据类型，所以不影响这个判断，可以直接用<code>==</code></p><p>具体代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.CollationElementIterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongID</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">//因为并不知道每一行究竟有多少个元素，所以用动态数组来装每一行的元素</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//先接收一下输入的N，即有N行数据</span></span><br><span class="line"><span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line"><span class="comment">//每一行数据结束之后有一个换行符，所以要把换行符读出去</span></span><br><span class="line">sc.nextLine();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) {</span><br><span class="line"><span class="comment">//想用nextLine来读取每一行数据</span></span><br><span class="line">String line = sc.nextLine();</span><br><span class="line"><span class="comment">//然后用split以空格为标识来分割这一行字符</span></span><br><span class="line">            <span class="comment">//把一个个数字当做字符串先存到split数组里</span></span><br><span class="line">String[] split = line.split(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;split.length;j++) {</span><br><span class="line"><span class="comment">//将split数组里分割出来的string类型的数字转换为整数类型然后存入动态数组list里</span></span><br><span class="line">list.add(Integer.parseInt(split[j]));</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//collations类的sort方法实现了list接口的集合进行排序</span></span><br><span class="line"><span class="comment">//拍完序方便找出断号的和重复的</span></span><br><span class="line">Collections.sort(list);</span><br><span class="line"><span class="keyword">int</span> broke = <span class="number">0</span>,repeat = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;list.size();k++) {</span><br><span class="line"><span class="comment">//如果前后两个数差为2就说明断开了，相差为1就正常</span></span><br><span class="line"><span class="keyword">if</span>(list.get(k)-list.get(k-<span class="number">1</span>)==<span class="number">2</span>)</span><br><span class="line">   broke = list.get(k)-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//如果前后两个数相等就说明重复了，相差为1就正常</span></span><br><span class="line"><span class="comment">//if(list.get(k)==list.get(k-1))</span></span><br><span class="line">            <span class="comment">//注意list集合比较大小应该用equals</span></span><br><span class="line">            <span class="keyword">if</span>(list.get(k).equals(list.get(k-<span class="number">1</span>)))</span><br><span class="line">   repeat = list.get(k);</span><br><span class="line">}</span><br><span class="line">System.out.println(broke+<span class="string">" "</span>+repeat);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="8、带分数"><a href="#8、带分数" class="headerlink" title="8、带分数"></a>8、带分数</h2><blockquote><p>100 可以表示为带分数的形式：100 = 3 + 69258 / 714。</p><p>还可以表示为：100 = 82 + 3546 / 197。</p><p>注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。</p><p>类似这样的带分数，100 有 11 种表示法。</p><p>输入格式</p><p>从标准输入读入一个正整数N (N&lt;1000*1000)</p><p>输出格式</p><p>程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。</p><p>注意：不要求输出每个表示，只统计有多少表示法！</p><p>样例输入1</p><p>100</p><p>样例输出1</p><p>11</p><p>样例输入2</p><p>105</p><p>样例输出2</p><p>6</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、世纪末问题（calendar-API）&quot;&gt;&lt;a href=&quot;#1、世纪末问题（calendar-API）&quot; class=&quot;headerlink&quot; title=&quot;1、世纪末问题（calendar API）&quot;&gt;&lt;/a&gt;1、世纪末问题（calendar API）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1999年的12月31日是星期五，请问:未来哪一个离我们最近的一个世纪末年〈即xx99年）的12月31日正好是星期天（即星期日)?&lt;br&gt;请回答该年份(只写这个4位整数，不要写12月31等多余信息)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;关键在于是否知道calendar类的存在，直接调用这个类，设定好年份月份日期再获取这一天是星期几就可以了&lt;/p&gt;</summary>
    
    
    
    <category term="JavaA组" scheme="https://laylaycjl.github.io/categories/JavaA%E7%BB%84/"/>
    
    
    <category term="蓝桥杯备赛笔记" scheme="https://laylaycjl.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>系统架构师案例分析</title>
    <link href="https://laylaycjl.github.io/2021/10/19/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <id>https://laylaycjl.github.io/2021/10/19/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</id>
    <published>2021-10-19T13:38:52.000Z</published>
    <updated>2022-07-01T10:24:02.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一题、软件架构评估"><a href="#第一题、软件架构评估" class="headerlink" title="第一题、软件架构评估"></a>第一题、软件架构评估</h1><h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><h3 id="1、软件质量属性"><a href="#1、软件质量属性" class="headerlink" title="1、软件质量属性"></a>1、软件质量属性</h3><p>1、性能</p><p>性能(performance)是指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件的个数。<br>代表参数:响应时间、吞吐量设计策略:优先级队列、资源调度</p><p>2、可用性</p><p>可用性(availability)是系统能够正常运行的时间比例。经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示。<br>代表参数:故障间隔时间设计策略:冗余、心跳线</p><span id="more"></span><p>3、安全性</p><p>安全性(security)是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。安全性又可划分为机密性、完整性、不可否认性及可控性等特性。<br>设计策略:追踪审计</p><p>4、可修改性</p><p>可修改性(modifiability)是指能够快速地以较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量可修改性。<br>主要策略:接口-实现分离、抽象、信息隐藏</p><h3 id="2、系统架构风险、敏感点与权衡点"><a href="#2、系统架构风险、敏感点与权衡点" class="headerlink" title="2、系统架构风险、敏感点与权衡点"></a>2、系统架构风险、敏感点与权衡点</h3><p><strong>系统架构风险</strong>是指架构设计中潜在的、存在问题的架构决策所带来的隐患。</p><p><strong>敏感点</strong>是指为了实现某种特定的质量属性，一个或多个构件所具有的特性。</p><p><strong>权衡点</strong>是影响多个质量属性的特性，是多个质量属性的敏感点。</p><h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><h3 id="1、常用的质量属性包括"><a href="#1、常用的质量属性包括" class="headerlink" title="1、常用的质量属性包括:"></a>1、常用的<strong>质量属性</strong>包括:</h3><p>1、性能<br>性能(performance)是指系统的<u>响应能力</u>，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件的个数。<br>2、可靠性<br>可靠性(reliability)是软件系统在应用或系统错误面前，在意外或错误使用的情况下<u>维持软件系统的功能特性</u>的基本能力。<br>3、可用性<br>可用性(availability)是系统<u>能够正常运行的时间比例</u>。经常用两次故障之间的时间长度或在<u>出现故障时系统能够恢复正常的速度</u>来表示。<br>4、安全性<br>安全性(security)是指系统在向合法用户提供服务的同时能够<u>阻止非授权用户使用的企图或拒绝服务的能力</u>。安全性又可划分为机密性、完整性、不可否认性及可控性等特性。<br>5、可修改性<br>可修改性(modifiability)是指能够<u>快速地以较高的性能价格比对系统进行变更的能力</u>。通常以某些具体的变更为基准，通过考察这些变更的代价衡量可修改性。<br>6、易用性<br>软件开发工具应有十分<u>友好的用户界面</u>，用户乐于使用;工具应能剪裁和定制，以适应特定用户的需要;工具应能提示用户的交互操作，提供简单有效的执行方式;工具还应能检查用户的操作错误，尽可能自动改正错误。</p><h3 id="2、管道过滤器风格与仓库风格"><a href="#2、管道过滤器风格与仓库风格" class="headerlink" title="2、管道过滤器风格与仓库风格"></a>2、管道过滤器风格与仓库风格</h3><h4 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h4><p>在<u>管道/过滤器风格</u>的软件体系结构中，每个构件都有一组输入和输出，数据输入构件，经过内部处理，然后产生数据输出。因此，这里的<u>构件被称为过滤器</u>，这种风格的连接件就像是数据流传输的管道，将一个过滤器的输出传到另一过滤器的输入。</p><p>在<u>仓库(repository)风格</u>中，有两种不同的构件:<u>中央数据结构说明当前状态</u>，<u>独立构件在中央数据存储上执行</u>。                                                                                                                                                                    一方面，若构件控制共享数据，则仓库是——<u>传统型数据库</u>;                                                                                                                                      另一方面，若中央数据结构的当前状态触友进程执行的选择，则仓库是——<u>黑板系统</u>。</p><h4 id="（2）对比"><a href="#（2）对比" class="headerlink" title="（2）对比"></a>（2）对比</h4><ul><li>交互方式：                                                                                                                                                                                                                        管理过滤器很明显是<u>顺序结构或循环结构</u>，数据在管理中进行传递。                                                                                                            仓库结构是数据在中心位置，所有的处理均是中心结点与周边结点之间的交互，从形态来看，是<u>星型</u>的。</li><li>数据结构：从数据结构来看                                                                                                                                                              管道过滤器则是在过滤器之间传递<u>数据流</u>；                                                                                                              仓库风格会使用一个<u>文件</u>将数据保存起来，所有的操作围绕这个文件进行。</li><li>控制结构：从控制结构来说                                                                                                                                          管道过滤器是由<u>数据流</u>驱动的                                                                                                                                                                                                                     仓库风格是<u>业务功能</u>驱动</li><li>扩展方法：从扩展方法来讲                                                                                                                                                                                                                          管道过滤器是<u>通过过滤器提供标准接口</u>与其他过滤器对接，                                                                                                             数据仓库风格，要共享数据，扩展功能，<u>只要功能的操作与数据模型本身是匹配的就行了</u>，就像我们要共享一个数据库做系统集成，此时共享同—数据库的多个应用系统所用的数据模型—定会是一致的，否则无法去共享。</li></ul><h3 id="3、补充集成开发环境"><a href="#3、补充集成开发环境" class="headerlink" title="3、补充集成开发环境"></a>3、补充集成开发环境</h3><p>本题最后一问是分析开发环境架构图。要填充这个图，首先得想明白的是，这个环境中，<strong>仓库的中心是数据，数据对应的是语法结构树</strong>，因为一系列的处理都是以此为依据来进行的。接下来找出与编译器同等地位的其他处理工具即可。</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20211019220740747.png" alt="image-20211019220740747" style="zoom:67%;"></p><h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><p>same as 2015</p><h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20211020151617284.png" alt="image-20211020151617284"></p><h3 id="1、系统架构设计中非功能需求"><a href="#1、系统架构设计中非功能需求" class="headerlink" title="1、系统架构设计中非功能需求"></a>1、系统架构设计中非功能需求</h3><p>操作性需求：与用户<u>操作使用系统</u>相关的一些需求</p><p>性能需求：指响应时间、吞吐量、准确性、有效性、资源利用率等<u>与系统完成任务效率相关</u>的指标。可靠性、可用性等指标可归为此类。</p><p>安全性需求：系统<u>向合法用户提供服务</u>并<u>阻止非授权用户使用服务</u>方面的系统需求。</p><p>文化需求：带有<u>文化背景因素</u>的系统需求</p><p>操作性需求包括：技术环境需求、系统集成需求、可移植性需求、维护性需求</p><p>性能需求包括：速度需求、容量需求、可信需求</p><p>安全性需求包括：系统价值需求、访问控制需求、加密/认证需求、病毒控制需求</p><p>文化需求包括：多语言需求、个性化定制需求、规范性描述需求、法律需求</p><h3 id="2、瘦客户端C-S架构和胖客户端C-S架构"><a href="#2、瘦客户端C-S架构和胖客户端C-S架构" class="headerlink" title="2、瘦客户端C/S架构和胖客户端C/S架构"></a>2、瘦客户端C/S架构和胖客户端C/S架构</h3><p>总结：</p><p>瘦客户端架构体量小，所以适合于更新变化，故障修复，个性定制的系统</p><p>胖客户端架构体量大，所以适合于对性能要求高（相应速度、传输速度等）且不怎么变化的系统</p><p>在安全性上，两者无明显差异</p><ul><li><p>基本概念：</p><ul><li><p><strong>胖客户端(C/S模式)</strong>应用程序的优势是<u>客户端和服务器端都能够处理任务</u>，对客户机的要求较高，但可以减轻服务器的压力。</p><p>应用：目前在<u>企业内部管理系</u>统中大量使用。</p><p>缺点是：</p><ul><li>1、系统客户端<u>软件安装、维护困难</u>，</li><li>2、数据库系统无法满足对于大量终端同时联机的需求</li><li>3、客户/服务器间的大量数据通信<u>不适合远程连接</u>，只能适合于局域网应用。</li><li>4、C/S系统的各部分模块中有一部分改变，就要关联到其它模块的变动，<u>系统升级维护成本较大</u>。</li></ul></li><li><p><strong>瘦客户端(B/S模式)</strong>应用程序的优势是其灵活性。任何时间、地点、系统，只要使用浏览器上网，就可以使用B/S系统的终端。</p><p>应用：目前在<u>网络远程办公系统、电子商务站点等系统</u>中大量使用。</p><p>缺点是：</p><ul><li>这种结构的客户端浏览器，<u>必须总是具有网络连接</u></li><li><u>只能完成浏览、查询、数据输入等简单功能</u></li><li>绝大部分工作由服务器承担，<u>服务器的负担很重</u></li><li>这种模式的开发、维护等几乎所有工作都集中在服务器端，<u>系统维护与升级的成本较低</u></li></ul></li><li><p><strong>智能客户端(SC/S模式)</strong>应用程序可以将胖客户端(C/S模式)与瘦客户端(B/S模式)应用程序的优点结合起来。</p><ul><li>它可以无接触部署、自动更新、动态加载和方便的离线运用。</li><li>具有如下全部或部分特征的管理系统适合使用这种模式：<ul><li>充分利用本地计算机资源，发挥客户机的功能；</li><li>利用网络资源，解决信息孤岛问题；</li><li>支持远程登陆；</li><li>支持在网络不联接情况下的单机工作；</li><li>提供智能安装和更新；</li><li>支持客户端设备灵活性；</li><li>这种模式目前开发成本较高但应用方便，维护成本较低。</li></ul></li></ul></li></ul></li><li><p>题目分析：</p><p><strong>(a）</strong>用户界面支持用户的个性化定制——瘦客户端更合适</p><p>​            无论胖还是瘦，要做到用户界面的个性化都没有问题，但从更新的角度来看，胖客户端针对新增的个性  化要求，更新起来比较困难。所以相对来说，瘦客户端更有优势。</p><p><strong>(b）</strong>系统需要支持<u>当前</u>主流的标准和服务，特别是通信协议和平台接口——瘦客户端更合适</p><p>​            从单次实现来看，都能实现，但要随时保持最新，瘦客户更有优势。</p><p>(c）用户操作的响应时间应不大于3秒，竞拍板块不大于1秒——胖客户端更合适</p><p>​            胖客户端，在客户端的运算能力强一些。</p><p><strong>(d）</strong>系统具有故障诊断和快速恢复能力——瘦客户端更合适</p><p>​            瘦客户端将业务逻辑迁移到应用服务器上，所以有故障只要修复服务器上的内容，而胖客户端要更新所有客户端，工作量大，所以此情况下瘦客户端有优势。</p><p>(e）用户密码需要加密传输</p><p>​            瘦客户端与胖客户端无明显差异。</p><p>(f）系统需要支持不低于2G的数据缓存——胖客户端更合适</p><p>​            胖客户端做到2G数据缓存很容易，而瘦客户端不容易实现。</p><p>(g）用户操作停滞时间超过一定时限需要重新登录验证</p><p>​            瘦客户端与胖客户端无明显差异。</p><p><strong>(h）</strong>系统支持用户选择汉语、英语或法语三种语言之—进行操作——瘦客户端更合适</p><p>​            瘦客户端与胖客户端均可做到，但若涉及到更新，瘦客户端有优势。</p></li></ul><h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><h3 id="面向对象架构与基于规则架构"><a href="#面向对象架构与基于规则架构" class="headerlink" title="面向对象架构与基于规则架构"></a>面向对象架构与基于规则架构</h3><div class="table-container"><table><thead><tr><th>架构风格</th><th>灵活性</th><th>可扩展性</th><th>性能</th></tr></thead><tbody><tr><td>面向对象</td><td>将用户级别、折扣规则等封装为对象，在系统启动时加载</td><td>加入新的用户级别和折扣规则时需要重新定义新的对象，并需要重启系统</td><td>用户级别和折扣规则已经在系统内编码，可直接运行，性能较好</td></tr><tr><td>基于规则</td><td>将用户级、折扣规则等描述为可动态改变的规则数据</td><td>加入新的用户级别和折扣规则时只需要定义新的规则，解释规则即可进行扩展。</td><td>需要对用户级别与折扣规则进行实时解释、性能可能较差</td></tr></tbody></table></div><h1 id="第二题、UML建模、软件系统设计"><a href="#第二题、UML建模、软件系统设计" class="headerlink" title="第二题、UML建模、软件系统设计"></a>第二题、UML建模、软件系统设计</h1><h2 id="2015-1"><a href="#2015-1" class="headerlink" title="2015"></a>2015</h2><h3 id="1、状态图和活动图概念及区别"><a href="#1、状态图和活动图概念及区别" class="headerlink" title="1、状态图和活动图概念及区别"></a>1、状态图和活动图概念及区别</h3><ul><li><p><strong>状态图</strong>用来描述<u>一个特定对象</u>的<u>所有可能状态</u>以及其<u>引起状态转移的事件</u></p><p>一个状态图包括<u>一系列的状态</u>以及<u>状态之间的转移</u></p><p>状态图通常用于表示<u>单个对象</u>在其生命周期中的行为。</p></li><li><p><strong>活动图</strong>用来描述<u>操作的行为</u>，也用于描述<u>用例和对象内部的工作过程</u>。</p><p>状态图和活动图都是用来描述系统的<u>动态行为特征</u>的</p><p>主要用于描述事物的<u>状态变化</u>和<u>处理过程</u>。</p></li><li><p>但是两者还是有本质区别:<br>状态图和活动图用于不同的目的：</p><p>状态图着重<strong>描述</strong><u>—系列的状态</u>及<u>状态间的转移</u>，状态间的变迁需要<u>外部事件</u>的触发。</p><p>活动图用于<strong>捕获</strong><u>动作</u>（将要执行的工作或活动）及<u>动作的结果</u>，活动图中一个活动结束将立即进入下一个活动，是<u>内部处理驱动</u>的流程。</p></li></ul><h2 id="2016-1"><a href="#2016-1" class="headerlink" title="2016"></a>2016</h2><h3 id="1、用例图和类图"><a href="#1、用例图和类图" class="headerlink" title="1、用例图和类图"></a>1、用例图和类图</h3><ul><li><p>用例图中用例之间的关系</p><p>关联、泛化、依赖（包含、扩展）</p><p>泛化：可看做继承，从一般到特殊</p><p>包含：一定会被执行</p><p>扩展：有可能会被执行</p></li><li><p>类图中类之间的关系</p><p>关联、泛化、依赖、聚合、组合、实现</p><p>关联关系：描述了—组链，链是对象之间的连接。</p><p>泛化关系：特殊/一般关系</p><p>依赖关系：—个事物发生变化影响另—个事物。</p><p>聚合关系：整体与部分生命周期不同。</p><p>组合关系：整体与部分生命周期相同。</p><p>实现关系：接口与类之间的关系</p></li></ul><h2 id="2017-1"><a href="#2017-1" class="headerlink" title="2017"></a>2017</h2><h3 id="1、MVC软件设计模式"><a href="#1、MVC软件设计模式" class="headerlink" title="1、MVC软件设计模式"></a>1、MVC软件设计模式</h3><p>MVC是一种目前广泛流行的软件设计模式。近年来，随着J2EE(Java 2Enterprise Edition)的成熟，MVC成为了J2EE平台上推荐的一种设计模式。</p><h4 id="【问题1】控制器、模型、视图"><a href="#【问题1】控制器、模型、视图" class="headerlink" title="【问题1】控制器、模型、视图"></a>【问题1】控制器、模型、视图</h4><p>MVC强制性地把一个应用的输入、处理、输出流程按照视图、控制、模型的方式进行分离，形成了三个核心模块:控制器、模型、视图。</p><p>(1）控制器(Controller):控制器接受用户的输入并调用模型和视图去完成用户的需求。该部分是用户界面与Model的接口。一方面它解释来自于视图的输入，将其解释成为系统能够理解的对象，同时它也识别用户动作，并将其解释为对模型特定方法的调用;另一方面，它处理来自于模型的事件和模型逻辑执行的结果，调用适当的视图为用户提供反馈。</p><p>(2〉模型(Model)︰模型是应用程序的主体部分。模型表示业务数据和业务逻辑。一个模型能为多个视图提供数据。由于同一个模型可以被多个视图重用，所以提高了应用的可重用性。</p><p>(3）视图(View):视图是用户看到并与之交互的界面。视图向用户显示相关的数据，并能接收用户的输入数据，但是它并不进行任何实际的业务处理。视图可以向模型查询业务状态，但不能改变模型。视图还能接受模型发出的数据更新事件，从而对用户界面进行同步更新。</p><h4 id="【问题2】EJB中Bean的三种类型"><a href="#【问题2】EJB中Bean的三种类型" class="headerlink" title="【问题2】EJB中Bean的三种类型"></a>【问题2】EJB中Bean的三种类型</h4><p>EJB中的Bean分三种类型:Session Bean、Entity Beans和Message-Driven Bean。Session Bean的职责是:维护—个短暂的会话。</p><p>Entity Beans的职责是:维护—行持久稳固的数据。</p><p>Message-Driven Bean的职责是:异步接受消息。</p><p>Session Bean描述了与客户端的一个短暂的会话。</p><p>当客户端的执行完成后，Session Bean和它的数据都将消失Entity Bean描述了存储在数据库表中的一行持久稳固的数据，如果客户端终止或者服务结束，底层的服务会负责entity Bean 数据的存储。</p><p>Message-driven bean结合了Session Bean和Java信息服务(JMS)信息监听者的功能，它允许一个商业组件异步地接受JMS消息。</p><h4 id="【问题3】有状态-Stateful）会话构件和无状态-Stateless）会话构件"><a href="#【问题3】有状态-Stateful）会话构件和无状态-Stateless）会话构件" class="headerlink" title="【问题3】有状态(Stateful）会话构件和无状态(Stateless）会话构件"></a>【问题3】有状态(Stateful）会话构件和无状态(Stateless）会话构件</h4><p>本题考查考生对JavaEE架构中会话构件(Session Bean)的掌握情况。</p><p>会话构件负责维护客户端与服务端的交互状态，按照是否跨方法调用保存客户端与服务端的交互状态可以分为有状态会话构件和无状态会话构件。</p><ul><li><p>有状态会话构件（Stateful）在交互过程中需要保存客户端与服务端交互的中间状态数据，一般在实现类中有自身的属性用于存储中间状态数据。</p></li><li><p>无状态会话构件（Stateless）则不需要保存客户端与服务端的交互状态数据，客户端每次发起的请求相互独立，不会对服务端状态产生影响，因此服务端类不需要保存中间状态数据。</p></li></ul><p>eg.</p><p>身份认证构件完成初次身份认证后需要在服务端记录客户端的身份信息，在线编辑构件需要在操作过程中记录前一次编辑的操作结果，所以两者需要设汁为有状态会话构件。资源发布、资源检索和统计分析构件对客户端多次请求均保持─致外理过程和结果，所以应设计为无状态会话构件。</p><h2 id="2018-1"><a href="#2018-1" class="headerlink" title="2018"></a>2018</h2><h3 id="1、数据流图填存储、实体、过程"><a href="#1、数据流图填存储、实体、过程" class="headerlink" title="1、数据流图填存储、实体、过程"></a>1、数据流图填存储、实体、过程</h3><h3 id="2、实体与类的区别"><a href="#2、实体与类的区别" class="headerlink" title="2、实体与类的区别"></a>2、实体与类的区别</h3><p>信息工程方法中的“实体(entity)”与面向对象方法中的”类(class)”之间有哪些不同之处?</p><p>实体只有属性、类有属性和操作</p><p>实体用于数据建模、类用于面向对象建模</p><h3 id="3、Essential-Use-Cases和Real-Use-Cases"><a href="#3、Essential-Use-Cases和Real-Use-Cases" class="headerlink" title="3、Essential Use Cases和Real Use Cases"></a>3、Essential Use Cases和Real Use Cases</h3><p>在面向对象方法中通常采用用例(Use Case)来捕获系统的功能需求。用例可以按照不同的层次来进行划分，其中的Essential Use Cases和Real Use Cases有哪些区别?</p><p>Essential Use Cases指的是抽象用例，抽象于基础用例，为了避免重复的操作，优化结构而提出的用例。抽象用例描述用例的属性，主要用于分析阶段，它与用例的具体实现方式无关。</p><p>Real Use Cases指的是基础用例，基础用例与用户需求一一对应，直接来源于用户的需求。基础用例描述用例的实现，主要用于设计阶段，它表达了实现该用例时所使用的技术和方法。</p><h2 id="2019-1"><a href="#2019-1" class="headerlink" title="2019"></a>2019</h2><h3 id="1、数据流图填存储、实体、过程-1"><a href="#1、数据流图填存储、实体、过程-1" class="headerlink" title="1、数据流图填存储、实体、过程"></a>1、数据流图填存储、实体、过程</h3><h3 id="2、补充缺失的数据流"><a href="#2、补充缺失的数据流" class="headerlink" title="2、补充缺失的数据流"></a>2、补充缺失的数据流</h3><h3 id="3、说明数据流和系统流程图的区别"><a href="#3、说明数据流和系统流程图的区别" class="headerlink" title="3、说明数据流和系统流程图的区别"></a>3、说明数据流和系统流程图的区别</h3><p>数据流图中的处理过程可以并行、系统流程图在某一时刻只能有一个处理过程执行</p><p>数据流图描述的是系统的数据流，系统流程图描述的是系统的控制流</p><p>数据流图各个处理过程不遵循统一的时间标准，系统流程图各个处理过程遵循统一的时间标准</p><h1 id="第三题、嵌入式系统"><a href="#第三题、嵌入式系统" class="headerlink" title="第三题、嵌入式系统"></a>第三题、嵌入式系统</h1><h2 id="2015-2"><a href="#2015-2" class="headerlink" title="2015"></a>2015</h2><h3 id="1、嵌入式系统的可靠性"><a href="#1、嵌入式系统的可靠性" class="headerlink" title="1、嵌入式系统的可靠性"></a>1、嵌入式系统的可靠性</h3><p>可靠性的定义及包含的4个子特性，并简要指出提高系统可靠性一般采用哪些技术?</p><p>可靠性定义：在规定的<u>条件</u>下和在规定的<u>时间</u>内，完成规定的<u>功能</u>的<strong>能力</strong></p><p>可靠性的4个子特性：<strong>成熟性</strong>、<strong>容错性</strong>、<strong>易恢复性</strong>、<strong>可靠性的依从性</strong></p><p>提高系统可靠性一般采用的技术：<strong>N版本程序设计</strong>、<strong>恢复块方法</strong>、防卫式程序设计、<strong>双机热备</strong>或<strong>集群系统</strong>、<strong>冗余设计</strong></p><h3 id="2、硬件可靠性与软件可靠性"><a href="#2、硬件可靠性与软件可靠性" class="headerlink" title="2、硬件可靠性与软件可靠性"></a>2、硬件可靠性与软件可靠性</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20211025145054537.png" alt="image-20211025145054537" style="zoom:80%;"></p><h3 id="3、用恢复块方法实现软件可靠性设计"><a href="#3、用恢复块方法实现软件可靠性设计" class="headerlink" title="3、用恢复块方法实现软件可靠性设计"></a>3、用恢复块方法实现软件可靠性设计</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20211025145639109.png" alt="image-20211025145639109" style="zoom:80%;"></p><h3 id="4、N版本程序设计与恢复块方法对比"><a href="#4、N版本程序设计与恢复块方法对比" class="headerlink" title="4、N版本程序设计与恢复块方法对比"></a>4、N版本程序设计与恢复块方法对比</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/image-20211025145750733.png" alt="image-20211025145750733" style="zoom:80%;"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一题、软件架构评估&quot;&gt;&lt;a href=&quot;#第一题、软件架构评估&quot; class=&quot;headerlink&quot; title=&quot;第一题、软件架构评估&quot;&gt;&lt;/a&gt;第一题、软件架构评估&lt;/h1&gt;&lt;h2 id=&quot;2015&quot;&gt;&lt;a href=&quot;#2015&quot; class=&quot;headerlink&quot; title=&quot;2015&quot;&gt;&lt;/a&gt;2015&lt;/h2&gt;&lt;h3 id=&quot;1、软件质量属性&quot;&gt;&lt;a href=&quot;#1、软件质量属性&quot; class=&quot;headerlink&quot; title=&quot;1、软件质量属性&quot;&gt;&lt;/a&gt;1、软件质量属性&lt;/h3&gt;&lt;p&gt;1、性能&lt;/p&gt;
&lt;p&gt;性能(performance)是指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件的个数。&lt;br&gt;代表参数:响应时间、吞吐量设计策略:优先级队列、资源调度&lt;/p&gt;
&lt;p&gt;2、可用性&lt;/p&gt;
&lt;p&gt;可用性(availability)是系统能够正常运行的时间比例。经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示。&lt;br&gt;代表参数:故障间隔时间设计策略:冗余、心跳线&lt;/p&gt;</summary>
    
    
    
    <category term="软考" scheme="https://laylaycjl.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="软考高级" scheme="https://laylaycjl.github.io/tags/%E8%BD%AF%E8%80%83%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>系统架构师上午真题知识点</title>
    <link href="https://laylaycjl.github.io/2021/09/29/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://laylaycjl.github.io/2021/09/29/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-09-29T07:12:13.000Z</published>
    <updated>2021-10-18T05:28:02.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统架构设计师上午题"><a href="#系统架构设计师上午题" class="headerlink" title="系统架构设计师上午题"></a>系统架构设计师上午题</h1><h1 id="真题知识点"><a href="#真题知识点" class="headerlink" title="真题知识点"></a>真题知识点</h1><p>转载自www.educity.cn</p><h1 id="2015年"><a href="#2015年" class="headerlink" title="2015年"></a>2015年</h1><h2 id="1、分片式数据库"><a href="#1、分片式数据库" class="headerlink" title="1、分片式数据库"></a>1、分片式数据库</h2><p>6题</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210929164652309.png" alt="image-20210929164652309" style="zoom:50%;"></p><p>C</p><span id="more"></span><p>解析：</p><ul><li><p>分片透明性是指<u>用户不必关系数据是如何分片的，它们对数据的操作在全局关系上进行，即关系如何分片对用户是透明的</u>，因此，当分片改变时应用程序可以不变。<strong>分片透明性是最高层次的透明性</strong>，如果用户能在全局关系一级操作，则数据如何分布，如何存储等细节自不必关系，其应用程序的编写与集中式数据库相同。</p></li><li><p>复制透明指的是<u>用户或应用程序不关心数据库在网络中各个结点的复制情况</u></p></li><li><p>位置透明性是指<u>用户不必知道所操作的数据放在何处，即数据分配到哪个或哪些站点存储对用户是透明的。</u>因此数据分片模式的改变，如把数据从一个站点转移到另一个站点将不会影响应用程序，因而应用程序不必改写。</p></li><li><p>局部映像透明性<strong>（逻辑透明)是最低层次的透明性</strong>，该透明性提供数据到局部数据库的映像，<u>即用户不必关系局部DBMS支持哪种数据模型、使用哪种数据操纵语言，数据模型和操纵语言的转换是由系统完成的</u>。因此，局部映像透明性对异构型和同构异质的分布式数据库系统是非常重要的。</p></li></ul><h2 id="2、嵌入式"><a href="#2、嵌入式" class="headerlink" title="2、嵌入式"></a>2、嵌入式</h2><h4 id="（1）嵌入式操作系统中的板级支持包BSP"><a href="#（1）嵌入式操作系统中的板级支持包BSP" class="headerlink" title="（1）嵌入式操作系统中的板级支持包BSP"></a>（1）嵌入式操作系统中的板级支持包BSP</h4><p>9题</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210929151452317.png" alt="image-20210929151452317" style="zoom:50%;"></p><p>B</p><p>解析：</p><ul><li><p>板级支持包 (BSP）是介于主板硬件和操作系统中驱动层程序之间的一层，一般认为它属于<strong>操作系统一部分</strong>，主要是实现对操作系统的支持，为上层的驱动程序提供访问硬件设备寄存器的函数包，使之能够更好的运行于硬件主板。</p><p>在嵌入式系统软件的组成中，就有BSP。</p></li><li><p>BSP是相对于操作系统而言的，不同的操作系统对应于不同定义形式的BSP，例如VxWorks的BSP和Linux的BSP相对于某一CPU来说尽管实现的功能一样，可是写法和接口定义是完全不同的，所以写BSP一定要按照该系统BSP的定义形式来写(BSP的编程过程大多数是在某一个成型的BSP模板上进行修改)。这样才能与上层OS保持正确的接口，良好的支持上层OS。</p></li><li><p>BSP主要功能为屏蔽硬件，提供操作系统及硬件驱动，具体功能包括:</p><p>1.单板硬件初始化，主要是CPU的初始化，为整个软件系统提供底层硬件支持</p><p>2.为操作系统提供设备驱动程序和系统中断服务程序</p><p>3.定制操作系统的功能，为软件系统提供一个实时多任务的运行环境</p><p>4.初始化操作系统，为操作系统的正常运行做好准备。</p></li><li><p>板级支持包(BSP，也称为硬件抽象层HAL)一般包含相关<strong>底层硬件的初始化</strong>、<strong>数据的输入/输出操作</strong>和<strong>硬件设备的配置</strong>等功能，它主要具有以下两个特点。</p><p>①硬件相关性，因为嵌入式实时系统的硬件环境具有应用相关性，而作为上层软件与硬件平台之间的接口，BSP需为操作系统提供操作和控制具体硬件的方法。<br>②操作系统相关性，不同的操作系统具有各自的软件层次结构，因此不同操作系统具有特定的硬件接口形式。</p></li></ul><h4 id="（2）嵌入式操作系统特点"><a href="#（2）嵌入式操作系统特点" class="headerlink" title="（2）嵌入式操作系统特点"></a>（2）嵌入式操作系统特点</h4><p>10题</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210929165247297.png" alt="image-20210929165247297" style="zoom:50%;"></p><p>B</p><p>解析：</p><p>嵌入式操作系统的特点包括:</p><p>1）系统内核小<br>由于嵌入式系统一般是应用于小型电子装置的，系统资源相对有限，所以内核较之传统的操作系统要小得多。比如Enea公司的OSE分布式系统，内核只有5K。</p><p>2)专用性强<br>嵌入式系统的个性化很强，其中的软件系统和硬件的结合非常紧密，一般要针对硬件进行系统的移植，即使在同一品牌、同一系列的产品中也需要根据系统硬件的变化和增减不断进行修改。同时针对不同的任务，往往需要对系统进行较大更改，程序的编译下载要和系统相结合，这种修改和通用软件的“升级”是完全两个概念。</p><p>3）系统精简<br>嵌入式系统一般没有系统软件和应用软件的明显区分，不要求其功能设计及实现上过于复杂，这样一方面利于控制系统成本，同时也利于实现系统安全。</p><p>4）高实时性<br>高实时性的系统软件(OS)是嵌入式软件的基本要求。而且软件要求固态存储，以提高速度;软件代码要求高质量和高可靠性。</p><p>5)多任务的操作系统<br>嵌入式软件开发要想走向标准化，就必须使用多任务的操作系统。嵌入式系统的应用程序可以没有操作系统直接在芯片上运行。但是为了合理地调度多任务、利用系统资源、系统函数以及和专用库函数接口，用户必须自行选配<br>RTOS (Real - Time Operating System)开发平台,这样才能保证程序执行的实时性、可靠性，并减少开发时间，保障软件质量。</p><p>6)需要开发工具和环境<br>嵌入式系统开发需要开发工具和环境。由于其本身不具备自开发能力，即使设计完成以后用户通常也是不能对其中的程序功能进行修改的，必须有一套开发工具和环境才能进行开发,这些工具和环境一般是基于通用计算机上的软硬件设备以及各种逻辑分析仪、混合信号示波器等。开发时往往有主机和目标机的概念，主机用于程序的开发，目标机作为最后的执行机，开发时需要交替结合进行。</p><h4 id="（2）嵌入式软件设计"><a href="#（2）嵌入式软件设计" class="headerlink" title="（2）嵌入式软件设计"></a>（2）嵌入式软件设计</h4><p>11题</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210929165909276.png" alt="image-20210929165909276" style="zoom:50%;"></p><p>解析：</p><p>备选答案中，只有硬件无关性与可移植性相关。实上，现在很多嵌入式系统开发对此非常重视，例如进行电视机顶盒开发,以前解码使用硬件芯片解码的做法比较普遍,现在随着嵌入式系统CPU运算能力的提升，人们开始将硬件解码改为软件解码，为的就是解决移植过程中由于解码芯片型号不同带来的问题。</p><h2 id="3、RAID5阵列"><a href="#3、RAID5阵列" class="headerlink" title="3、RAID5阵列"></a>3、RAID5阵列</h2><p>13、14题</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210929170316229.png" alt="image-20210929170316229" style="zoom:50%;"></p><p>解析：</p><p>RAID5是一种存储性能、数据安全和存储成本兼顾的存储解决方案。这种方案中数据信息与校验信息的配比是N+1方案，即<strong>N份数据，1份校验信息</strong>。</p><p>当用3块容量为80G的硬盘实际数据容量为160G。</p><p>当3盘不同容量的盘做RAID时，会以最小容量的盘为准,所以2块80G和1块40G的盘视为3块40G的盘,所以容量为80G。</p><h2 id="4、IPV6阵列"><a href="#4、IPV6阵列" class="headerlink" title="4、IPV6阵列"></a>4、IPV6阵列</h2><p>15题</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210929170650490.png" alt="image-20210929170650490" style="zoom:50%;"></p><p>解析：</p><p>A: IPv4的首部比IPv6复杂，因为IPv6删减掉了IPv4中许多不必要的功能</p><p>B：IPv6寻址模式分为三种，即单播地址、组播地址和泛播地址。<br>通常一台IPv6主机有多个IPv6地址,即使该主机只有一个单接口。-台IPv6主机可以同时拥有以机种单点传送地址:<br>每个接口的链路本地地址; .<br>每个接口的单播地址(可以是一 个站点本地地址和一个或多个可聚集全球地址) ;<br>回环(loopback)接口的回环地址(: : 1);<br>此外，每台主机还需要时刻保持收听以下多点传送地址上的信息;<br>节点本地范围内所有节点组播地址(FFOUh?链路本地范围内所有节点组播地址(FF02::1); .<br>请求节点(solicited-node)组播地址 (如果主机的某个接口加入请求节点组;<br>组播组组播地址(如果主机的某个接U加人任何组播组)。</p><h2 id="5、评价程序"><a href="#5、评价程序" class="headerlink" title="5、评价程序"></a>5、评价程序</h2><p>17题</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210929171101249.png" alt="image-20210929171101249" style="zoom:50%;"></p><p>解析：</p><p>评价程序用于测试新系统的性能。</p><p>基准程序测试：将应用程序中用得最多的，最频繁的那部分核心程序作为评估计算机系统性能的标准程序</p><p>评测准确程度:</p><p>真实程序 &gt; 核心程序 &gt; 小型基准程序 &gt; 合成基准程序</p><p>合成基准程序覆盖面广了,但是毕竟不是全覆盖，造成了系统的不确定或者说增加了跟真实系统偏离的概率,所以相对单个的小型基准程序来说更不准确。</p><h2 id="6、信息系统基础"><a href="#6、信息系统基础" class="headerlink" title="6、信息系统基础"></a>6、信息系统基础</h2><h3 id="（1）商业智能系统"><a href="#（1）商业智能系统" class="headerlink" title="（1）商业智能系统"></a>（1）商业智能系统</h3><p>22题</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210929171351378.png" alt="image-20210929171351378" style="zoom:50%;"></p><p>解析：</p><p>商业智能系统的处理过程包括数据预处理、建立数据仓库、数据分析及数据展现4个主要阶段。</p><ul><li><p><u>数据预处理</u>是整合企业原始数据的第一步，包括<strong>数据的抽取</strong>、<strong>转换</strong>和<strong>装载</strong>三个过程。</p></li><li><p><u>建立数据仓库</u>则是处理海量数据的基础。</p></li><li><p><u>数据分析</u>是体现系统智能的关键，一般采用<strong>OLAP</strong>和<strong>数据挖掘技术</strong>。</p><ul><li><p><strong>联机分析处理OLAP</strong>不仅进行数据汇总/聚集，同时还提供切片、切块、下钻、上卷和旋转等数据分析功能，用户可以方便地对海量数据进行多维分析。主要用于数据仓库。</p><p>区分<strong>联机数据处理OLTP</strong>：主要应用于传统的关系型数据库</p></li><li><p>数据挖掘的目标则是挖掘数据背后隐藏的知识，通过关联分析、聚类和分类等方法建立分析模型，预测企业未来发展趋势和将要面临的问题。</p></li></ul></li><li><p>在海量数据和分析手段增多的情况下，<u>数据展现</u>则主要保障系统分析结果的可视化。</p></li></ul><h2 id="7、项目管理"><a href="#7、项目管理" class="headerlink" title="7、项目管理"></a>7、项目管理</h2><h3 id="（1）项目范围管理"><a href="#（1）项目范围管理" class="headerlink" title="（1）项目范围管理"></a>（1）项目范围管理</h3><p>25题</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211003101018993.png" alt="image-20211003101018993" style="zoom:50%;"></p><p>D</p><p>解析：</p><p>项目范围管理：包括保证项目顺利完成所需的全部工作过程。</p><ul><li><p>目的是控制项目的全部活动都在需求范围内，以确保项目资源的高效利用。</p></li><li><p>主要包括<u>项目启动</u>、<u>范围计划编制</u>、<u>范围定义</u>、<u>范围核实</u>和<u>范围变更控制</u>5个部分的内容。</p><ul><li><p><strong>项目启动</strong>指批准项目启动或者允许项目进入下一个阶段</p></li><li><p><strong>范围计划编</strong>制是将生产项目产品所需进行的项目工作渐进明细和形成文件的过程;</p></li><li><p><strong>项目范围定义</strong>是把主要的项目可交付成果分解成更小、更易管理的单元，</p><p>以达到如下目的:</p><ul><li>提高对成本、时间及资源估算的准确性。</li><li>为绩效测量与控制定义一个基准计划。</li><li>便于进行明确的职责分配。</li></ul></li><li><p><strong>范围定义</strong>：正确的范围定义是项目成功的关键。“当范围定义不明确时，不可避免的变更会使最终项目成本大大超出预算，因为这些不可避免的变更会破坏项目节奏，导致返工、增加项目历时、降低生产率和工作人员的士气”。</p></li><li><p><strong>范围核实</strong>是项目干系人（发起人、客户）正式接受项目范围的过程。范围核实需要审查可交付成果和工作结果，以确保它们都已经正确圆满地完成。如果项目被提前终止，范围核实过程应当对项目完成程度建立文档。范围核实与质量控制是不同的，范围核实是有关工作结果的“接收”，而质量控制是有关工作结果的正确性。项目范围变更控制涉及的是:<br>对造成范围变更的因素施加影响，以确保这些变更得到一致认可;确定范围变更是否已经发生;<br>当范围变更发生时对实际变更进行管理。</p></li><li><p><strong>范围变更控制</strong>必须与其他控制管理过程（进行控制、成本控制和质量控制）结合在一起使用，才能取得良好的效果。</p></li></ul></li></ul><h3 id="（2）软件配置管理"><a href="#（2）软件配置管理" class="headerlink" title="（2）软件配置管理"></a>（2）软件配置管理</h3><p>26题</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211003110400088.png" alt="image-20211003110400088" style="zoom:50%;"></p><p>解析：</p><p>配置项的状态有3种：草稿（draft）、正式发布（released）、正在修改（changing）</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211003141849297.png" style="zoom:50%;"></p><h1 id="2016年"><a href="#2016年" class="headerlink" title="2016年"></a>2016年</h1><h2 id="一、计算机组成原理"><a href="#一、计算机组成原理" class="headerlink" title="一、计算机组成原理"></a>一、计算机组成原理</h2><h3 id="1、嵌入式"><a href="#1、嵌入式" class="headerlink" title="1、嵌入式"></a>1、嵌入式</h3><p>（1）嵌入式处理器</p><p>3题</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009133627724.png" alt="image-20211009133627724" style="zoom:50%;"></p><ul><li><p>嵌入式微处理器MPU：</p><p>MPU采用增强型通用微处理器。由于嵌入式系统通常应用于环境比较恶劣的环境中，因而MPU在工作温度、电磁兼容性以及可靠性方面的要求较通用的标准微处理器高。但是<u>，MPU在功能方面与标准的微处理器基本上是一样的。</u>A是错的。</p><p>MPU对可靠性和安全性要求高，但在功能方面和其他微处理器是一样的</p></li><li><p>微控制器MCU：</p><p>MCU又称单片微型计算机(Single Chip Microcomputer)或者单片机，是指随着大规模集成电路的出现及其发展，将计算机的CPU、RAM、ROM、定时计数器和多种I/O接口集成在一片芯片上，形成芯片级的计算机，为不同的应用场合做不同组合控制。B是对的。</p></li><li><p>数字信号处理器DSP：</p><p>DSP是一种独特的微处理器，是以数字信号来处理大量信息的器件。其实时运行速度可达每秒数以千万条复杂指令程序，远远超过通用微处理器，它的<u>强大数据处理能力</u>和<u>高运行速度</u>，是最值得称道的两大特色。C也是对的，</p></li><li><p>片上系统SOC</p><p>SOC称为系统级芯片，也有称片上系统,意指它是一个产品，是一个有专用目标的集成电路，<u>其中包含完整系统并有嵌入软件的全部内容</u>，D也是对的。</p></li></ul><h3 id="2、磁盘存储（缓冲区）"><a href="#2、磁盘存储（缓冲区）" class="headerlink" title="2、磁盘存储（缓冲区）"></a>2、磁盘存储（缓冲区）</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009134746612.png" alt="image-20211009134746612" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009142617869.png" style="zoom:50%;"></p><h2 id="二、计算机网络"><a href="#二、计算机网络" class="headerlink" title="二、计算机网络"></a>二、计算机网络</h2><h3 id="1、TCP-IP协议族"><a href="#1、TCP-IP协议族" class="headerlink" title="1、TCP/IP协议族"></a>1、TCP/IP协议族</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009145745830.png" alt="image-20211009145745830" style="zoom:50%;"></p><p>区分服务（DiffServ）：是为解决服务质量问题，在网络上将用户发送的数据流按照它对<u>服务质量的要求</u>划分等级的一种协议。</p><p>区分服务将具有相同特性的若干业务流汇聚起来，为整个汇聚流提供服务，而不是面向单个业务流来提供服务。</p><p>每个IP分组都要根据其QoS需求打上一个标记，这种标记称为DS码点，可以利用IPv4协议头中的<strong><u>服务类型字段</u></strong>，或者IPv6协议头中的<strong><u>通信类别字段</u></strong>来实现，这样就维持了现有的IP分组格式不变。</p><h3 id="2、IPv6"><a href="#2、IPv6" class="headerlink" title="2、IPv6"></a>2、IPv6</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009151658619.png" alt="image-20211009151658619" style="zoom:50%;"></p><p>IPv6地址的格式前缀(FP)用于表示地址类型或子网地址，用类似于IPv4的CIDR表示方法表示。</p><p>链路本地地址:前缀为1111111010，用于同一链路的相邻节点间的通信.相当于IPv4的自动专用IP地址。</p><p>为实现IP地址的自动配置，IPv6主机将MAC地址附加在地址前缀1111111010之后，产生一个链路本地地址。</p><h3 id="3、管理距离"><a href="#3、管理距离" class="headerlink" title="3、管理距离"></a>3、管理距离</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009152002347.png" alt="image-20211009152002347" style="zoom:50%;"></p><p><u>管理距离是指—种路由协议的路由可信度。</u>每一种路由协议按可靠性从高到低，依次分配一个信任等级，这个信任等级就叫管理距离。</p><p>为什么要出现管理距离这个技术呢?<br>在自治系统内部，如RIP协议是根据路径传递的跳数来决定路径长短也就是传输距离，而像EIGRP协议是根据路径传输中的带宽和延迟来决定路径开销从而体现传输距离的。这是两种不同单位的度量值，我们没法进行比较。为了方便比较，我们定义了管理距离。这样我们就可以统一单位从而衡量不同协议的路径开销从而选出最优路径。</p><p>正常情况下，<u>管理距离越小，它的优先级就越高，也就是可信度越高。</u><br>对于两种不同的路由协议到一个目的地的路由信息，路由器首先根据管理距离决定相信哪一个协议。<br>AD值越低，则它的优先级越高。一个管理距离是一个从<u>0——255的整数值，0是最可信赖的，而255则意味着不会有业务量通过这个路由。</u><br>由此可见，管理距离是与信任相关的，只有选项C是相符的。</p><h2 id="三、企业信息化战略与实施"><a href="#三、企业信息化战略与实施" class="headerlink" title="三、企业信息化战略与实施"></a>三、企业信息化战略与实施</h2><h3 id="1、政府信息化与电子政务"><a href="#1、政府信息化与电子政务" class="headerlink" title="1、政府信息化与电子政务"></a>1、政府信息化与电子政务</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009152450073.png" alt="image-20211009152450073"></p><p>参考解析:</p><p>电子政务的行为主体包括:<strong>政府</strong>、<strong>企(事)业单位</strong>及<strong>居民</strong>。<br>国家和地方人口信息的采集、处理和利用，属于<strong>政府对政府</strong>的电子政务活动。</p><h3 id="2、企业信息化与电子商务"><a href="#2、企业信息化与电子商务" class="headerlink" title="2、企业信息化与电子商务"></a>2、企业信息化与电子商务</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009152832036.png" alt="image-20211009152832036"></p><p>参考解析:</p><p>信息化的”三流”: <strong>信息流</strong>，<strong>资金流</strong>，<strong>物流</strong>。</p><p>采购与库存管理是ERP的基本模块，其中采购管理模块是对采购工作——从采购订单产生至货物收到的全过程进行组织、实施与控制。</p><p>库存管理(Inventory Management, IM）模块则是对企业物料的进、出、存进行管理。</p><h2 id="四、开发管理"><a href="#四、开发管理" class="headerlink" title="四、开发管理"></a>四、开发管理</h2><h3 id="1、软件配置管理"><a href="#1、软件配置管理" class="headerlink" title="1、软件配置管理"></a>1、软件配置管理</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009161331171.png" alt="image-20211009161331171"></p><p><strong>配置管理</strong>是PMBOK、ISO9000和CMMI中的重要组成元素，它在产品开发的生命周期中，提供了结构化的、有序化的、产品化的管理方法，是项目管理的基础工作。</p><p><u><strong>配置管理</strong>是通过技术和行政手段对产品及其开发过程和生命周期进行控制、规范的一系列措施和过程。</u>信息系统开发过程中的变更以及相应的返工会对产品的质量有很大的影响。</p><p><u><strong>产品配置</strong>是指一个产品在其生命周期各个阶段所产生的各种形式(机器可读或人工可读)和各种版本的文档、计算机程序、部件及数据的集合。</u>该集合中的每一个元素称为该产品配置中的一个配置项(Configuration ltem, Cl)。</p><ul><li><p>配置项主要有两大类：</p><p>属于<strong>产品组成部分</strong>的工作成果，如需求文档、设计文档、源代码、测试用例等。</p><p>属于<strong>项目管理</strong>和<strong>机构支撑过程域</strong>产生的文档，如工作计划、项目质量报告、项目跟踪报告等。这些文档虽然不是产品的组成部分，但是值得保存。</p></li></ul><p><strong>软件系统的文档</strong>可以分为<u>用户文档</u>和<u>系统文档</u>两类。</p><ul><li><p><strong>用户文档</strong>主要描述系统功能和使用方法，并不关心这些功能是怎样实现的。</p><p>用户文档是用户了解系统的第一步，它可以让用户获得对系统的准确的初步印象。</p><p>用户文档至少应该包括下述5方面的内容:<br>(1）功能描述：说明系统能做什么;<br>(2）安装文档：说明怎样安装这个系统以及怎样使系统适应特定的硬件配置;<br>(8）使用手册：简要说明如何着手使用这个系统(通过丰富的例子说明怎样使用常用的系统功能，并说明用户操作错误时怎样恢复和重新启动);<br>(4）参考手册：详尽描述用户可以使用的所有系统设施以及它们的使用方法，并解释系统可能产生的各种出错信息的含义(对参考手册最主要的要求是完整，因此通常使用形式化的描述技术);<br>(5）操作员指南(如果需要有系统操作员的话)：说明操作员应如何处理使用中出现的各种情况。系统文档<br>所谓系统文档指从问题定义、需求说明到验收测试计划这样—系列和系统实现有关的文档。描述系统设计、实现和测试的文档对于理解程序和维护程序来说是非常重要的。</p></li><li><p><strong>系统文档</strong>描述系统设计、实现和测试等各方面的内容。</p></li></ul><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009182224882.png" alt="image-20211009182224882"></p><p>软件系统工具的种类繁多，很难有统一的分方法。</p><p>通常可以按软件过程活动将软件工具分为：<br><strong>软件开发工具</strong>：需求分析工具、设计工具、编码与排错工具。<br><strong>软件维护工具</strong>：版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具。<br><strong>软件管理和软件支持工具</strong>：项目管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择。</p><h3 id="2、软件需求管理"><a href="#2、软件需求管理" class="headerlink" title="2、软件需求管理"></a>2、软件需求管理</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009180029700.png" alt="image-20211009180029700"></p><ul><li><p>过程能力成熟度模型（CMM ) 在软件开发机构中被广泛用来指导软件过程改进。</p><p>该模型描述了软件处理能力的5个成熟级别。为了达到过程能力成熟度模型的第二级，组织机构必须具有<strong>6个</strong>关键过程域KPA ( Key ProcessAreas )。故A选项错误。</p></li><li><p>除了文本，每一个功能需求应该有一些相关的信息与它联系，我们把这些信息称为<strong>需求属性</strong>。对于一个大型的复杂项目来说，丰富的属性类别显得尤为重要。例如，在文档中考虑和明确如下属性：</p><p>1、创建需求的时间 2、需求的版本号 3、创建需求的作者 4、负责认可该软件需求的人员 5、需求状态 6、需求的原因和根据 7、需求涉及的子系统 8、需求涉及的产品版本号 9、使用的验证方法或者接受的测试标准 10、产品的优先级或者重要程度 11、需求的稳定性。故B选项错误。</p></li><li><p>需求的变更遵循以下流程:<br>（1）<u>问题分析和变更描述。</u>这是识别和分析需求问题或者一份明确的变更提议，以检查它的有效性，从而产生个更明确的需求变更提议。<br>（2）<u>变更分析和成本计算。</u>使用可追溯性信息和系统需求的一般知识，对需求变更提议进行影响分析和评估。变更成本计算应该包括对需求文档的修改、系统修改的设计和实现的成本。一旦分析完成并且被确认，应该进行是否执行这一变更的决策。<br>（3）<u>变更实现。</u>这要求需求文档和系统设计以及实现都要同时修改。如果先对系统的程序做变更，然后再修改需求文档，这几乎不可避免地会出现需求文档和程序的不一致。<br>故C选项错误。</p></li></ul><h3 id="3、软件重用"><a href="#3、软件重用" class="headerlink" title="3、软件重用"></a>3、软件重用</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211010160050833.png" alt="image-20211010160050833"></p><p>软件重用是指在两次或多次不同的软件开发过程中重复使用相同或相似软件元素的过程。</p><p><strong>软件元素</strong>包括<u>需求分析文档</u>、<u>设计过程</u>、<u>设计文档</u>、<u>程序代码</u>、<u>测试用例</u>、<u>领域知识</u>等。</p><p>对于新的软件开发项目而言，它们或者是构成整个目标软件系统的部件，或者在软件开发过程中发挥某种作用。通常将这些软件元素称为<strong>软部件</strong>。</p><h2 id="五、开发方法"><a href="#五、开发方法" class="headerlink" title="五、开发方法"></a>五、开发方法</h2><h3 id="1、软件开发模型"><a href="#1、软件开发模型" class="headerlink" title="1、软件开发模型"></a>1、软件开发模型</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009180752487.png" alt="image-20211009180752487"></p><p>记住。</p><p>螺旋模型在快速模型的基础上扩展而成。</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211009181030564.png" alt="image-20211009181030564"></p><p>（1）<strong>XP(Extreme Programming，极限编程）</strong>在所有的敏捷型方法中，XP是最引人瞩目的。它源于Smalltalk圈子，特别是Kent Beck和Ward Cunningham在2o世纪80年代末的密切合作。XP在一些对费用控制严格的公司中的使用，已经被证明是非常有效的。</p><p>（2）<strong>Cockburn的水晶系列方法</strong>，水晶系列方法是由Alistair Cockburn提出的。<u>它与XP方法一样，都有以人为中心的理念，但在实践上有所不同。</u>Alistair考虑到人们一般很难严格遵循一个纪律约束很强的过程，因此，与XP的高度纪律性不同，Alistair探索了用<u>最少纪律约束而仍能成功</u>的方法，从而在产出效率与易于运作上达到一种平衡也就是说，虽然水晶系列不如XP那样的产出效率，但会有更多的人能够接受并遵循它。</p><p>（3）<strong>开放式源码</strong>，这里提到的开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是<u>程序开发人员在地域上分布很广</u>，这使得它和其他敏捷方法不同，因为一般的敏捷方法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是<u>查错排障(debug)的高度并行性</u>，任何人发现了错误都可将改正源码的“补丁”文件发给维护者。然后由维护者将这些“补丁”或是新增的代码并入源码库。</p><p>（4）<strong>SCRUM</strong>。SCRUM已经出现很久了，像前面所论及的方法一样，该方法强调这样一个事实，即明确定义了的可重复的方法过程只限于在明确定义了的可重复的环境中，为明确定义了的可重复的人员所用，去解决明确定义了的可重复的问题。</p><p>（5）<strong>Coad的功用驱动开发方法(FDD-Feature Driven Development)</strong><br>FDD是由Jeff De Luca和大师Peter Coad提出来的。像其他方法一样，它致力于短时的迭代阶段和可见可用的功能。在FDD中，一个迭代周期─般是两周。<br>在FDD中，编程开发人员分成两类:<u>首席程序员</u>和<u>类程序员(class owner)</u>。首席程序员是最富有经验的开发人员，他们是项目的协调者、设计者和指导者，而“类”程序员则主要做源码编写。</p><p>（6）<strong>ASD方法</strong>，ASD (Adaptive Software Development)方法由Jim Highsmith提出，其核心是三个非线性的、重叠的开发阶段:猜测、合作与学习。</p><h2 id="六、系统分析与设计方法"><a href="#六、系统分析与设计方法" class="headerlink" title="六、系统分析与设计方法"></a>六、系统分析与设计方法</h2><h3 id="1、UML图"><a href="#1、UML图" class="headerlink" title="1、UML图"></a>1、UML图</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211010101843355.png" alt="image-20211010101843355"></p><p>面向对象的<strong>分析模型</strong>主要由<u>顶层架构图</u>、<u>用例与用例图</u>、<u>领域概念模型</u>构成；</p><p><strong>设计模型</strong>则包含<u>以包图表示的软件体系结构图</u>、<u>以交互图表示的用例实现图</u>、<u>完整精确的类图</u>、<u>针对复杂对象的状态图</u>和<u>用以描述流程化处理过程的活动图</u>等。</p><h2 id="七、软件架构设计"><a href="#七、软件架构设计" class="headerlink" title="七、软件架构设计"></a>七、软件架构设计</h2><h3 id="1、软件质量属性"><a href="#1、软件质量属性" class="headerlink" title="1、软件质量属性"></a>1、软件质量属性</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211011154402202.png" alt="image-20211011154402202"></p><p><strong>可修改性(modifiability)</strong>是指能够<u>快速地</u>以<u>较高的性能价格比</u>对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量可修改性。</p><p>可修改性包含四个方面：</p><ul><li>（1）<strong>可维护性</strong>(maintainability)。这主要体现在问题的修复上:在错误发生后”修复”软件系统。为可维护性做好准备的软件体系结构往往能做局部性的修改并能使对其他构件的负面影响最小化。</li><li>（2）<strong>可扩展性</strong>（extendibility)。这一点关注的是使用新特性来扩展软件系统，以及使用改进版本来替换构件并删除不需要或不必要的特性和构件。为了实现可扩展性，软件系统需要松散耦合的构件。其目标是实现一种体系结构，它能使开发人员在不影响构件客户的情况下替换构件。支持把新构件集成到现有的体系结构中也是必要的。</li><li>（3）<strong>结构重组</strong>(reassemble)。这一点处理的是重新组织软件系统的构件及构件间的关系，例如通过将构件移动到一个不同的子系统而改变它的位置。为了支持结构重组，软件系统需要精心设计构件之间的关系。理想情况下它们允许开发人员在不影响实现的主体部分的情况下灵活地配置构件。</li><li>（4）<strong>可移植性</strong>(portability)。可移植性使软件系统适用于多种硬件平台、用户界面、操作系统、编程语言或编译器。为了实现可移植，需要按照硬件无关的方式组织软件系统，其他软件系统和环境被提取出。可移植性是系统能够在不同计算环境下运行的能力。这些环境可能是硬件、软件，也可能是两者的结合。在关于某个特定计算环境的所有假设都集中在一个构件中时，系统是可移植的。如果移植到新的系统需要做些更改，则可移植性就是一种特殊的可修改性。</li></ul><p>第40题（单选题)∶<br>某公司欲开发一个智能机器人系统，在架构设计阶段，公司的架构师识别出3个核心质量属性场景。其中”机器人系统主电源断电后，能够在10秒内自动启动备用电源并进行切换，恢复正常运行”主要与（<strong>可用性</strong>）质量属性相关，通常可采用（<strong>主动冗余</strong>）架构策略实现该属性；“机器人在正常运动过程中如果发现前方2米内有人或者障碍物，应在1秒内停止并在2秒内选择一条新的运行路径“主要与(<strong>性能</strong>)质量属性相关，通常可采用（<strong>资源调度</strong>）架构策略实现该属性;“对机器人的远程控制命令应该进行加密，从而能够抵挡恶意的入侵破坏行为，并对攻击进行报警和记录”主要与(<strong>安全性</strong>）质量属性相关，通常可采用（<strong>追踪审计</strong>）架构策略实现该属性。</p><p>解析：</p><ul><li><p>“机器人系统主电源断电后，能够在10秒内自动启动备用电源并进行切换，恢复正常运行”</p><p>——<u>属于<strong>可用性</strong>，因为场景描述的是<strong>故障恢复问题</strong>。<strong>主动冗余</strong>是可用性的常见策略。</u></p></li><li><p>“机器人在正常运动过程中如果发现前方2米内有人或者障碍物，应在1秒内停止并在2秒内选择一条新的运行路径”</p><p>——<u>属于<strong>性能</strong>，<strong>资源调度</strong>是其常见策略。</u></p></li><li><p>“对机器人的远程控制命令应该进行加密，从而能够抵挡恶意的入侵破坏行为，并对攻击进行报警和记录”</p><p>——<u>属于<strong>安全性</strong>，常见的策略是<strong>追踪审计</strong>。</u></p></li></ul><h3 id="2、构件与中间件技术"><a href="#2、构件与中间件技术" class="headerlink" title="2、构件与中间件技术"></a>2、构件与中间件技术</h3><h4 id="（1）面向构件的编程"><a href="#（1）面向构件的编程" class="headerlink" title="（1）面向构件的编程"></a>（1）面向构件的编程</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211010161501092.png" alt="image-20211010161501092"></p><p>面向构件的编程(COP）关注于如何支持建立面向构件的解决方案。</p><p>一个基于一般OOP风格的COP定义如下：</p><p>面向构件的编程需要下列基本的支持:</p><p>1、多态性（可替代性)</p><p>2、模块封装性(高层次信息的隐藏)</p><p>3、后期的绑定和装载(部署独立性)</p><p>4、安全性(类型和模块安全性)</p><h4 id="（2）CORBA构件模型"><a href="#（2）CORBA构件模型" class="headerlink" title="（2）CORBA构件模型"></a>（2）CORBA构件模型</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211010162029394.png" alt="image-20211010162029394"></p><p><strong>可移植对象适配器POA</strong>：是对象实现与ORB其他组件之间的中介，它将客户请求传送到伺服对象，按需创建子POA，提供管理伺服对象的策略。</p><p><strong>CORBA对象</strong>可看作是一个具有对象标识、对象接口及对象实现的抽象实体。之所以称为抽象的，是因为并没有硬性规定CORBA对象的实现机制。由于独立于程序设计语言和特定ORB产品，一个CORBA对象的引用又称可互操作的对象引用(Interoperable Object Reference)。</p><p>从客户程序的角度看，IOR中包含了对象的标识、接口类型及其他信息以查找对象实现。<br><strong>伺服对象(servant)</strong>是指具体程序设计语言的对象或实体，通常存在于一个服务程序进程之中。客户程序通过对象引用发出的请求经过ORB担当中介角色，转换为对特定的伺服对象的调用。在一个CORBA对象的生命期中，它可能与多个伺服对象相关联，因而对该对象的请求可能被发送到不同的伺服对象。<br><strong>对象标识(Object ID)</strong>是一个用于在POA中标识一个CORBA对象的字符串。它既可由程序员指派，也可由对象适配器自动分配，这两种方式都要求对象标识在创建它的对象适配器中必须具有唯—性。</p><h4 id="（3）构件"><a href="#（3）构件" class="headerlink" title="（3）构件"></a>（3）构件</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211010164119354.png" alt="image-20211010164119354"></p><p><u><strong>构件</strong>是一组通常需要 <em>同时部署</em> 的原子构件。</u>构件和原子构件之间的区别在于，大多数原子构件永远都不会被单独部署，尽管它们可以被单独部署。相反，大多数原子构件都属于一个构件家族，一次部署往往涉及整个家族。—个原子构件是一个模块和一组资源。</p><p><u><strong>原子构件</strong>是部署、版本控制和替换的基本单位。</u>原子构件通常<u>成组地部署</u>，但是它也能够被单独部署。</p><p><u><strong>模块</strong>是—组类和可能的非面向对象的结构体</u>，比如过程或者函数。一个模块是<strong>不带单独资源</strong>的原子构件(在这个严格定义下，Java包不是模块——在Java中部署的原子单元是类文件。一个单独的包被编译成多个单独的类文件——每个公共类都有一个)。</p><h3 id="3、调用返回风格"><a href="#3、调用返回风格" class="headerlink" title="3、调用返回风格"></a>3、调用返回风格</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211010173833150.png" alt="image-20211010173833150"></p><p>UDDI(Universal Descrip tion，Discovery&amp;Integration)，UDDI用于Web服务注册和服务查找;</p><p>WSDL (Web Service Description Language),WSDL用于描述Web服务的接口和操作功能;</p><p>SOAP (Simple Object Access Protocol)，SOAP为建立Web服务和服务请求之间的通信提供支持。</p><p>BPEL (Business Process Execution Language For Web Services)翻译成中文的意思是面向Web服务的业务流程执行语言，也有的文献简写成BPEL4WS，它是一种使用Web服务定义和执行业务流程的语言。使用BPEL，用户可以通过组合、编排和协调Web服务自上而下地实现面向服务的体系结构(SOA)。BPEL提供了一种相对简单易懂的方法，可将多个Web服务组合到一个新的复合服务（称作业务流程)中。</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211010180841371.png" alt="image-20211010180841371"></p><p>C2体系结构风格可以概括为:通过连接件绑定在一起的按照一组规则运作的并行构件网络。</p><p>C2风格中的系统组织规则如下:<br>（1）系统中的构件和连接件都有一个顶部和一个底部;<br>（2）构件的顶部应连接到某连接件的底部，构件的底部则应连接到某连接件的顶部，而构件与构件之间的直接连接是不允许的;<br>（3）一个连接件可以和任意数目的其他构件和连接件连接;<br>（4）当两个连接件进行直接连接时，必须由其中一个的底部到另一个的顶部。</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211010180917088.png" alt="image-20211010180917088" style="zoom:50%;"></p><h3 id="4、特定领域架构设计"><a href="#4、特定领域架构设计" class="headerlink" title="4、特定领域架构设计"></a>4、特定领域架构设计</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211011153348308.png" alt="image-20211011153348308"></p><p>DSSA的基本活动包括：<strong>领域分析、领域设计、领域实现</strong>:</p><ul><li><p>1、领域分析<br><u>这个阶段的主要目标是获得领域模型。</u>领域模型描述领域中系统之间的共同的需求，即领域模型所描述的需求为领域需求。在这个阶段中首先要进行一些准备性的活动，包括定义领域的边界。从而明确分析的对象;识别信息源整个领域工程过程中信息的来源，可能的信息源包括现存系统、技术文献、问题域和系统开发的专家、用户调查和市场分析、领域演化的历史记录等，在此基础上就可以分析领域中系统的需求，确定哪些需求是领域中的系统广泛共享的，从而建立领域模型。当领域中存在大量系统时，需要选择它们的一个子集作为样本系统。对样本系统需求的考察将显示领域需求的一个变化范围。一些需求对所有被考察的系统是共同的，一些需求是单个系统所独有的很多需求位于这两个极端之间，即被部分系统共享。</p></li><li><p>2、领域设计<br><u>这个阶段的目标是获得DSSA</u>。DSSA描述在领域模型中表示的需求的解决方案，它不是单个系统的表示，而是能够适应领域中多个系统的需求的一个高层次的设计。建立了领域模型之后，就可以派生出满足这些被建模的领域需求的DSSA，由于领域模型中的领域需求具有一定的变化性，DSSA也要相应地具有变化性。它可以通过表示多选一的(alternative)、可选的(optional)解决方案等来做到这一点。模型和DSSA来组织的，因此在这个阶段通过获得DSSA，也就同时形成了重用基础设施的规约。</p></li><li><p>3、领域实现<br><u>这个阶段的主要目标是依据领域模型和DSSA开发和组织可重用信息。</u>这些可重用信息可能是从现有系统中提取得到，也可能需要通过新的开发得到。它们依据领域模型和DSSA进行组织，也就是领域模型和DSSA定义了这些重用信息的重用时机，从而支持了系统化的软件重用。这个阶段也可以看作重用基础设施的实现阶段。<br>值得注意的是，以上过程是一个反复的、逐渐求精的过程。在实施领域工程的每个阶段中，都可能返回到以前的步骤，对以前的步骤得到的结果进行修改和完善，再回到当前步骤，在新的基础上进行本阶段的活动。</p></li></ul><p>参与DSSA的人员可以划分为四种角色:领域专家、领域分析师、领域设计人员和领域实现人员。</p><ul><li>1、领域专家<br>领域专家可能包括该领域中系统的有经验的用户、从事该领域中系统的需求分析、设计、实现以及项目管理的有经验的软件工程师等。领域专家的主要任务包括提供关于领域中系统的需求规约和实现的知识，帮助组织规范的致的领域字典，帮助选择样本系统作为领域工程的依据，复审领域模型、DSSA等领域工程产品等。<br>领域专家应该熟悉该领域中系统的软件设计和实现、硬件限制、未来的用户需求及技术走向等。</li><li>2、领域分析人员<br>领域分析人员应由具有知识工程背景的有经验的系统分析员来担任。领域分析人员的主要任务包括控制整个领域分析过程，进行知识获取，将获取的知识组织到领域模型中，根据现有系统、标准规范等验证领域模型的准确性和一致性，维护领域模型。<br>领域分析人员应熟悉软件重用和领域分析方法;熟悉进行知识获取和知识表示所需的技术、语言和工具;应具有一定的该领域的经验，以便于分析领域中的问题及与领域专家进行交互;应具有较高的进行抽象、关联和类比的能<br>力;应具有较高的与他人交互和合作的能力。</li><li>3、领域设计人员<br>领域设计人员应由有经验的软件设计人员来担任。领域设计人员的主要任务包括控制核个软件设计过程，根据领域模型和现有的系统开发出DSSA，对DSSA的准确性和一致性进行验证，建立领域模型和DSSA之间的联系。<br>领域设计人员应熟悉软件重用和领域设计方法;熟悉软件设计方法;应有一定的该领域的经验，以便于分析领域中的问题及与领域专家进行交互。</li><li>4、领域实现人员<br>领域实现人员应由有经验的程序设计人员来担任。领域实现人员的主要任务包括根据领域模型和DSSA，或者从头开发可重用构件，或者利用再工程的技术从现有系统中提取可重用构件，对可重用构件进行验证，建立DSSA与可重用构件间的联系。<br>领域实现人员应熟悉软件重用、领域实现及软件再工程技术;熟悉程序设计;具有一定的该领域的经验。</li></ul><h2 id="八、信息系统基础"><a href="#八、信息系统基础" class="headerlink" title="八、信息系统基础"></a>八、信息系统基础</h2><h3 id="1、企业信息化与电子商务"><a href="#1、企业信息化与电子商务" class="headerlink" title="1、企业信息化与电子商务"></a>1、企业信息化与电子商务</h3><h4 id="（1）企业应用集成"><a href="#（1）企业应用集成" class="headerlink" title="（1）企业应用集成"></a>（1）企业应用集成</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211010175014750.png" alt="image-20211010175014750"></p><p><strong>JDBC</strong>(Java Data Base Connectivity,java数据库连接)</p><ul><li>是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统—访问，它由一组用Java语言编写的类和接口组成。</li><li>JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。</li></ul><p><strong>JCA</strong>标准化连接子</p><ul><li>是由J2EE 1.3首先提出的，它位于J2EE应用服务器和企业信息系统(EIS)之间，比如数据库管理、企业资源规划(ERP)、企业资产管理(EAM）和客户关系管理(CRM)系统。</li><li>不是用Java开发的企业应用或者在J2EE框架内的应用都可以通过JCA连接。</li><li>JCA是在javax.resource包和它的子包(cci, spi和spi.security)中定义的。(JCA的缩写形式也用于Java cryptography API的缩写。)</li></ul><p><u><strong>JMS</strong>是Java对消息系统的访问机制，但它本身并不实现消息。</u></p><ul><li>JMS支持点对点分发的消息队列，也支持多个目标订阅的消息主题。当消息发布给一个主题的适合，消息就会发送给所有那个主题的订阅者。</li><li>JMS支持各种消息类型(二进制、流、名-值表、序列化的对象和文本)。通过声明与SQL的WHERE相近的句段，可以建立消息的过滤器。</li></ul><p><u><strong>Java lDL</strong>即idltojava编译器就是一个ORB，可用来在Java语言中定义、实现和访问CORBA对象。</u></p><ul><li>Java IDL支持的是一个瞬间的CORBA对象，即在对象服务器处理过程中有效。</li><li>实际上，Java IDL的ORB是一个类库而已，并不是一个完整的平台软件，但它对Java IDL应用系统和其他CORBA应用系统之间提供了很好的底层通信支持，实现了OMG定义的ORB基本功能。</li></ul><h2 id="九、软件测试审评方法"><a href="#九、软件测试审评方法" class="headerlink" title="九、软件测试审评方法"></a>九、软件测试审评方法</h2><h3 id="1、软件集成测试"><a href="#1、软件集成测试" class="headerlink" title="1、软件集成测试"></a>1、软件集成测试</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211010180511158.png" alt="image-20211010180511158"></p><p>集成方式</p><ul><li>非渐增式（一次性组装）</li><li>渐增式组装（自顶向下集成、自底向上集成）</li></ul><p>集成测试主要目标是发现模块之间接口和通信所存在的问题，主要发现设计阶段所产生的错误，所以在概要设计阶段制定。</p><h2 id="十、法律"><a href="#十、法律" class="headerlink" title="十、法律"></a>十、法律</h2><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211011180138907.png" alt="image-20211011180138907"></p><p>软件著作权中规定:开发软件所用的思想、处理过程、操作方法或者数学概念不受保护。</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211011180333128.png" alt="image-20211011180333128"></p><p>著作权法规定:美术作品的著作权不随原作品所有权的转变而发生变化。所以M公司购买N画家的美术作品，著作权不归M公司，而归N画家。M公司将美术作品注册为商标，是侵犯了N画家著作权的。</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211011180411428.png" alt="image-20211011180411428"></p><p>在题目的描述中，未体现出有申请专利的行为，所以不享有专利权。</p><h2 id="十一、数学"><a href="#十一、数学" class="headerlink" title="十一、数学"></a>十一、数学</h2><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211011180453086.png" alt="image-20211011180453086"></p><p>数学建模是利用数学方法解决实际问题的一种实践。即通过抽象、简化、假设、引进变量等处理过程后，将实际问题用数学方式表达，建立起数学模型，然后运用先进的数学方法及计算机技术进行求解。</p><p>数学模型是对于现实世界的一个特定对象，一个特定目的，根据特有的内在规律，做出一些必要的假设，运用适当的数学工具，得到一个数学结构。</p><p>对不同的问题，有不同的评价标准，数学模型难有统一的普适标准来评价。</p><h1 id="2017年"><a href="#2017年" class="headerlink" title="2017年"></a>2017年</h1><h2 id="一、操作系统"><a href="#一、操作系统" class="headerlink" title="一、操作系统"></a>一、操作系统</h2><h3 id="1、进程的状态"><a href="#1、进程的状态" class="headerlink" title="1、进程的状态"></a>1、进程的状态</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017100647019.png" alt="image-20211017100647019"></p><p>进程控制块PCB的组织方式有: 1) 线性表方式，2)引表方式，3)链接表方式。</p><ul><li>线性表方式：不论进程的状态如何,将所有的PCB<strong>连续地存放</strong>在内存的系统区。这种方式适用于系统中进程数<br>目不多的情况。</li><li>索引表方式：该访式是线性表方式的改进，系统按照进程的状态分别建立<strong>就绪索引表</strong>、<strong>阻塞索引表</strong>等。</li><li>链接表方式：系统按照进程的状态将进程的PCB组成队列，从而形成<strong>就绪队列、阻塞队列、运行队列</strong>等。</li></ul><h3 id="2、嵌入式操作系统——低功耗设计"><a href="#2、嵌入式操作系统——低功耗设计" class="headerlink" title="2、嵌入式操作系统——低功耗设计"></a>2、嵌入式操作系统——低功耗设计</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017104538408.png" alt="image-20211017104538408"></p><p>软件设计层面的功耗控制主要可以从以下方面展开：</p><p>1、<strong>软硬件协同</strong>设计，即软件的设计要与硬件的匹配，考虑硬件因素。</p><p>2、<strong>编译优化</strong>，采用低功耗优化的编译技术。</p><p>3、减少系统的持续运行时间，可从<strong>算法</strong>角度进行优化。</p><p>4、用“中断”代替′查询””。</p><p>5、进行电源的有效管理。</p><h2 id="二、数据库"><a href="#二、数据库" class="headerlink" title="二、数据库"></a>二、数据库</h2><h3 id="1、查询语句效率问题"><a href="#1、查询语句效率问题" class="headerlink" title="1、查询语句效率问题"></a>1、查询语句效率问题</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017101323601.png" alt="image-20211017101323601"></p><p>本题考查关系代数运行效率问题。</p><p>解决这类问题，有一个通用原则，即，存在联接操作与选择操作的，<strong>尽可能早的完成选择操作</strong>，这样能降低参与联接操作的数据量，极大提升运算效率。</p><p>本题题目有瑕疵，E2和E4是不等价的，虽然自然连接比笛卡尔积效率高，但E4由于本身与E2不等价，缺少了一次等值比较(R.A2=S.A2)，所以效率更高。</p><h3 id="2、数据仓库"><a href="#2、数据仓库" class="headerlink" title="2、数据仓库"></a>2、数据仓库</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017101702001.png" alt="image-20211017101702001"></p><p>数据仓库4大特点:<br><strong>面向主题</strong>：数据按主题组织。<br><strong>集成的</strong>：消除了源数据中的不一致性，提供整个企业的一致性全局信息。<br><strong>相对稳定</strong>（非易失的)：主要进行查询操作，只有少量的修改和删除操作(或是不删除)。<br><strong>反映历史变化</strong>(随着时间变化)：记录了企业从过去某一时刻到当前各个阶段的信息，可对发展历程和未来趋势做定量分析和预测。</p><h2 id="三、计算机组成原理"><a href="#三、计算机组成原理" class="headerlink" title="三、计算机组成原理"></a>三、计算机组成原理</h2><h3 id="1、嵌入式——DSP芯片"><a href="#1、嵌入式——DSP芯片" class="headerlink" title="1、嵌入式——DSP芯片"></a>1、嵌入式——DSP芯片</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017102229034.png" alt="image-20211017102229034"></p><p><strong>编程DSP芯片</strong>是一种具有特殊结构的<u>微处理器</u>，为了达到快速进行数字信号处理的目的，DSP芯片一般都采用特殊的软硬件结构：</p><ul><li><p>哈佛结构：</p><p>DSP采用了<strong>哈佛结构</strong>，<u>将存储器空间划分成两个，分别存储程序和数据</u>。它们有两组总线连接到处理器核，允许同时对它们进行访问，每个存储器独立编址，独立访问。这种安排将处理器的数据吞吐率加倍，更重要的是同为处理器核提供数据与指令。在这种布局下，DSP得以实现单周期的MAC指令。<br>在哈佛结构中，由于程序和数据存储器在两个分开的空间中，因此<u>取指和执行能完全重叠运行</u>。</p></li><li><p>流水线：</p><p>与哈佛结构相关，DSP芯片广泛采用2-6级流水线以减少指令执行时间，从而增强了处理器的处理能力。这可使指令执行能完全重叠，每个指令周期内，不同的指令都处于激活状态。</p></li><li><p>独立的硬件乘法器：</p><p>在实现多媒体功能及数字信号处理的系统中，算法的实现和数字滤波都是计算密集型的应用。在这些场合，乘法运算是数字处理的重要组成部分，是各种算法实现的基本元素之一。乘法的执行速度越快，DSP处理器的性能越高。相比与一般的处理器需要30-40个指令周期，<u>DSP芯片的特征就是有一个专用的硬件乘法器，乘法可以在一个周期内完成</u>。</p></li><li><p>特殊的DSP指令：</p><p>DSP的另一特征是采用特殊的指令，专为数字信号处理中的一些常用算法优化。这些特殊指令为一些典型的数字处理提供加速，可以大幅提高处理器的执行效率。使一些高速系统的实时数据处理成为可能。</p></li><li><p>独立的DMA总线和控制器：</p><p><u>有一组或多组独立的DMA总线，与CPU的程序、数据总线并行工作。</u>在不影响CPU工作的条件下，DMA的速度已经达到800MBIS以上。这在需要大数据量进行交换的场合可以减小CPU的开销，提高数据的吞吐率。提高系统的并行执行能力。</p></li><li><p>多处理器接口：</p><p>使多个处理器可以很方便的并行或串行工作以提高处理速度。</p></li><li><p>JTAG (Joint Test Action Group）：</p><p>标准测试接口(IEEE 1149标准接口)。便于对DSP作片上的在线仿真和多DSP条件下的调试。</p></li><li><p>快速的指令周期：</p><p>哈佛结构，流水线操作，专用的硬件乘法器，特殊的DSP指令再加上集成电路的优化设计，可使DSP芯片的指令周期在10ns以下。快速的指令周期可以使DSP芯片能够实时实现许多DSP应用。</p></li></ul><h3 id="2、总线"><a href="#2、总线" class="headerlink" title="2、总线"></a>2、总线</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017104304946.png" alt="image-20211017104304946"></p><p>关于串行总线的特点，总结如下:<br>1、串行总线适宜长距离传输数据。但串行总线有半双工、全双工之分，全双工是一条线发一条线收。所以A选项错误<br>2、串行总线传输的波特率在使用中可以改变，所以B选项错误。<br>3、串行总线的数据发送和接收可以使用多种方式，程序查询方式和中断方式都可以。所以D选项错误。</p><h2 id="四、系统性能评价"><a href="#四、系统性能评价" class="headerlink" title="四、系统性能评价"></a>四、系统性能评价</h2><h3 id="1、性能指标——CPU主频的计算"><a href="#1、性能指标——CPU主频的计算" class="headerlink" title="1、性能指标——CPU主频的计算"></a>1、性能指标——CPU主频的计算</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017153613850.png" alt="image-20211017153613850"></p><p>CPU的工作频率（主频）包括两个部分：外频与倍频，两者的乘积就是主频。所谓外频，就是外部频率，指的是系统总线频率。</p><p>外频（系统总线频率） x 倍频 = 主频（CPU频率）</p><p>倍频的全称是倍频系数，倍频系数是指CPU主频与外频之间的相对比例关系。</p><p>最初CPU主频和系统总线速度是一样的，但CPU的速度越来越快，倍频技术也就相应产生。它的作用是使系统总线工作在相对较低的频率上，而CPU速度可以通过倍频来提升。</p><h3 id="2、性能指标——不同系统的性能指标"><a href="#2、性能指标——不同系统的性能指标" class="headerlink" title="2、性能指标——不同系统的性能指标"></a>2、性能指标——不同系统的性能指标</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017161226983.png" alt="image-20211017161226983"></p><p>为了优化系统性能，有时需要对系统进行调整。</p><p>对于数据库系统，性能调整主要包括<strong>CPU/内存使用状况</strong>、<strong>优化数据库设计</strong>、<strong>优化数据库管理</strong>以及<strong>进程/线程状态</strong>、<strong>硬盘剩余空间</strong>、<strong>日志文件大小</strong>等;</p><p>对于应用系统，性能调整主要包括应用<strong>系统的可用性</strong>、<strong>响应时间</strong>、<strong>并发用户数</strong>以及<strong>特定应用的系统资源占用</strong>等。</p><h2 id="五、计算机网络"><a href="#五、计算机网络" class="headerlink" title="五、计算机网络"></a>五、计算机网络</h2><h3 id="1、TCP-IP协议族——通过IP查询域名"><a href="#1、TCP-IP协议族——通过IP查询域名" class="headerlink" title="1、TCP/IP协议族——通过IP查询域名"></a>1、TCP/IP协议族——通过IP查询域名</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017154337028.png" alt="image-20211017154337028"></p><p>PTR记录是反向记录，通过IP查询域名。</p><p>服务器名称——&gt;IP地址（查询DNS缓存）</p><p>IP地址——&gt;服务器名称（查询PTR记录）</p><h3 id="2、TCP-IP协议族——DHCP指令"><a href="#2、TCP-IP协议族——DHCP指令" class="headerlink" title="2、TCP/IP协议族——DHCP指令"></a>2、TCP/IP协议族——DHCP指令</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017154921496.png" alt="image-20211017154921496"></p><ul><li>发现报文（DHCP DISCOVER ）：客户端开始DHCP过程发送的包，是DHCP协议的开始。</li><li>提供报文（DHCP OFFER ）：服务器接收到DHCP DISCOVER之后做出的<u>响应</u>，它包括了给予客户端的IP（yiaddr）、客户端的MAC地址、租约过期时间、服务器的识别符以及其他信息。</li><li>请求报文（DHCP REQUEST ）：客户端对于服务器发出的DHCP OFFER所做出的响应。在租用期过了一半，需要续租用期的时候同样会使用。</li><li>确认报文（DHCP ACK ）：服务器在接收到客户端发来的DHCP REQUEST之后发出的成功确认的报文。在建立连接的时候，客户端在接收到这个报文之后才会确认分配给它的IP和其他信息可以被允许使用。</li><li>否认报文（DHCP NACK） ：DHCP ACK的相反的报文，表示服务器拒绝了客户端的请求。</li><li>释放报文（DHCP RELEASE ）：一般出现在客户端关机、下线等状况。这个报文将会使DHCP服务器释放发出此报文的客户端的IP地址，从而客户可以随时提前终止服务器所提供的租用期。</li><li>服务请求报文（DHCP INFORM ）：客户端发出的向服务器请求一些信息的报文</li><li>拒绝当前分配报文（DHCP DECLINE） ：当客户端发现服务器分配的IP地址无法使用（如IP地址冲突时），将发出此报文，拒绝已经分配的地址信息，通知服务器禁止使用该IP地址。</li></ul><h2 id="六、信息系统基础知识"><a href="#六、信息系统基础知识" class="headerlink" title="六、信息系统基础知识"></a>六、信息系统基础知识</h2><h3 id="1、系统工程"><a href="#1、系统工程" class="headerlink" title="1、系统工程"></a>1、系统工程</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017161808809.png" alt="image-20211017161808809"></p><p>系统工程在上个世纪中后期发展起来的一门新兴学科。它最早约产生于20世纪40年代的美国，时至今日，系统工程已经成为现代社会高速发展不可或缺的一部分。系统工程的诞生让自然科学和社会科学中有关的思想、理论和方法根据总体协调的需要联系起来，综合应用，并利用现代电子计算机，对系统的<strong>结构、要素、信息和反馈</strong>等进行分析，以达到<strong>最优规划、最优设计、最优管理</strong>和<strong>最优控制</strong>等目的。</p><p>霍尔三维结构是由<strong>逻辑维</strong>、<strong>时间维</strong>和<strong>知识维</strong>组成的立体空间结构：</p><p>1、逻辑维                                                                                                                                                                            运用系统工程方法解决某一大型工程项目时，一般可分为七个步骤:                                                                             (1）明确问题<br>(2）建立价值体系或评价体系                                                                                                                                                   (3）系统分析<br>(4）系统综合<br>(5）系统方案的优化选择<br>(6）决策”决策就是管理”，”决策就是决定”，人类的决策管理活动面临着被决策系统的日益庞大和日益复杂。        (7）制定计划有了决策就要付诸实施，实施就要依靠严格的有效的计划。</p><p>2、时间维（工作进程）<br>对于一个具体的工作项目，从制定规划起—直到更新为止，全部过程可分为七个阶段:                                           (1）规划阶段。即调研、程序设计阶段，目的在于谋求活动的规划与战略。<br>(2）拟定方案。提出具体的计划方案。<br>(3）研制阶段。作出研制方案及生产计划。<br>(4）生产阶段。生产出系统的零部件及整个系统，并提出安装计划。                                                                          (5）安装阶段。将系统安装完毕，并完成系统的运行计划。                                                                                                 (6）运行阶段。系统按照预期的用途开展服务。<br>(7）更新阶段。即为了提高系统功能，取消旧系统而代之以新系统，或改进原有系统，使之更加有效地工作。</p><p>3、知识维（专业科学知识）<br>系统工程除了要求为完成上述各步骤、各阶段所需的某些共性知识外，还需要其他学科的知识和各种专业技术<br>霍尔把这些知识分为工程、医药、建筑、商业、法律、管理、社会科学和艺术等。各类系统工程，如军事系统工程、经济系统工程、信息系统工程等。都需要使用其他相应的专业基础知识。</p><h2 id="七、开发管理"><a href="#七、开发管理" class="headerlink" title="七、开发管理"></a>七、开发管理</h2><h3 id="1、项目管理——时间管理"><a href="#1、项目管理——时间管理" class="headerlink" title="1、项目管理——时间管理"></a>1、项目管理——时间管理</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017164010475.png" alt="image-20211017164010475"></p><p>时间管理的过程包括:</p><p>1、活动定义<br>2、活动排序<br>3、活动的资源估算                                                                                                                                                                                        4、活动历时估算                                                                                                                                                                                        5、制定计划                                                                                                                                                                                        6、进度控制</p><h3 id="2、配置与文档管理——软件配置管理"><a href="#2、配置与文档管理——软件配置管理" class="headerlink" title="2、配置与文档管理——软件配置管理"></a>2、配置与文档管理——软件配置管理</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017164246464.png" alt="image-20211017164246464"></p><ul><li><p>用户文档</p><p>用户文档主要描述所交付系统的功能和使用方法，并不关心这些功能是怎样实现的。用户文档是了解系统的第步，它可以让用户获得对系统准确的初步印象。<br>用户文档至少应该包括下述5方面的内容。<br>①功能描述：说明系统能做什么。<br>②安装文档：说明怎样安装这个系统以及怎样使系统适应特定的硬件配置。<br>③使用手册：简要说明如何着手使用这个系统（通过丰富的例子说明怎样使用常用的系统功能，并说明用户操作错误是怎样恢复和重新启动的)。<br>④参考手册：详尽描述用户可以使用的所有系统设施以及它们的使用方法，并解释系统可能产生的各种出错信息的含义(对参考手册最主要的要求是完整，因此通常使用形式化的描述技术)。<br>⑤操作员指南(如果需要有系统操作员的话)∶说明操作员应如何处理使用中出现的各种情况。</p></li><li><p>系统文档</p><p>系统文档<u>是从问题定义</u>、<u>需求说明</u>到<u>验收测试计划</u>这样一系列和系统实现有关的文档。</p><p>描述系统设计、实现和测试的文档对于理解程序和维护程序来说是非常重要的。</p></li></ul><h3 id="3、需求管理"><a href="#3、需求管理" class="headerlink" title="3、需求管理"></a>3、需求管理</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017170721200.png" alt="image-20211017170721200"></p><p>需求管理的活动包括:</p><p>1、变更控制<br>2、版本控制                                                                                                                                                                          3、需求跟踪<br>4、需求状态跟踪</p><h3 id="4、需求管理——变更控制"><a href="#4、需求管理——变更控制" class="headerlink" title="4、需求管理——变更控制"></a>4、需求管理——变更控制</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017170930475.png" alt="image-20211017170930475"></p><p><u>变更控制委员会可以由一个小组担任，也可以由多个不同的组担任。</u>变更控制委员会的成员应能代表变更涉及的团体。变更控制委员会可能包括如下方面的代表:<br>(1）产品或计划管理部门;<br>(2）项目管理部门;<br>(3）开发部门;<br>(4）测试或质量保证部门;                                                                                                                                                  (5）市场部或客户代表;                                                                                                                                                       (6）制作用户文档的部门;                                                                                                                                                      (7）技术支持部门;<br>(8）帮助桌面或用户支持热线部门;                                                                                                                                                      (9）配置管理部门。</p><h2 id="八、开发方法"><a href="#八、开发方法" class="headerlink" title="八、开发方法"></a>八、开发方法</h2><h3 id="1、软件开发模型——原型模型"><a href="#1、软件开发模型——原型模型" class="headerlink" title="1、软件开发模型——原型模型"></a>1、软件开发模型——原型模型</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017171422445.png" alt="image-20211017171422445"></p><p>本题考查的是开发模型的特点，题目所述”由原型开发阶段和目标软件开发阶段构成”符合原型模型的特点。因为原型模型先是使用原型获取需求，需求获取到之后有可能抛弃丢原型，然后根据原型获得的需求进行目标软件的开发。</p><h3 id="2、软件开发模型——快速应用开发模型、螺旋模型"><a href="#2、软件开发模型——快速应用开发模型、螺旋模型" class="headerlink" title="2、软件开发模型——快速应用开发模型、螺旋模型"></a>2、软件开发模型——快速应用开发模型、螺旋模型</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017171643167.png" alt="image-20211017171643167"></p><p>快速应用开发模型、螺旋模型：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017171734294.png" alt="image-20211017171734294" style="zoom:67%;"></p><h3 id="3、软件开发环境"><a href="#3、软件开发环境" class="headerlink" title="3、软件开发环境"></a>3、软件开发环境</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20211017172042221.png" alt="image-20211017172042221"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;系统架构设计师上午题&quot;&gt;&lt;a href=&quot;#系统架构设计师上午题&quot; class=&quot;headerlink&quot; title=&quot;系统架构设计师上午题&quot;&gt;&lt;/a&gt;系统架构设计师上午题&lt;/h1&gt;&lt;h1 id=&quot;真题知识点&quot;&gt;&lt;a href=&quot;#真题知识点&quot; class=&quot;headerlink&quot; title=&quot;真题知识点&quot;&gt;&lt;/a&gt;真题知识点&lt;/h1&gt;&lt;p&gt;转载自www.educity.cn&lt;/p&gt;
&lt;h1 id=&quot;2015年&quot;&gt;&lt;a href=&quot;#2015年&quot; class=&quot;headerlink&quot; title=&quot;2015年&quot;&gt;&lt;/a&gt;2015年&lt;/h1&gt;&lt;h2 id=&quot;1、分片式数据库&quot;&gt;&lt;a href=&quot;#1、分片式数据库&quot; class=&quot;headerlink&quot; title=&quot;1、分片式数据库&quot;&gt;&lt;/a&gt;1、分片式数据库&lt;/h2&gt;&lt;p&gt;6题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B8%8A%E5%8D%88%E7%9C%9F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210929164652309.png&quot; alt=&quot;image-20210929164652309&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;C&lt;/p&gt;</summary>
    
    
    
    <category term="软考" scheme="https://laylaycjl.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="软考高级" scheme="https://laylaycjl.github.io/tags/%E8%BD%AF%E8%80%83%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>系统架构设计师上午题</title>
    <link href="https://laylaycjl.github.io/2021/09/08/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    <id>https://laylaycjl.github.io/2021/09/08/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/</id>
    <published>2021-09-08T05:41:27.000Z</published>
    <updated>2022-07-01T10:25:58.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统架构设计师上午题"><a href="#系统架构设计师上午题" class="headerlink" title="系统架构设计师上午题"></a>系统架构设计师上午题</h1><p>转载自www.educity.cn</p><p>上午知识点总结：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908134924552.png" alt="image-20210908134924552"></p><span id="more"></span><h2 id="一、计算机组成与体系结构"><a href="#一、计算机组成与体系结构" class="headerlink" title="一、计算机组成与体系结构"></a>一、计算机组成与体系结构</h2><h3 id="1、Flynn分类法"><a href="#1、Flynn分类法" class="headerlink" title="1、Flynn分类法"></a>1、Flynn分类法</h3><p>S: single（单）</p><p>M: multiple（多）</p><p>考查形式：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908145905265.png" alt="image-20210908145905265" style="zoom: 50%;"></p><h3 id="2、CISC与RISC"><a href="#2、CISC与RISC" class="headerlink" title="2、CISC与RISC"></a>2、CISC与RISC</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908150407631.png" alt="image-20210908150407631" style="zoom: 50%;"></p><h3 id="3、计算机层次化存储结构"><a href="#3、计算机层次化存储结构" class="headerlink" title="3、计算机层次化存储结构"></a>3、计算机层次化存储结构</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908150957580.png" alt="image-20210908150957580" style="zoom: 50%;"></p><p>寄存器速度快效率高、但容量小（顶层存储结构</p><p>外存速度慢，但容量大</p><p>cache<strong>按内容存取</strong>主存中的一部分内容，但可使得速度极大提高</p><p><strong>按内容存取</strong>也叫相联存储器</p><h3 id="4、cache"><a href="#4、cache" class="headerlink" title="4、cache"></a>4、cache</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908151453479.png" alt="image-20210908151453479" style="zoom: 50%;"></p><h3 id="5、时间局部性和空间局部性"><a href="#5、时间局部性和空间局部性" class="headerlink" title="5、时间局部性和空间局部性"></a>5、时间局部性和空间局部性</h3><p>局部性原理：计算机在处理相关程序时，会在某一时段集中地访问某一空间中的数据。</p><p>例如以下的循环语句会反复访问某一数据。</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908151944500.png" alt="image-20210908151944500" style="zoom:50%;"></p><p>空间局部性：访问某一空间之后又立即访问其临近的空间</p><h3 id="6、主存"><a href="#6、主存" class="headerlink" title="6、主存"></a>6、主存</h3><h4 id="1）、主存的分类"><a href="#1）、主存的分类" class="headerlink" title="1）、主存的分类"></a>1）、主存的分类</h4><p>随机存储器和只读存储器</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908152220294.png" alt="image-20210908152220294" style="zoom: 50%;"></p><h4 id="2）、主存的编址"><a href="#2）、主存的编址" class="headerlink" title="2）、主存的编址"></a>2）、主存的编址</h4><p>多计算题</p><h3 id="7、磁盘"><a href="#7、磁盘" class="headerlink" title="7、磁盘"></a>7、磁盘</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908152732274.png" alt="image-20210908152732274" style="zoom: 50%;"></p><h2 id="二、系统配置与性能评价"><a href="#二、系统配置与性能评价" class="headerlink" title="二、系统配置与性能评价"></a>二、系统配置与性能评价</h2><h4 id="1、计算机性能指标"><a href="#1、计算机性能指标" class="headerlink" title="1、计算机性能指标"></a>1、计算机性能指标</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908153312283.png" alt="image-20210908153312283" style="zoom: 50%;"></p><p>字长：代表计算机的一次操作可以完成对几个比特位的处理（如32位，64位</p><h4 id="2、阿姆达尔解决方案"><a href="#2、阿姆达尔解决方案" class="headerlink" title="2、阿姆达尔解决方案"></a>2、阿姆达尔解决方案</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908153604849.png" alt="image-20210908153604849" style="zoom: 50%;"></p><p>解决此类题目：先假设出所需时间，然后代入计算，求出加速的倍数</p><h4 id="3、计算机性能评价方法"><a href="#3、计算机性能评价方法" class="headerlink" title="3、计算机性能评价方法"></a>3、计算机性能评价方法</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908154249877.png" alt="image-20210908154249877" style="zoom:50%;"></p><p>指令执行速度：MIPS 用加法指令的执行速度代表指令执行速度</p><p>等效指令速度法：求出各个指令所占比例，再求速度</p><p>PDR：既考虑CPU速度也要考虑存储</p><p>CTP：PDR的进阶</p><p>基准程序法：综合全面的评测性能，综合T/O、CPU、显卡、存储等各个方面</p><h4 id="4、计算机性能监测方法"><a href="#4、计算机性能监测方法" class="headerlink" title="4、计算机性能监测方法"></a>4、计算机性能监测方法</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908154930747.png" alt="image-20210908154930747" style="zoom:50%;"></p><p>软件检测会影响到当前计算机的性能</p><p>硬件检测实现更困难，但不会影响当前计算机的性能</p><h2 id="三、操作系统基本原理"><a href="#三、操作系统基本原理" class="headerlink" title="三、操作系统基本原理"></a>三、操作系统基本原理</h2><h3 id="1、进程状态"><a href="#1、进程状态" class="headerlink" title="1、进程状态"></a>1、进程状态</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908160430513.png" alt="image-20210908160430513" style="zoom: 50%;"></p><h3 id="2、前趋图"><a href="#2、前趋图" class="headerlink" title="2、前趋图"></a>2、前趋图</h3><p>略</p><h3 id="3、进程的同步与互斥"><a href="#3、进程的同步与互斥" class="headerlink" title="3、进程的同步与互斥"></a>3、进程的同步与互斥</h3><p>同步——异步</p><p>互斥——共享</p><h3 id="4、PV操作"><a href="#4、PV操作" class="headerlink" title="4、PV操作"></a>4、PV操作</h3><p>略</p><h3 id="5、PV操作与前趋图"><a href="#5、PV操作与前趋图" class="headerlink" title="5、PV操作与前趋图"></a>5、PV操作与前趋图</h3><p>略</p><h3 id="6、死锁"><a href="#6、死锁" class="headerlink" title="6、死锁"></a>6、死锁</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908162344663.png" alt="image-20210908162344663" style="zoom:50%;"></p><h3 id="7、银行家算法"><a href="#7、银行家算法" class="headerlink" title="7、银行家算法"></a>7、银行家算法</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908162413112.png" alt="image-20210908162413112" style="zoom:50%;"></p><h3 id="8、页式存储、段式存储、段页式存储"><a href="#8、页式存储、段式存储、段页式存储" class="headerlink" title="8、页式存储、段式存储、段页式存储"></a>8、页式存储、段式存储、段页式存储</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909205612746.png" alt="image-20210909205612746" style="zoom: 50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909205715705.png" alt="image-20210909205715705" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909205756688.png" alt="image-20210909205756688" style="zoom:50%;"></p><p>快表</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909205828593.png" style="zoom:50%;"></p><h3 id="9、页面淘汰算法"><a href="#9、页面淘汰算法" class="headerlink" title="9、页面淘汰算法"></a>9、页面淘汰算法</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909205926877.png" alt="image-20210909205926877" style="zoom:50%;"></p><h3 id="10、索引文件结构"><a href="#10、索引文件结构" class="headerlink" title="10、索引文件结构"></a>10、索引文件结构</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909210013120.png" alt="image-20210909210013120" style="zoom:50%;"></p><h3 id="11、树形目录结构"><a href="#11、树形目录结构" class="headerlink" title="11、树形目录结构"></a>11、树形目录结构</h3><p>主要考察<strong>绝对路径</strong>和<strong>相对路径</strong>的差别</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909210054193.png" alt="image-20210909210054193" style="zoom:50%;"></p><h3 id="12、位示图法"><a href="#12、位示图法" class="headerlink" title="12、位示图法"></a>12、位示图法</h3><p>空闲存储空间管理方法：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909210218359.png" alt="image-20210909210218359" style="zoom:50%;"></p><p>（主要了解位示图法）</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909210451685.png" alt="image-20210909210451685" style="zoom:50%;"></p><h3 id="13、数据传输控制方式"><a href="#13、数据传输控制方式" class="headerlink" title="13、数据传输控制方式"></a>13、数据传输控制方式</h3><p>内存与外设之间进行数据传输的方式：</p><p>程序控制：CPU介入，外设不会主动报告是否完成数据传输</p><p>程序中断：CPU介入，传输完成后外设会向CPU报告</p><p>DMA：专门的控制器来控制传输，不需要CPU介入</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909210548872.png" alt="image-20210909210548872" style="zoom:50%;"></p><h3 id="14、微内核操作系统"><a href="#14、微内核操作系统" class="headerlink" title="14、微内核操作系统"></a>14、微内核操作系统</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909210819496.png" alt="image-20210909210819496" style="zoom:50%;"></p><h2 id="四、数据库"><a href="#四、数据库" class="headerlink" title="四、数据库"></a>四、数据库</h2><h3 id="1、三级模式、两级映射"><a href="#1、三级模式、两级映射" class="headerlink" title="1、三级模式、两级映射"></a>1、三级模式、两级映射</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909210850079.png" alt="image-20210909210850079" style="zoom:50%;"></p><h3 id="2、数据库设计过程说明"><a href="#2、数据库设计过程说明" class="headerlink" title="2、数据库设计过程说明"></a>2、数据库设计过程说明</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909210937181.png" alt="image-20210909210937181" style="zoom:50%;"></p><h3 id="3、ER模型"><a href="#3、ER模型" class="headerlink" title="3、ER模型"></a>3、ER模型</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211002201.png" alt="image-20210909211002201" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211020444.png" alt="image-20210909211020444" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211241395.png" alt="image-20210909211241395" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211241395.png" alt="image-20210909211241395" style="zoom:50%;"></p><h3 id="4、关系代数"><a href="#4、关系代数" class="headerlink" title="4、关系代数"></a>4、关系代数</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211307657.png" alt="image-20210909211307657" style="zoom:50%;"><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211332774.png" alt="image-20210909211332774" style="zoom: 80%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211307657.png" alt="image-20210909211307657" style="zoom:50%;"><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211332774.png" alt="image-20210909211332774" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211359910.png" alt="image-20210909211359910" style="zoom:50%;"></p><h3 id="5、规范化理论"><a href="#5、规范化理论" class="headerlink" title="5、规范化理论"></a>5、规范化理论</h3><h4 id="1）函数依赖"><a href="#1）函数依赖" class="headerlink" title="1）函数依赖"></a>1）函数依赖</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211431509.png" alt="image-20210909211431509" style="zoom:50%;"></p><h4 id="2）规范化理论意义"><a href="#2）规范化理论意义" class="headerlink" title="2）规范化理论意义"></a>2）规范化理论意义</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211448018.png" alt="image-20210909211448018" style="zoom:50%;"></p><h4 id="3）求候选关键字"><a href="#3）求候选关键字" class="headerlink" title="3）求候选关键字"></a>3）求候选关键字</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211503704.png" alt="image-20210909211503704" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211522173.png" alt="image-20210909211522173" style="zoom:50%;"></p><h4 id="4）范式"><a href="#4）范式" class="headerlink" title="4）范式"></a>4）范式</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211539608.png" alt="image-20210909211539608" style="zoom:50%;"></p><h4 id="5）模式分解"><a href="#5）模式分解" class="headerlink" title="5）模式分解"></a>5）模式分解</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211617802.png" alt="image-20210909211617802" style="zoom:50%;"></p><h3 id="6、数据库并发控制"><a href="#6、数据库并发控制" class="headerlink" title="6、数据库并发控制"></a>6、数据库并发控制</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211646818.png" alt="image-20210909211646818" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211737438.png" style="zoom:50%;"></p><h3 id="7、数据库完整性约束"><a href="#7、数据库完整性约束" class="headerlink" title="7、数据库完整性约束"></a>7、数据库完整性约束</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210909211832772.png" alt="image-20210909211832772" style="zoom:50%;"></p><h3 id="8、数据库安全"><a href="#8、数据库安全" class="headerlink" title="8、数据库安全"></a>8、数据库安全</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910103552673.png" alt="image-20210910103552673" style="zoom:50%;"></p><h3 id="9、数据库备份与恢复"><a href="#9、数据库备份与恢复" class="headerlink" title="9、数据库备份与恢复"></a>9、数据库备份与恢复</h3><p>备份：冷备份与热备份</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910103644539.png" alt="image-20210910103644539" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104141992.png" style="zoom:50%;"></p><p>故障恢复：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104054208.png" alt="image-20210910104054208" style="zoom:50%;"></p><h3 id="10、分布式数据库系统"><a href="#10、分布式数据库系统" class="headerlink" title="10、分布式数据库系统"></a>10、分布式数据库系统</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104323463.png" alt="image-20210910104323463" style="zoom:50%;"><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104342973.png" alt="image-20210910104342973"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104342973.png" style="zoom:50%;"></p><h3 id="11、数据库优化"><a href="#11、数据库优化" class="headerlink" title="11、数据库优化"></a>11、数据库优化</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104435801.png" alt="image-20210910104435801" style="zoom:50%;"></p><h3 id="12、数据仓库与数据挖掘"><a href="#12、数据仓库与数据挖掘" class="headerlink" title="12、数据仓库与数据挖掘"></a>12、数据仓库与数据挖掘</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104503066.png" alt="image-20210910104503066" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104523744.png" alt="image-20210910104523744" style="zoom:50%;"></p><h3 id="13、联邦数据库"><a href="#13、联邦数据库" class="headerlink" title="13、联邦数据库"></a>13、联邦数据库</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104546418.png" alt="image-20210910104546418" style="zoom: 50%;"></p><h3 id="14、NoSQL技术"><a href="#14、NoSQL技术" class="headerlink" title="14、NoSQL技术"></a>14、NoSQL技术</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104635201.png" alt="image-20210910104635201" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104652357.png" style="zoom: 50%;"></p><h3 id="15、反规范化技术"><a href="#15、反规范化技术" class="headerlink" title="15、反规范化技术"></a>15、反规范化技术</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104732978.png" alt="image-20210910104732978" style="zoom:50%;"></p><h3 id="16、大数据"><a href="#16、大数据" class="headerlink" title="16、大数据"></a>16、大数据</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104754943.png" alt="image-20210910104754943" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910104813592.png" style="zoom:50%;"></p><h2 id="五、计算机网络"><a href="#五、计算机网络" class="headerlink" title="五、计算机网络"></a>五、计算机网络</h2><h3 id="1、七层模型"><a href="#1、七层模型" class="headerlink" title="1、七层模型"></a>1、七层模型</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910105722097.png" alt="image-20210910105722097" style="zoom:50%;"></p><h3 id="2、网络技术标准与协议"><a href="#2、网络技术标准与协议" class="headerlink" title="2、网络技术标准与协议"></a>2、网络技术标准与协议</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910105755314.png" alt="image-20210910105755314" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910105912298.png" alt="image-20210910105912298" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910105935030.png" alt="image-20210910105935030" style="zoom:50%;"></p><h3 id="3、网络规划与设计"><a href="#3、网络规划与设计" class="headerlink" title="3、网络规划与设计"></a>3、网络规划与设计</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910105959972.png" alt="image-20210910105959972" style="zoom: 50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110025483.png" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110113293.png" alt="image-20210910110113293" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110124230.png" alt="image-20210910110124230" style="zoom:50%;"></p><h3 id="4、无线网"><a href="#4、无线网" class="headerlink" title="4、无线网"></a>4、无线网</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110152711.png" alt="image-20210910110152711" style="zoom:50%;"></p><h3 id="5、网络接入技术"><a href="#5、网络接入技术" class="headerlink" title="5、网络接入技术"></a>5、网络接入技术</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110213693.png" alt="image-20210910110213693" style="zoom:50%;"></p><h3 id="6、网络存储技术"><a href="#6、网络存储技术" class="headerlink" title="6、网络存储技术"></a>6、网络存储技术</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110250095.png" alt="image-20210910110250095" style="zoom:50%;"></p><h3 id="7、磁盘阵列（RAID）"><a href="#7、磁盘阵列（RAID）" class="headerlink" title="7、磁盘阵列（RAID）"></a>7、磁盘阵列（RAID）</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110313553.png" alt="image-20210910110313553" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110337013.png" alt="image-20210910110337013" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110411775.png" style="zoom:50%;"></p><h3 id="8、IPv6"><a href="#8、IPv6" class="headerlink" title="8、IPv6"></a>8、IPv6</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110442642.png" alt="image-20210910110442642" style="zoom:50%;"></p><h3 id="9、物联网"><a href="#9、物联网" class="headerlink" title="9、物联网"></a>9、物联网</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110501459.png" alt="image-20210910110501459" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110519032.png" alt="image-20210910110519032" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110536596.png" alt="image-20210910110536596" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110600175.png" style="zoom:50%;"></p><h3 id="10、云计算"><a href="#10、云计算" class="headerlink" title="10、云计算"></a>10、云计算</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110647348.png" alt="image-20210910110647348" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110705192.png" style="zoom:50%;"></p><h2 id="六、企业信息化战略与实施"><a href="#六、企业信息化战略与实施" class="headerlink" title="六、企业信息化战略与实施"></a>六、企业信息化战略与实施</h2><h3 id="1、信息与信息化的概念"><a href="#1、信息与信息化的概念" class="headerlink" title="1、信息与信息化的概念"></a>1、信息与信息化的概念</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210910110805613.png" alt="image-20210910110805613" style="zoom:50%;"></p><h3 id="2、信息系统的概念"><a href="#2、信息系统的概念" class="headerlink" title="2、信息系统的概念"></a>2、信息系统的概念</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913094437961.png" alt="image-20210913094437961" style="zoom:50%;"></p><p>信息系统不一定是计算机的，也可以是人工的。</p><p>输入—&gt;加工—&gt;输出</p><h3 id="3、信息系统的模型"><a href="#3、信息系统的模型" class="headerlink" title="3、信息系统的模型"></a>3、信息系统的模型</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913094618801.png" alt="image-20210913094618801" style="zoom:50%;"></p><p>按数据环境分类：</p><p>数据文件：非常繁冗，需要人工完成信息输入输出</p><p>数据库：具体存取数据的操作由系统完成，人只需要输入指令</p><h3 id="4、信息系统的战略规划"><a href="#4、信息系统的战略规划" class="headerlink" title="4、信息系统的战略规划"></a>4、信息系统的战略规划</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913094859465.png" alt="image-20210913094859465" style="zoom:50%;"></p><ul><li><p>信息系统的发展历程：</p><p>以数据处理为核心：BSP、CSF、SST 可统称为BCS</p><p>以企业全局为核心：SDP：提出主题数据库的概念，强调全局问题；</p><p>​                                   IE：将信息系统工程化；</p><p>以集成为核心：综合考虑企业的内外环境</p></li><li><p>信息系统的主要思想：</p></li></ul><h3 id="5、政府信息化与电子商务"><a href="#5、政府信息化与电子商务" class="headerlink" title="5、政府信息化与电子商务"></a>5、政府信息化与电子商务</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913105505056.png" alt="image-20210913105505056" style="zoom:50%;"></p><p>G2G：government to government</p><p>G2B：government to business</p><p>G2C：government to citizen</p><p>G2E：government to employee</p><h3 id="6、企业信息化与电子商务"><a href="#6、企业信息化与电子商务" class="headerlink" title="6、企业信息化与电子商务"></a>6、企业信息化与电子商务</h3><h4 id="1）企业资源计划ERP"><a href="#1）企业资源计划ERP" class="headerlink" title="1）企业资源计划ERP"></a>1）企业资源计划ERP</h4><p>enterprise resource plan</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913112546254.png" alt="image-20210913112546254" style="zoom:50%;"></p><p>前身：mrp（物料管理系统</p><p>让企业内部的供应链连通起来</p><p>erp的实施非常困难：原因：1、结构复杂  2、管理思想必须与erp同步 </p><p>erp相当于软件管理：可以在过程执行过程中实现监控功能</p><h4 id="2）客户关系管理CRM"><a href="#2）客户关系管理CRM" class="headerlink" title="2）客户关系管理CRM"></a>2）客户关系管理CRM</h4><p>customer relationship management</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913113054394.png" alt="image-20210913113054394" style="zoom: 50%;"></p><p>维护企业与顾客的关系</p><p>触发中心：顾客咨询时自动触发顾客的信息，从而不必每次都询问</p><p>挖掘中心：向已存在的顾客进行推销，（垃圾短信</p><h4 id="3）供应链管理SCM"><a href="#3）供应链管理SCM" class="headerlink" title="3）供应链管理SCM"></a>3）供应链管理SCM</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913113509321.png" alt="image-20210913113509321" style="zoom:50%;"></p><p>仅仅管理自身是不够的，还要了解整个供应链，从而更好的配合工作</p><h4 id="4）商业智能BI"><a href="#4）商业智能BI" class="headerlink" title="4）商业智能BI"></a>4）商业智能BI</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913113939578.png" alt="image-20210913113939578" style="zoom:50%;"></p><p>商业智能 = 数据仓库 + 数据挖掘</p><p>利用数据仓库和数据挖掘来为<strong>企业决策</strong>作贡献</p><p>需求分析——设计好数据仓库——抽取相关数据填充数据仓库——建立分析报表</p><h4 id="5）电子数据交换EDI"><a href="#5）电子数据交换EDI" class="headerlink" title="5）电子数据交换EDI"></a>5）电子数据交换EDI</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913114255712.png" alt="image-20210913114255712" style="zoom:50%;"></p><p>无纸化办公，用电子化方式来交换数据</p><p>交换数据的标准：EDI标准</p><p>在外贸企业应用广泛</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913114449297.png" alt="image-20210913114449297" style="zoom:50%;"></p><h4 id="6）企业应用集成（常考"><a href="#6）企业应用集成（常考" class="headerlink" title="6）企业应用集成（常考"></a>6）企业应用集成（常考</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913114558284.png" alt="image-20210913114558284" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913163045637.png" alt="image-20210913163045637" style="zoom:50%;"></p><h4 id="7）电子商务"><a href="#7）电子商务" class="headerlink" title="7）电子商务"></a>7）电子商务</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913163218719.png" alt="image-20210913163218719" style="zoom:50%;"></p><p>电子商务四流：信息流、资金流、物流、商流</p><p>电子商务三流：信息流（主要、资金流、物流</p><p>电子商务分类：B2C\C2C\B2B\O2O(线上对线下 在线上购物 线下消费)</p><p>电子商务标准体系分类：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913163456222.png" alt="image-20210913163456222" style="zoom:50%;"></p><h3 id="7、信息系统开发方式"><a href="#7、信息系统开发方式" class="headerlink" title="7、信息系统开发方式"></a>7、信息系统开发方式</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913163549328.png" alt="image-20210913163549328" style="zoom:50%;"></p><h2 id="七、软件工程"><a href="#七、软件工程" class="headerlink" title="七、软件工程"></a>七、软件工程</h2><h3 id="1、软件开发模型"><a href="#1、软件开发模型" class="headerlink" title="1、软件开发模型"></a>1、软件开发模型</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913165149703.png" alt="image-20210913165149703" style="zoom:50%;"></p><h4 id="（1）瀑布模型"><a href="#（1）瀑布模型" class="headerlink" title="（1）瀑布模型"></a>（1）瀑布模型</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913165246207.png" alt="image-20210913165246207" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913165334976.png" style="zoom:50%;"></p><p>结构化模型</p><p>现在基本已经淘汰，因为需求分析阶段是不够完善的，一旦需求变更会导致项目失败</p><p>适合于小型项目或者需求明确的项目</p><h4 id="（2）原型模型、演化模型、增量模型"><a href="#（2）原型模型、演化模型、增量模型" class="headerlink" title="（2）原型模型、演化模型、增量模型"></a>（2）原型模型、演化模型、增量模型</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913165601918.png" alt="image-20210913165601918" style="zoom:50%;"></p><p><strong>原型模型</strong>：先做一个demo给客户看 作为原型</p><p>原型模型演化到最终产品——<strong>演化模型</strong></p><p>螺旋模型+瀑布模型=增量模型</p><p><strong>增量模型</strong>：做出一个模块先使用，合格之后再做下一个模块</p><h4 id="（3）螺旋模型："><a href="#（3）螺旋模型：" class="headerlink" title="（3）螺旋模型："></a>（3）螺旋模型：</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913170043832.png" alt="image-20210913170043832" style="zoom:50%;"></p><p>提供了<u>风险分析</u>，边编写边进行风险分析</p><h4 id="（4）V模型、喷泉模型、RAD模型"><a href="#（4）V模型、喷泉模型、RAD模型" class="headerlink" title="（4）V模型、喷泉模型、RAD模型"></a>（4）V模型、喷泉模型、RAD模型</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913170220403.png" alt="image-20210913170220403" style="zoom:50%;"></p><p>V模型：强调<strong>测试</strong>贯穿整个开发过程，一遍开发一遍测试</p><p>喷泉模型：最大特点是<strong>面向对象</strong></p><p>RAD模型：可以快速的</p><h4 id="（5）构建构建组装模型"><a href="#（5）构建构建组装模型" class="headerlink" title="（5）构建构建组装模型"></a>（5）构建构建组装模型</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913170855168.png" alt="image-20210913170855168" style="zoom:50%;"></p><p>提高代码的复用性</p><h4 id="（6）统一过程"><a href="#（6）统一过程" class="headerlink" title="（6）统一过程"></a>（6）统一过程</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913171456815.png" alt="image-20210913171456815" style="zoom:50%;"></p><h4 id="（7）敏捷开发"><a href="#（7）敏捷开发" class="headerlink" title="（7）敏捷开发"></a>（7）敏捷开发</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913171909597.png" alt="image-20210913171909597" style="zoom:50%;"></p><h3 id="2、逆向工程"><a href="#2、逆向工程" class="headerlink" title="2、逆向工程"></a>2、逆向工程</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210913172831931.png" alt="image-20210913172831931" style="zoom:50%;"></p><h3 id="3、软件测试"><a href="#3、软件测试" class="headerlink" title="3、软件测试"></a>3、软件测试</h3><h4 id="1、测试原则和类型"><a href="#1、测试原则和类型" class="headerlink" title="1、测试原则和类型"></a>1、测试原则和类型</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914230342254.png" alt="image-20210914230342254" style="zoom:50%;"></p><h4 id="2、测试用例设计"><a href="#2、测试用例设计" class="headerlink" title="2、测试用例设计"></a>2、测试用例设计</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914230457425.png" alt="image-20210914230457425" style="zoom:50%;"></p><h4 id="3、测试阶段"><a href="#3、测试阶段" class="headerlink" title="3、测试阶段"></a>3、测试阶段</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914230524845.png" alt="image-20210914230524845" style="zoom:50%;"></p><h4 id="4、面向对象测试"><a href="#4、面向对象测试" class="headerlink" title="4、面向对象测试"></a>4、面向对象测试</h4><p>了解基本概念即可</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914230546172.png" alt="image-20210914230546172" style="zoom:50%;"></p><p>也可以认为模块测试属于单元测试</p><h4 id="5、测试管理"><a href="#5、测试管理" class="headerlink" title="5、测试管理"></a>5、测试管理</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914230740069.png" alt="image-20210914230740069" style="zoom:50%;"></p><p>a1:b1=a2:b2：提前人为植入一些bug，然后看找出来的bug里所含的提前植入bug所占比例，求出debug率</p><p>DRE：测试出来的bug占软件投入使用后产生的总bug（e+d）</p><h4 id="6、软件调试"><a href="#6、软件调试" class="headerlink" title="6、软件调试"></a>6、软件调试</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914231319506.png" alt="image-20210914231319506" style="zoom:50%;"></p><h3 id="4、系统运行与维护"><a href="#4、系统运行与维护" class="headerlink" title="4、系统运行与维护"></a>4、系统运行与维护</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915170543816.png" alt="image-20210915170543816" style="zoom:50%;"></p><h3 id="5、软件能力成熟度模型集成——CMMI"><a href="#5、软件能力成熟度模型集成——CMMI" class="headerlink" title="5、软件能力成熟度模型集成——CMMI"></a>5、软件能力成熟度模型集成——CMMI</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915171123523.png" alt="image-20210915171123523" style="zoom:50%;"></p><h2 id="八、需求工程"><a href="#八、需求工程" class="headerlink" title="八、需求工程"></a>八、需求工程</h2><h3 id="1、面向对象基本概念"><a href="#1、面向对象基本概念" class="headerlink" title="1、面向对象基本概念"></a>1、面向对象基本概念</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914081450972.png" alt="image-20210914081450972" style="zoom:50%;"></p><h3 id="2、UML"><a href="#2、UML" class="headerlink" title="2、UML"></a>2、UML</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914092905232.png" alt="image-20210914092905232" style="zoom:50%;"></p><h4 id="（1）关系"><a href="#（1）关系" class="headerlink" title="（1）关系"></a>（1）关系</h4><p>依赖、关联、泛化、实现</p><h4 id="（2）图"><a href="#（2）图" class="headerlink" title="（2）图"></a>（2）图</h4><p>结构（静态）：类图、对象图、包图、组合结构图、构件图、部署图（软件的构建应该部署在硬件的哪个节点上）、制品图</p><p>——结构图都差不多</p><p>行为（动态）：用例图（有分歧，可以说是动态图也可以说是静态图）、顺序图（强调时间顺序）、通信图（不强调时间顺序）、定时图、状态图、活动图（和流程图很相似）、交互概览图</p><p>——行为图各有特征</p><h3 id="3、需求的分类与需求的获取"><a href="#3、需求的分类与需求的获取" class="headerlink" title="3、需求的分类与需求的获取"></a>3、需求的分类与需求的获取</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914093930729.png" alt="image-20210914093930729" style="zoom:50%;"></p><h4 id="（1）需求分类"><a href="#（1）需求分类" class="headerlink" title="（1）需求分类"></a>（1）需求分类</h4><ul><li><p>系统需求：</p><p>性能需求：非功能需求</p><p>设计约束：与功能、性能无关的需求，例如，项目既可以用c++也可以用java，但客户要求用java语言编写</p></li><li><p>OFD</p><p>基本需求：明确提出的需求；</p><p>期望需求：未说明但期望达到的需求；</p><p>兴奋需求：顾客没有预料到的需求。</p></li></ul><h4 id="（2）需求的获取"><a href="#（2）需求的获取" class="headerlink" title="（2）需求的获取"></a>（2）需求的获取</h4><p>如图</p><h3 id="4、需求分析"><a href="#4、需求分析" class="headerlink" title="4、需求分析"></a>4、需求分析</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914101347118.png" alt="image-20210914101347118" style="zoom:50%;"></p><p>重点是数据流图 and E-R图</p><h4 id="（1）数据流图（DFD）"><a href="#（1）数据流图（DFD）" class="headerlink" title="（1）数据流图（DFD）"></a>（1）数据流图（DFD）</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914101501689.png" alt="image-20210914101501689" style="zoom:50%;"></p><h4 id="（2）E-R图"><a href="#（2）E-R图" class="headerlink" title="（2）E-R图"></a>（2）E-R图</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914102440570.png" alt="image-20210914102440570" style="zoom:50%;"></p><h4 id="（3）数据字典"><a href="#（3）数据字典" class="headerlink" title="（3）数据字典"></a>（3）数据字典</h4><p>定义：数据字典是描述数据的信息的集合，是对系统中使用的所有数据元素/数据流图中包含的所有元素 的定义的集合。是为了描述在结构化分析过程中定义对象的内容时，使用的一种半形式化的工具。</p><p>数据字典的内容：</p><ul><li>数据流：系统中对应的每个数据流都应该在数据字典中做出相应的描述</li><li>数据元素：定义数据元素时需要知名的东西（例如数据类型、数据取值范围…</li><li>数据存储：描述存放的是什么数据</li><li>处理：能够把数据流转变成输出数据流的机制称之为“处理”</li></ul><h2 id="九、系统设计"><a href="#九、系统设计" class="headerlink" title="九、系统设计"></a>九、系统设计</h2><h3 id="1、业务流重组（BPR）与业务流管理（BPM）"><a href="#1、业务流重组（BPR）与业务流管理（BPM）" class="headerlink" title="1、业务流重组（BPR）与业务流管理（BPM）"></a>1、业务流重组（BPR）与业务流管理（BPM）</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914104231530.png" alt="image-20210914104231530" style="zoom:50%;"></p><p>业务流程重组（business process rematch</p><p>变动过大——推出业务流程管理</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914104531382.png" alt="image-20210914104531382" style="zoom:50%;"></p><h3 id="2、人机界面设计"><a href="#2、人机界面设计" class="headerlink" title="2、人机界面设计"></a>2、人机界面设计</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914112657554.png" alt="image-20210914112657554" style="zoom:50%;"></p><h3 id="3、结构化设计"><a href="#3、结构化设计" class="headerlink" title="3、结构化设计"></a>3、结构化设计</h3><p>基本原则：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914224754441.png" alt="image-20210914224754441" style="zoom:50%;"></p><p>扇入（高扇入：被别的模块调用（被调用的多说明用处大</p><p>扇出（低扇出：调用别的模块（调用别的多说明该模块控制的功能很复杂</p><p>模块衡量标准：耦合（低耦合）与内聚（高内聚）</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914225034347.png" alt="image-20210914225034347" style="zoom:50%;"></p><p>系统结构、模块结构</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914225330885.png" alt="image-20210914225330885" style="zoom:50%;"></p><h3 id="4、面向对象设计"><a href="#4、面向对象设计" class="headerlink" title="4、面向对象设计"></a>4、面向对象设计</h3><h4 id="（1）设计原则"><a href="#（1）设计原则" class="headerlink" title="（1）设计原则"></a>（1）设计原则</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914225351301.png" alt="image-20210914225351301" style="zoom:50%;"></p><h4 id="（2）设计模式的概念"><a href="#（2）设计模式的概念" class="headerlink" title="（2）设计模式的概念"></a>（2）设计模式的概念</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914225448483.png" alt="image-20210914225448483" style="zoom:50%;"></p><p>决定整体的框架，从全局看待问题——架构模式</p><p>决定局部的设计，从局部看待问题，但不涉及语言——设计模式</p><p>和语言相关——惯用法</p><h4 id="（3）设计模式的分类"><a href="#（3）设计模式的分类" class="headerlink" title="（3）设计模式的分类"></a>（3）设计模式的分类</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914225717220.png" alt="image-20210914225717220" style="zoom:50%;"></p><p>设计模式分为 创建型模式、结构型模式、行为型模式</p><h5 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914225846560.png" alt="image-20210914225846560" style="zoom:50%;"></p><p>原型模式：也称为克隆模式</p><h5 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914230055477.png" alt="image-20210914230055477" style="zoom:50%;"></p><h5 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210914230125017.png" alt="image-20210914230125017" style="zoom:50%;"></p><h2 id="十、项目管理"><a href="#十、项目管理" class="headerlink" title="十、项目管理"></a>十、项目管理</h2><h3 id="1、范围管理"><a href="#1、范围管理" class="headerlink" title="1、范围管理"></a>1、范围管理</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915172824938.png" alt="image-20210915172824938" style="zoom:50%;"></p><h3 id="2、时间管理"><a href="#2、时间管理" class="headerlink" title="2、时间管理"></a>2、时间管理</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915173121208.png" alt="image-20210915173121208" style="zoom:50%;"></p><p>活动定义：找出活动是什么</p><p>活动排序：找出活动之间的依赖关系</p><p>活动资源、时间估算 </p><p>进度控制</p><h4 id="（1）单代号网络图"><a href="#（1）单代号网络图" class="headerlink" title="（1）单代号网络图"></a>（1）单代号网络图</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915193107876.png" alt="image-20210915193107876" style="zoom:50%;"></p><p>网络图：时间管理计划工具</p><p>单代号网络图：每一个节点代表一个活动</p><p>FS：A完成B才能开始  FF：A完成B才能完成</p><p>SS：A开始B才能开始  SF：A开始B才能结束</p><h4 id="（2）双代号网络图"><a href="#（2）双代号网络图" class="headerlink" title="（2）双代号网络图"></a>（2）双代号网络图</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915193538161.png" alt="image-20210915193538161" style="zoom:50%;"></p><p>双代号网络图：每一个节点代表一个时间，每一条边代表活动</p><p>虚线：代表不占时间，但不能够直接删除，因为它代表了先后顺序的依赖关系</p><h4 id="（3）自由时差"><a href="#（3）自由时差" class="headerlink" title="（3）自由时差"></a>（3）自由时差</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915193730455.png" alt="image-20210915193730455" style="zoom:50%;"></p><h4 id="（4）甘特图"><a href="#（4）甘特图" class="headerlink" title="（4）甘特图"></a>（4）甘特图</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915194055122.png" alt="image-20210915194055122" style="zoom:50%;"></p><p>粗线：代表计划完成时间</p><p>细线：代表实际完成时间</p><h3 id="3、成本管理"><a href="#3、成本管理" class="headerlink" title="3、成本管理"></a>3、成本管理</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915194143757.png" alt="image-20210915194143757" style="zoom:50%;"></p><h4 id="（1）挣值管理"><a href="#（1）挣值管理" class="headerlink" title="（1）挣值管理"></a>（1）挣值管理</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915194303127.png" alt="image-20210915194303127" style="zoom:50%;"></p><h4 id="（2）挣值曲线"><a href="#（2）挣值曲线" class="headerlink" title="（2）挣值曲线"></a>（2）挣值曲线</h4><p>成本超支 进度滞后：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915194401889.png" alt="image-20210915194401889" style="zoom:50%;"></p><h3 id="4、质量管理"><a href="#4、质量管理" class="headerlink" title="4、质量管理"></a>4、质量管理</h3><h4 id="（1）质量模型"><a href="#（1）质量模型" class="headerlink" title="（1）质量模型"></a>（1）质量模型</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915194458334.png" alt="image-20210915194458334" style="zoom:50%;"></p><h4 id="（2）质量管理过程"><a href="#（2）质量管理过程" class="headerlink" title="（2）质量管理过程"></a>（2）质量管理过程</h4><h5 id="PDCA循环"><a href="#PDCA循环" class="headerlink" title="PDCA循环"></a>PDCA循环</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915194547932.png" alt="image-20210915194547932" style="zoom:50%;"></p><h5 id="质量保证和质量控制"><a href="#质量保证和质量控制" class="headerlink" title="质量保证和质量控制"></a>质量保证和质量控制</h5><p>质量保证强调过程</p><p>质量控制强调结果</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915194625361.png" alt="image-20210915194625361" style="zoom:50%;"></p><h4 id="（3）质量管理工具"><a href="#（3）质量管理工具" class="headerlink" title="（3）质量管理工具"></a>（3）质量管理工具</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915194712173.png" alt="image-20210915194712173" style="zoom:50%;"></p><h4 id="（4）项目管理三角形"><a href="#（4）项目管理三角形" class="headerlink" title="（4）项目管理三角形"></a>（4）项目管理三角形</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915194802382.png" alt="image-20210915194802382" style="zoom:50%;"></p><h3 id="5、软件配置管理"><a href="#5、软件配置管理" class="headerlink" title="5、软件配置管理"></a>5、软件配置管理</h3><h4 id="（1）配置项"><a href="#（1）配置项" class="headerlink" title="（1）配置项"></a>（1）配置项</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915194858390.png" alt="image-20210915194858390" style="zoom:50%;"></p><h4 id="（2）配置库"><a href="#（2）配置库" class="headerlink" title="（2）配置库"></a>（2）配置库</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915194929407.png" alt="image-20210915194929407" style="zoom:50%;"></p><h4 id="（3）变更控制"><a href="#（3）变更控制" class="headerlink" title="（3）变更控制"></a>（3）变更控制</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915195008504.png" alt="image-20210915195008504" style="zoom:50%;"></p><h3 id="6、风险管理"><a href="#6、风险管理" class="headerlink" title="6、风险管理"></a>6、风险管理</h3><h4 id="（1）风险的概念"><a href="#（1）风险的概念" class="headerlink" title="（1）风险的概念"></a>（1）风险的概念</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915195052589.png" alt="image-20210915195052589" style="zoom:50%;"></p><h4 id="（2）风险分类"><a href="#（2）风险分类" class="headerlink" title="（2）风险分类"></a>（2）风险分类</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915195132828.png" alt="image-20210915195132828" style="zoom:50%;"></p><h4 id="（3）风险曝光率"><a href="#（3）风险曝光率" class="headerlink" title="（3）风险曝光率"></a>（3）风险曝光率</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915195203821.png" alt="image-20210915195203821" style="zoom:50%;"></p><h3 id="7、项目管理工具"><a href="#7、项目管理工具" class="headerlink" title="7、项目管理工具"></a>7、项目管理工具</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915195239998.png" alt="image-20210915195239998" style="zoom:50%;"></p><h2 id="十一、软件架构设计"><a href="#十一、软件架构设计" class="headerlink" title="十一、软件架构设计"></a>十一、软件架构设计</h2><h3 id="1、软件架构的概念"><a href="#1、软件架构的概念" class="headerlink" title="1、软件架构的概念"></a>1、软件架构的概念</h3><p>架构在需求分析和软件设计之间</p><p>架构就是将识别到的需求划分为不同模块</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915195300573.png" alt="image-20210915195300573" style="zoom:50%;"></p><h3 id="2、软件架构风格"><a href="#2、软件架构风格" class="headerlink" title="2、软件架构风格"></a>2、软件架构风格</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915195817867.png" alt="image-20210915195817867" style="zoom:50%;"></p><h4 id="（1）数据流风格"><a href="#（1）数据流风格" class="headerlink" title="（1）数据流风格"></a>（1）数据流风格</h4><p>整个架构以处理数据流为目的</p><p>批处理序列的架构风格：特点：在处理过程当中，用户不参与</p><p>管道过滤器：结构和批处理一样，但更高级</p><p>两者差别：</p><ul><li>批处理序列所处理的数据必须完整的进入下一环节</li><li>管道过滤器所处理的数据成流状，可以一部分在上一环节，一部分已进入下一环节</li></ul><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210915195907832.png" alt="image-20210915195907832" style="zoom:50%;"></p><h4 id="（2）调用-返回风格"><a href="#（2）调用-返回风格" class="headerlink" title="（2）调用/返回风格"></a>（2）调用/返回风格</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916144400197.png" alt="image-20210916144400197" style="zoom:50%;"></p><h4 id="（3）独立构建风格"><a href="#（3）独立构建风格" class="headerlink" title="（3）独立构建风格"></a>（3）独立构建风格</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916151308725.png" alt="image-20210916151308725" style="zoom:50%;"></p><p>进程通信</p><p>事件驱动系统（重点）</p><h4 id="（4）虚拟机风格"><a href="#（4）虚拟机风格" class="headerlink" title="（4）虚拟机风格"></a>（4）虚拟机风格</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916151449654.png" alt="image-20210916151449654" style="zoom:50%;"></p><h4 id="（5）仓库风格"><a href="#（5）仓库风格" class="headerlink" title="（5）仓库风格"></a>（5）仓库风格</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916151549733.png" alt="image-20210916151549733"></p><p>仓库风格：以数据为中心的风格</p><h4 id="（6）C-S架构"><a href="#（6）C-S架构" class="headerlink" title="（6）C/S架构"></a>（6）C/S架构</h4><p>两层C/S架构：表示层（数据库服务器）、客户层（客户机）</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916151841273.png" alt="image-20210916151841273" style="zoom:50%;"></p><p>三层C/S架构：因为更新换代主要变换的是业务逻辑层，不必每次修改数据层和表示层，所以分为三层。</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916152110313.png" alt="image-20210916152110313" style="zoom:50%;"></p><p>可以部署为俩层，当需要修改时变换为三层</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916152229511.png" alt="image-20210916152229511" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916152328692.png" style="zoom:50%;"></p><h4 id="（7）三层BS架构"><a href="#（7）三层BS架构" class="headerlink" title="（7）三层BS架构"></a>（7）三层BS架构</h4><p>三层C/S架构没有怎么流行就被淘汰</p><p>三层B/S架构开始流行</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916152404351.png" alt="image-20210916152404351" style="zoom:50%;"></p><p>混合架构风格（BS\CS混合使用）</p><p>内部：CS架构，效率高</p><p>外部：BS架构，方便更新换代</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916152810309.png" alt="image-20210916152810309" style="zoom:50%;"></p><h4 id="（8）富互联网应用（RIA）"><a href="#（8）富互联网应用（RIA）" class="headerlink" title="（8）富互联网应用（RIA）"></a>（8）富互联网应用（RIA）</h4><p>结合BS\CS</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916152923122.png" alt="image-20210916152923122" style="zoom:50%;"></p><p>应用最多的是ajax</p><h5 id="ajax：异步JavaScript以及XML"><a href="#ajax：异步JavaScript以及XML" class="headerlink" title="ajax：异步JavaScript以及XML"></a>ajax：异步JavaScript以及XML</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916153231289.png" alt="image-20210916153231289" style="zoom:50%;"></p><h5 id="mushup"><a href="#mushup" class="headerlink" title="mushup"></a>mushup</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916153253250.png" alt="image-20210916153253250" style="zoom:50%;"></p><h4 id="（9）基于服务的架构（SOA）"><a href="#（9）基于服务的架构（SOA）" class="headerlink" title="（9）基于服务的架构（SOA）"></a>（9）基于服务的架构（SOA）</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916153533752.png" alt="image-20210916153533752" style="zoom:50%;"></p><h5 id="1）SOA特点："><a href="#1）SOA特点：" class="headerlink" title="1）SOA特点："></a>1）SOA特点：</h5><p>松耦合、粗粒度、标准化接口</p><p>——&gt;使得很多服务可以复用 </p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916153708729.png" alt="image-20210916153708729" style="zoom:50%;"></p><h5 id="2）SOA实现方式——Web-Service"><a href="#2）SOA实现方式——Web-Service" class="headerlink" title="2）SOA实现方式——Web Service"></a>2）SOA实现方式——Web Service</h5><ul><li>服务注册中心：可以省略；服务请求者、服务提供者必不可少</li><li><strong>静态绑定</strong>：服务请求者、服务提供者直接绑定称之为静态绑定</li><li><strong>动态绑定</strong>：服务请求者、服务提供者之间通过服务注册中心绑定起来称之为动态绑定</li><li>web service强调把各种服务进行相应的封装</li></ul><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916154204007.png" alt="image-20210916154204007" style="zoom:50%;"></p><h5 id="3）SOA实现方式——ESB（企业服务总线）"><a href="#3）SOA实现方式——ESB（企业服务总线）" class="headerlink" title="3）SOA实现方式——ESB（企业服务总线）"></a>3）SOA实现方式——ESB（企业服务总线）</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916154556796.png" alt="image-20210916154556796" style="zoom:50%;"></p><ul><li>ESB强调提供一条总线，把各个服务连接起来（总线的拓扑结构）</li></ul><h3 id="3、软件架构评估"><a href="#3、软件架构评估" class="headerlink" title="3、软件架构评估"></a>3、软件架构评估</h3><h4 id="（1）质量属性"><a href="#（1）质量属性" class="headerlink" title="（1）质量属性"></a>（1）质量属性</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916155148869.png" alt="image-20210916155148869" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916155421182.png" alt="image-20210916155421182" style="zoom:50%;"></p><h4 id="（2）软件架构评估方法"><a href="#（2）软件架构评估方法" class="headerlink" title="（2）软件架构评估方法"></a>（2）软件架构评估方法</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916155629608.png" alt="image-20210916155629608" style="zoom:80%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916160208578.png" style="zoom:50%;"></p><p>基于场景的方式用的最多</p><p>基于场景的方法又分为ATAM/SAAM/CBAM</p><p>ATAM/SAAM用的较多</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916160329427.png" alt="image-20210916160329427" style="zoom:50%;"></p><h5 id="1）ATAM"><a href="#1）ATAM" class="headerlink" title="1）ATAM"></a>1）ATAM</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916160505787.png" alt="image-20210916160505787" style="zoom:50%;"></p><p>描述ATAM方法：由评估小组负责人介绍评估方法（有开发人员参与</p><p>描述业务动机：介绍为什么要做这个业务</p><p>由架构师描述架构，确定一种架构方法</p><p>生成质量属性效用树：由各个小组共同权衡</p><h5 id="2）SAAM"><a href="#2）SAAM" class="headerlink" title="2）SAAM"></a>2）SAAM</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916160928796.png" alt="image-20210916160928796" style="zoom:50%;"></p><p>用SAAM的前提是描述架构</p><p>决定哪些场景更重要</p><p>评估单个场景以及场景组合起来的效果</p><h3 id="4、软件产品线技术"><a href="#4、软件产品线技术" class="headerlink" title="4、软件产品线技术"></a>4、软件产品线技术</h3><h4 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916161106990.png" alt="image-20210916161106990" style="zoom:50%;"></p><h4 id="（2）过程模型"><a href="#（2）过程模型" class="headerlink" title="（2）过程模型"></a>（2）过程模型</h4><h5 id="1）双生命周期模型"><a href="#1）双生命周期模型" class="headerlink" title="1）双生命周期模型"></a>1）双生命周期模型</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916161926403.png" alt="image-20210916161926403" style="zoom:50%;"></p><h5 id="2）SEI模型"><a href="#2）SEI模型" class="headerlink" title="2）SEI模型"></a>2）SEI模型</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916161942273.png" alt="image-20210916161942273" style="zoom:50%;"></p><h5 id="3）三生命周期模型（了解即可"><a href="#3）三生命周期模型（了解即可" class="headerlink" title="3）三生命周期模型（了解即可"></a>3）三生命周期模型（了解即可</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916162028719.png" alt="image-20210916162028719" style="zoom:50%;"></p><h4 id="（3）组织结构"><a href="#（3）组织结构" class="headerlink" title="（3）组织结构"></a>（3）组织结构</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916162051531.png" alt="image-20210916162051531" style="zoom:50%;"></p><h4 id="（4）建立方式（重点）"><a href="#（4）建立方式（重点）" class="headerlink" title="（4）建立方式（重点）"></a>（4）建立方式（重点）</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916162147305.png" alt="image-20210916162147305" style="zoom:50%;"></p><h3 id="5、中间件技术"><a href="#5、中间件技术" class="headerlink" title="5、中间件技术"></a>5、中间件技术</h3><p>把不互联互通的系统连接起来，中间件支持各种不同的系统</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916162258518.png" alt="image-20210916162258518" style="zoom:50%;"></p><p>主要的中间件：</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916162434953.png" alt="image-20210916162434953" style="zoom:50%;"></p><h3 id="6、典型的应用架构"><a href="#6、典型的应用架构" class="headerlink" title="6、典型的应用架构"></a>6、典型的应用架构</h3><h4 id="（1）J2EE——分布式多层应用程序"><a href="#（1）J2EE——分布式多层应用程序" class="headerlink" title="（1）J2EE——分布式多层应用程序"></a>（1）J2EE——分布式多层应用程序</h4><p>J2EE可以分多个层次，支持多层分布式开发应用</p><p>数据层、业务层、web层、客户层</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916162557352.png" alt="image-20210916162557352" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916162736587.png" alt="image-20210916162736587" style="zoom:50%;"></p><h4 id="（2）-NET"><a href="#（2）-NET" class="headerlink" title="（2）.NET"></a>（2）.NET</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916162805491.png" alt="image-20210916162805491" style="zoom:50%;"></p><p>通用语言运行环境——就是一个虚拟机</p><p>执行的时候必须在通用语言运行环境中</p><p>可将不同语言转换为符合通用语言规范的语言</p><h4 id="（3）-NET和J2EE的差别"><a href="#（3）-NET和J2EE的差别" class="headerlink" title="（3）.NET和J2EE的差别"></a>（3）.NET和J2EE的差别</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916162950766.png" alt="image-20210916162950766" style="zoom:50%;"></p><p>相比于J2EE而言，.NET可移植性差，但支持的语言形式更多。其他都差不多</p><h4 id="（4）MVC模式"><a href="#（4）MVC模式" class="headerlink" title="（4）MVC模式"></a>（4）MVC模式</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916163057005.png" alt="image-20210916163057005" style="zoom:50%;"></p><p>MVC的产生：可复用程度高和可复用程度低的模块混杂在一起会使得整体可复用性很差，MVC可使混杂在一起的逻辑分开。</p><p>view：控制输入输出，在视图界面发号指令</p><p>controller：指令到控制层后发送到模型层</p><p>model：模型进行处理，将处理结果送回view</p><p>主动的MVC：model可以给view推送信息</p><p>被动的MVC：model只能等待view来取信息</p><h4 id="（5）J2EE——Java企业应用框架"><a href="#（5）J2EE——Java企业应用框架" class="headerlink" title="（5）J2EE——Java企业应用框架"></a>（5）J2EE——Java企业应用框架</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916163821564.png" alt="image-20210916163821564" style="zoom:50%;"></p><h4 id="（6）MVP模式"><a href="#（6）MVP模式" class="headerlink" title="（6）MVP模式"></a>（6）MVP模式</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916163851702.png" alt="image-20210916163851702" style="zoom:50%;"></p><p>相比于MVC，</p><p>MVP的view和model没有联系起来，controller层变为presenter</p><p>MVP耦合程度更有优势</p><h2 id="十二、系统安全性与保密性设计"><a href="#十二、系统安全性与保密性设计" class="headerlink" title="十二、系统安全性与保密性设计"></a>十二、系统安全性与保密性设计</h2><h3 id="1、信息系统安全属性"><a href="#1、信息系统安全属性" class="headerlink" title="1、信息系统安全属性"></a>1、信息系统安全属性</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210916164315845.png" alt="image-20210916164315845" style="zoom:50%;"></p><h3 id="2、对称加密和非对称加密"><a href="#2、对称加密和非对称加密" class="headerlink" title="2、对称加密和非对称加密"></a>2、对称加密和非对称加密</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152031267.png" alt="image-20210918152031267" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152101519.png" alt="image-20210918152101519" style="zoom:50%;"></p><h3 id="3、信息摘要"><a href="#3、信息摘要" class="headerlink" title="3、信息摘要"></a>3、信息摘要</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152125413.png" alt="image-20210918152125413" style="zoom:50%;"></p><h3 id="4、数字签名"><a href="#4、数字签名" class="headerlink" title="4、数字签名"></a>4、数字签名</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152148407.png" alt="image-20210918152148407" style="zoom:50%;"></p><h3 id="5、数字证书与PGP"><a href="#5、数字证书与PGP" class="headerlink" title="5、数字证书与PGP"></a>5、数字证书与PGP</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152205780.png" alt="image-20210918152205780" style="zoom:50%;"></p><h3 id="6、设计邮件加密系统-实例"><a href="#6、设计邮件加密系统-实例" class="headerlink" title="6、设计邮件加密系统(实例)"></a>6、设计邮件加密系统(实例)</h3><p>略</p><h3 id="7、PKI公钥体系"><a href="#7、PKI公钥体系" class="headerlink" title="7、PKI公钥体系"></a>7、PKI公钥体系</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152241636.png" alt="image-20210918152241636" style="zoom:50%;"></p><h3 id="8、PKI公钥系分层情况"><a href="#8、PKI公钥系分层情况" class="headerlink" title="8、PKI公钥系分层情况"></a>8、PKI公钥系分层情况</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152317394.png" alt="image-20210918152317394" style="zoom:50%;"></p><h3 id="9、信息系统安全保证层次"><a href="#9、信息系统安全保证层次" class="headerlink" title="9、信息系统安全保证层次"></a>9、信息系统安全保证层次</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152340726.png" alt="image-20210918152340726" style="zoom:50%;"></p><h3 id="10、安全审核与安全系统设计原则"><a href="#10、安全审核与安全系统设计原则" class="headerlink" title="10、安全审核与安全系统设计原则"></a>10、安全审核与安全系统设计原则</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152402524.png" alt="image-20210918152402524" style="zoom:50%;"></p><h3 id="11、各个网络层次的安全保障"><a href="#11、各个网络层次的安全保障" class="headerlink" title="11、各个网络层次的安全保障"></a>11、各个网络层次的安全保障</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152422144.png" alt="image-20210918152422144" style="zoom:50%;"></p><h3 id="12、网络威胁与共计"><a href="#12、网络威胁与共计" class="headerlink" title="12、网络威胁与共计"></a>12、网络威胁与共计</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152445835.png" alt="image-20210918152445835" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152511800.png" alt="image-20210918152511800" style="zoom:50%;"></p><h3 id="13、DOS和DDOS共计"><a href="#13、DOS和DDOS共计" class="headerlink" title="13、DOS和DDOS共计"></a>13、DOS和DDOS共计</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152529904.png" alt="image-20210918152529904" style="zoom:50%;"></p><h3 id="14、防火墙技术"><a href="#14、防火墙技术" class="headerlink" title="14、防火墙技术"></a>14、防火墙技术</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152551564.png" alt="image-20210918152551564" style="zoom:50%;"></p><h3 id="15、入侵检测"><a href="#15、入侵检测" class="headerlink" title="15、入侵检测"></a>15、入侵检测</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152609240.png" alt="image-20210918152609240" style="zoom:50%;"></p><h3 id="16、计算机病毒与木马"><a href="#16、计算机病毒与木马" class="headerlink" title="16、计算机病毒与木马"></a>16、计算机病毒与木马</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152629508.png" alt="image-20210918152629508" style="zoom:50%;"></p><h2 id="十三、系统可靠性分析与设计"><a href="#十三、系统可靠性分析与设计" class="headerlink" title="十三、系统可靠性分析与设计"></a>十三、系统可靠性分析与设计</h2><h3 id="1、系统故障模型"><a href="#1、系统故障模型" class="headerlink" title="1、系统故障模型"></a>1、系统故障模型</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152659578.png" alt="image-20210918152659578" style="zoom:50%;"></p><h3 id="2、可靠性指标"><a href="#2、可靠性指标" class="headerlink" title="2、可靠性指标"></a>2、可靠性指标</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152720674.png" alt="image-20210918152720674" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152745171.png" alt="image-20210918152745171" style="zoom:50%;"></p><h3 id="3、串联系统与并联系统可靠度计算"><a href="#3、串联系统与并联系统可靠度计算" class="headerlink" title="3、串联系统与并联系统可靠度计算"></a>3、串联系统与并联系统可靠度计算</h3><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152805927.png" alt="image-20210918152805927" style="zoom:50%;"></p><h3 id="4、系统错技术"><a href="#4、系统错技术" class="headerlink" title="4、系统错技术"></a>4、系统错技术</h3><h4 id="（1）概念与分类"><a href="#（1）概念与分类" class="headerlink" title="（1）概念与分类"></a>（1）概念与分类</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152831074.png" alt="image-20210918152831074" style="zoom:50%;"></p><h4 id="（2）冗余系统"><a href="#（2）冗余系统" class="headerlink" title="（2）冗余系统"></a>（2）冗余系统</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152856286.png" alt="image-20210918152856286" style="zoom:50%;"></p><h4 id="（3）软件容错"><a href="#（3）软件容错" class="headerlink" title="（3）软件容错"></a>（3）软件容错</h4><h5 id="1）N版本程序设计"><a href="#1）N版本程序设计" class="headerlink" title="1）N版本程序设计"></a>1）N版本程序设计</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918152955548.png" alt="image-20210918152955548" style="zoom:50%;"></p><h5 id="2）恢复快方法"><a href="#2）恢复快方法" class="headerlink" title="2）恢复快方法"></a>2）恢复快方法</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918153012608.png" alt="image-20210918153012608" style="zoom:50%;"></p><h5 id="3）防卫式程序设计"><a href="#3）防卫式程序设计" class="headerlink" title="3）防卫式程序设计"></a>3）防卫式程序设计</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210918153036567.png" alt="image-20210918153036567" style="zoom:50%;"></p><h4 id="（4）双机容错"><a href="#（4）双机容错" class="headerlink" title="（4）双机容错"></a>（4）双机容错</h4><p>在核心部位，采取双机配合工作，一台坏了，另一台还可以用</p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210920172112270.png" alt="image-20210920172112270" style="zoom:50%;"></p><h4 id="（5）集群技术"><a href="#（5）集群技术" class="headerlink" title="（5）集群技术"></a>（5）集群技术</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210920172801675.png" alt="image-20210920172801675" style="zoom:50%;"></p><h2 id="十四、法律法规与标准化"><a href="#十四、法律法规与标准化" class="headerlink" title="十四、法律法规与标准化"></a>十四、法律法规与标准化</h2><h3 id="1、法律法规知识"><a href="#1、法律法规知识" class="headerlink" title="1、法律法规知识"></a>1、法律法规知识</h3><h4 id="（1）保护年限"><a href="#（1）保护年限" class="headerlink" title="（1）保护年限"></a>（1）保护年限</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210920173025653.png" alt="image-20210920173025653" style="zoom:50%;"></p><h4 id="（2）知识产权人确定"><a href="#（2）知识产权人确定" class="headerlink" title="（2）知识产权人确定"></a>（2）知识产权人确定</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210920173321974.png" alt="image-20210920173321974" style="zoom:50%;"></p><h4 id="（3）侵权判断"><a href="#（3）侵权判断" class="headerlink" title="（3）侵权判断"></a>（3）侵权判断</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210920173934469.png" alt="image-20210920173934469" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210920174317458.png" alt="image-20210920174317458" style="zoom:50%;"></p><h3 id="2、标准化基础知识"><a href="#2、标准化基础知识" class="headerlink" title="2、标准化基础知识"></a>2、标准化基础知识</h3><h4 id="标准的编号"><a href="#标准的编号" class="headerlink" title="标准的编号"></a>标准的编号</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210920174722255.png" alt="image-20210920174722255" style="zoom:50%;"></p><h2 id="十五、数学与经济管理"><a href="#十五、数学与经济管理" class="headerlink" title="十五、数学与经济管理"></a>十五、数学与经济管理</h2><h3 id="1、图论应用"><a href="#1、图论应用" class="headerlink" title="1、图论应用"></a>1、图论应用</h3><h4 id="网络与最大流量"><a href="#网络与最大流量" class="headerlink" title="网络与最大流量"></a>网络与最大流量</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210920175156721.png" alt="image-20210920175156721" style="zoom:50%;"></p><h3 id="2、运筹方法"><a href="#2、运筹方法" class="headerlink" title="2、运筹方法"></a>2、运筹方法</h3><h4 id="（1）线性规划"><a href="#（1）线性规划" class="headerlink" title="（1）线性规划"></a>（1）线性规划</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210920175238864.png" alt="image-20210920175238864" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210920175526818.png" style="zoom:50%;"></p><h4 id="（2）决策"><a href="#（2）决策" class="headerlink" title="（2）决策"></a>（2）决策</h4><h5 id="1）不确定型决策"><a href="#1）不确定型决策" class="headerlink" title="1）不确定型决策"></a>1）不确定型决策</h5><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210920175919495.png" style="zoom:50%;"></p><p><img src="/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210920180147276.png" alt="image-20210920180147276" style="zoom:50%;"></p><ul><li><p>乐观主义准则：大中取大</p><p>整个表中的最大值：500</p></li><li><p>悲观主义准则：小中取大</p><p>整个表中最差情况的最大收益：200</p></li><li><p>折中主义准则：取系数α</p><p>α取0——悲观主义准则</p><p>α取1——乐观主义准则</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;系统架构设计师上午题&quot;&gt;&lt;a href=&quot;#系统架构设计师上午题&quot; class=&quot;headerlink&quot; title=&quot;系统架构设计师上午题&quot;&gt;&lt;/a&gt;系统架构设计师上午题&lt;/h1&gt;&lt;p&gt;转载自www.educity.cn&lt;/p&gt;
&lt;p&gt;上午知识点总结：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98/image-20210908134924552.png&quot; alt=&quot;image-20210908134924552&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="软考" scheme="https://laylaycjl.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="软考高级" scheme="https://laylaycjl.github.io/tags/%E8%BD%AF%E8%80%83%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师上午题知识点总结</title>
    <link href="https://laylaycjl.github.io/2021/06/11/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://laylaycjl.github.io/2021/06/11/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-11T03:45:26.000Z</published>
    <updated>2021-09-08T05:47:35.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件设计师知识点100条"><a href="#软件设计师知识点100条" class="headerlink" title="软件设计师知识点100条"></a>软件设计师知识点100条</h1><p>转载自 希赛网</p><p>原网址：<a href="https://www.educity.cn/rk/2213375.html">https://www.educity.cn/rk/2213375.html</a></p><h2 id="1、码制的表示"><a href="#1、码制的表示" class="headerlink" title="1、码制的表示"></a>1、码制的表示</h2><p><strong>定点整数</strong></p><p>原码与反码的0既有+0也有-0，数码的表示个数为2n-1个。补码与移码有人为定义，-0编码定义为最小数值-1，数码的表示个数为2n个，最小表示数值为2n-1。</p><p><strong>定点小数</strong></p><p>数码的表示个数与定点整数一致。补码与移码的人为定义，将-0的编码定义为最小数值-1。</p><span id="more"></span><h2 id="2、浮点数的表示"><a href="#2、浮点数的表示" class="headerlink" title="2、浮点数的表示"></a>2、浮点数的表示</h2><p><strong>浮点数格式</strong></p><p>阶码决定范围，阶码越长，范围越大；</p><p>尾数决定精度，尾数越长，精度越高。</p><p><strong>浮点数运算过程</strong></p><p>对阶→尾数计算→格式化；</p><p>对阶：小数像大数看齐，尾数右移。</p><h2 id="3、校验码"><a href="#3、校验码" class="headerlink" title="3、校验码"></a>3、校验码</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/7euR5nFNzR.png" alt="1.png"></p><h2 id="4、CPU组成"><a href="#4、CPU组成" class="headerlink" title="4、CPU组成"></a>4、CPU组成</h2><p>CPU分为运算器与控制器两大部分。</p><p><strong>运算器</strong></p><p>算术逻辑单元ALU：执行算术运算和逻辑运算。</p><p>累加寄存器AC：暂存数据，为ALU提供工作区。</p><p>数据缓冲寄存器DR</p><p>状态条件寄存器PSW归属有争议</p><p><strong>控制器</strong></p><p>指令计数器PC：存储下一条要执行指令的地址</p><p>指令寄存器IR：存储即将执行的指令</p><p>指令译码器ID</p><p>时序部件</p><h2 id="5、CISC与RISC"><a href="#5、CISC与RISC" class="headerlink" title="5、CISC与RISC"></a>5、CISC与RISC</h2><p>CISC（复杂指令集）的特点：指令数量多，指令频率差别大，变长，多种寻址方式，使用微码（微程序）实现。</p><p>RISC（精简指令集）的特点：指令数量少，频率接近，定长，单周期，多寄存器寻址，多通用寄存器，硬布线逻辑控制，适用于流水线。有效支持高级程序语言，优化编译。</p><h2 id="6、流水线技术"><a href="#6、流水线技术" class="headerlink" title="6、流水线技术"></a>6、流水线技术</h2><p>流水线建立时间：第1条指令执行时间</p><p>流水线周期：指令分段后，最长段时间</p><p>流水线执行时间（默认使用理论公式，无答案时考虑实践公式）</p><p>理论公式：流水线建立时间+（指令条数-1）*流水线周期</p><p>实践公式：指令段数<em>流水线周期+（指令条数-1）</em>流水线周期</p><p>吞吐率=指令条数/流水线执行时间</p><p>最大吞吐率=流水线周期的倒数。</p><h2 id="7、局部性原理"><a href="#7、局部性原理" class="headerlink" title="7、局部性原理"></a>7、局部性原理</h2><p>时间局部性：指程序中的某条指令一旦执行，不久以后该指令可能再次执行，典型原因是由于程序中存在着大量的循环操作。</p><p>空间局部性：指一旦程序访问了某个存储单元，不久以后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型情况是程序顺序执行。</p><h2 id="8、常见存储器"><a href="#8、常见存储器" class="headerlink" title="8、常见存储器"></a>8、常见存储器</h2><p><strong>按内容存取</strong></p><p>相联存储器（如Cache）</p><p><strong>按地址存取</strong></p><p>随机存取存储器（如内存）</p><p>顺序存取存储器（如磁带）</p><p>直接存取存储器（如磁盘）</p><p><strong>工作方式</strong></p><p>随机存取存储器RAM（如内存DRAM）</p><p>只读存储器ROM（如BIOS）</p><h2 id="9、Cache"><a href="#9、Cache" class="headerlink" title="9、Cache"></a>9、Cache</h2><p>在计算机的存储系统体系中，Cache是（除寄存器以外）访问速度最快的层次。解决CPU与主存之间速度容量不匹配问题。</p><p>Cache与主存映射三种方式：</p><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/QcpKWs5SvX.png" alt="1.png"></p><h2 id="10、主存编址计算"><a href="#10、主存编址计算" class="headerlink" title="10、主存编址计算"></a>10、主存编址计算</h2><p>内存单元数个数=最大地址+1-最小地址</p><p>内存编址内容：</p><p>按字编址（每个存储单元存放内容为机器字长—题干定义）</p><p>按字节编址（每个存储单元内容为1字节即8bit）</p><p>内存总容量=内存单元数*编址内容</p><p>总容量=单位芯片容量*总片数</p><p>总片数=总容量/单位容量；</p><p>单位芯片容量=总容量/芯片片数。</p><h2 id="11、输入输出技术"><a href="#11、输入输出技术" class="headerlink" title="11、输入输出技术"></a>11、输入输出技术</h2><p><strong>程序控制（查询）方式</strong>：分为无条件传送和程序查询方式。方法简单，硬件开销小，但I/O能力不高，严重影响CPU的利用率。</p><p><strong>程序中断方式</strong>：与程序控制方式相比，中断方式因为CPU无需等待而提高了传输请求的响应速度。</p><p><strong>DMA方式</strong>：DMA方式是为了在主存与外设之间实现高速、批量数据交换而设置的。DMA方式比程序控制方式与中断方式都高效。</p><h2 id="12、中断"><a href="#12、中断" class="headerlink" title="12、中断"></a>12、中断</h2><p><strong>中断处理</strong>（CPU无需等待也不必查询I/O状态）：</p><p>当I/O系统准备好以后，发出中断请求信号通知CPU；</p><p>CPU接到中断请求后，保存正在执行程序的现场（保存现场），打断的程序当前位置即为断点；</p><p>（通过中断向量表-保存中断服务程序的入口地址）</p><p>转入I/O中的服务程序的执行，完成I/O系统的数据交换；</p><p>返回被打断的程序继续执行（恢复现场）。</p><h2 id="13、可靠性"><a href="#13、可靠性" class="headerlink" title="13、可靠性"></a>13、可靠性</h2><p>串联系统计算：R总=R1<em>R2</em>…*Rn;</p><p>并联系统计算：R总=1-(1-R1)(1-R2)…(1-Rn)；</p><p>N模混联系统：先将整个系统划分为多个部分串联R1、R2…等，再计算R1、R2内部的并联可靠性，带入原公式。</p><p>可靠性表示：MTTF/(1+MTTF)</p><h2 id="14、操作系统位置和功能"><a href="#14、操作系统位置和功能" class="headerlink" title="14、操作系统位置和功能"></a>14、操作系统位置和功能</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/QY5uqEGwUM.png" alt="1.png"></p><p>管理系统的硬件、软件、数据资源</p><p>控制程序运行</p><p>人机之间的接口</p><p>应用软件与硬件之间的接口</p><h2 id="15、嵌入式操作系统"><a href="#15、嵌入式操作系统" class="headerlink" title="15、嵌入式操作系统"></a>15、嵌入式操作系统</h2><p>特点：微型化、可定制（针对硬件变化配置）、实时性、可靠性、易移植性(硬件抽象层HAL和板级支撑包BSP支持)</p><p>初始化过程：片级初始化→板级初始化→系统初始化</p><h2 id="16、线程"><a href="#16、线程" class="headerlink" title="16、线程"></a>16、线程</h2><p>同一个进程当中的各个线程，可以共享该进程的各种资源，如内存地址空间、代码、数据、文件等，线程之间的通信与交流非常方便。</p><p>对于同一个进程当中的各个线程来说， 他们可以共享该进程的大部分资源。每个线程都有自己独立的CPU运行上下文和栈，这是不能共享的。</p><p>（程序计数器、寄存器和栈不能共享）</p><h2 id="17、PV操作"><a href="#17、PV操作" class="headerlink" title="17、PV操作"></a>17、PV操作</h2><p>P操作：S=S-1(申请并锁定资源)；S&lt;0(检查资源是否足够)</p><p>V操作：S=S+1(释放资源)；S&lt;=0(检查是否有进程排队并通知排队进程)</p><p>S信号量：表示资源数，初值即为初始状态无操作时，资源的数量；信号量小于0的时候，还可以表示排队的进程数量。</p><h2 id="18、前趋图与PV操作分析题技巧"><a href="#18、前趋图与PV操作分析题技巧" class="headerlink" title="18、前趋图与PV操作分析题技巧"></a>18、前趋图与PV操作分析题技巧</h2><p>针对箭线标注信号量，箭线的起点位置是V操作（即前趋活动完成后以V操作通知后继活动）；箭线的终点位置是P操作（即后继活动开始前以P操作检查前趋活动是否完成）。</p><h2 id="19、死锁"><a href="#19、死锁" class="headerlink" title="19、死锁"></a>19、死锁</h2><p>死锁四大条件：互斥、保持和等待、不剥夺、环路等待。</p><p>假设m个进程各自需要w个R资源，系统中共有n个R资源，此时不可能形成死锁的条件是：m*(w-1)+1&lt;=n。</p><h2 id="20、页式存储的淘汰原则"><a href="#20、页式存储的淘汰原则" class="headerlink" title="20、页式存储的淘汰原则"></a>20、页式存储的淘汰原则</h2><p>页面淘汰时，主要依据原则（考试中默认按照此原则进行淘汰）：先淘汰最近未被访问的（访问位为0），其次多个页面访问位为0时，则淘汰未被修改的（即修改位为0，因为修改后的页面淘汰时代价更大）。</p><h2 id="21、树形目录结构-多级目录结构"><a href="#21、树形目录结构-多级目录结构" class="headerlink" title="21、树形目录结构(多级目录结构)"></a>21、树形目录结构(多级目录结构)</h2><p>绝对路径从根目录开始写起，并且该文件的全名即为绝对路径+文件名。</p><p>相对路径从当前位置下一级目录开始写起。</p><h2 id="22、I-O管理软件"><a href="#22、I-O管理软件" class="headerlink" title="22、I/O管理软件"></a>22、I/O管理软件</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/5wy2ee9HwQ.png" alt="1.png"></p><p>硬件：完成具体的I/O操作。</p><p>中断处理程序：I/O完成后唤醒设备驱动程序</p><p>设备驱动程序：设置寄存器，检查设备状态</p><p>设备无关I/O层：设备名解析、阻塞进程、分配缓冲区</p><p>用户级I/O层：发出I/O调用。</p><h2 id="23、分布式透明性"><a href="#23、分布式透明性" class="headerlink" title="23、分布式透明性"></a>23、分布式透明性</h2><p>分片透明：用户不必关心数据是如何分片的即如何分片对用户是透明的。</p><p>复制透明：用户不用关心数据库在网络中各个结点的复制情况，被复制的数据的更新由系统自动完成。</p><p>位置透明：用户不必知道所操作的数据放在何处，即数据分配到哪个或哪些站点存储对用户是透明的。</p><p>局部映像透明性（逻辑透明）：用户不必知道局部数据库模式。</p><h2 id="24、数据库三级模式两级映像"><a href="#24、数据库三级模式两级映像" class="headerlink" title="24、数据库三级模式两级映像"></a>24、数据库三级模式两级映像</h2><p>外模式-视图；模式-基本表；内模式-文件。</p><p>外模式-模式映射，保证<strong>数据逻辑独立性</strong>，即数据的逻辑结构发生变化后，用户程序也可以不修改。只需要修改外模式和概念模式之间的映像。</p><p>模式-内模式映射，保证<strong>数据物理独立性</strong>，即当数据的物理结构发生改变时，应用程序不用改变。只需要修改概念模式和内模式之间的映像。</p><h2 id="25、数据库设计过程"><a href="#25、数据库设计过程" class="headerlink" title="25、数据库设计过程"></a>25、数据库设计过程</h2><p>需求分析阶段产物：数据流图、数据字典、需求说明书。</p><p>概念设计阶段产物：E-R模型。</p><p>逻辑设计阶段产物：关系模式。设计依据：需求分析、E-R模型、转换原则、规范化理论。</p><h2 id="26、关系模式基本概念"><a href="#26、关系模式基本概念" class="headerlink" title="26、关系模式基本概念"></a>26、关系模式基本概念</h2><p>属性</p><p>简单属性和复合属性：</p><p>简单属性是原子的，不可再分的；</p><p>复合属性可以细分为更小的部分（即划分为别的属性）。</p><p>单值属性和多值属性：</p><p>定义的属性对于一个</p><p>特定的实体都只有单独的一个值，称为单值属性；</p><p>在某些特定情况下，一个属性可能对应一组值，称为多值属性。</p><p>NULL属性：表示无意义或不知道。</p><p>派生属性：可以从其他属性得来。</p><p>目或度：关系模式中属性的个数。</p><p>候选码（候选键）：唯一标示元组的属性集合，可以有多个。</p><p>主码（主键）：从候选键选择一个。</p><p>主属性与非主属性：组成候选码的属性就是主属性，其它的就是非主属性。</p><p>外码（外键）：其他关系模式的主键。</p><p>全码（ALL-Key）：关系模式的所有属性组是这个关系的候选码。</p><h2 id="27、候选键"><a href="#27、候选键" class="headerlink" title="27、候选键"></a>27、候选键</h2><p>选择入度为0（无函数依赖可推导得出的属性入度为0）的属性集合，从该集合尝试推导出全部属性（可通过传递函数依赖等进行传递推导），如果可以，该集合为候选键，否则，该集合依次添加既有入度也有出度（既可被推导得出也可推导出其他属性）的中间结点，直到推导出所有属性为止，最终集合即为候选键。</p><h2 id="28、E-R图转关系模式转换原则"><a href="#28、E-R图转关系模式转换原则" class="headerlink" title="28、E-R图转关系模式转换原则"></a>28、E-R图转关系模式转换原则</h2><p>实体必须单独转换为1个关系模式。</p><p>联系根据类型不同：</p><p>1对1联系可以转换为独立的关系模式，也可以归并到任意一端实体中。</p><p>1对多联系可以转换为独立的关系模式，也可以归并到多端实体中。</p><p>多对多联系只能转换为独立的关系模式，不能归并。</p><h2 id="29、关系代数"><a href="#29、关系代数" class="headerlink" title="29、关系代数"></a>29、关系代数</h2><p>笛卡尔积×：结果的属性列数是二者之和，结果的元组行数是二者乘积。</p><p>投影π：对垂直方向的属性列进行筛选。</p><p>选择σ：对水平方向的元组行进行筛选。</p><p>自然连接⋈：结果的属性列数是二者之和减去重复列数，结果元组是同名属性列取值相等的元组。</p><h2 id="30、Amstrong公理体系"><a href="#30、Amstrong公理体系" class="headerlink" title="30、Amstrong公理体系"></a>30、Amstrong公理体系</h2><p>A1.自反律（Reflexivity）：若Y⊆X⊆U，则X →Y成立。</p><p>A2.增广律（Augmentation）：若Z⊆U且X→Y，则XZ→YZ成立。</p><p>A3.传递律（Transitivity）：若X→Y且Y→Z，则X→Z成立。</p><p>合并规则：由X→Y，X→Z，有X→YZ。 （A2， A3）</p><p>伪传递规则：由X→Y，WY→Z，有XW→Z。 （A2， A3）</p><p>分解规则：由X→Y及 Z ⊆ Y，有X→Z。 （A1， A3）</p><h2 id="31、规范化程度判断即范式判定依据"><a href="#31、规范化程度判断即范式判定依据" class="headerlink" title="31、规范化程度判断即范式判定依据"></a>31、规范化程度判断即范式判定依据</h2><p>1NF：属性值都是不可分的原子值。（基本二维表）</p><p>2NF：在1NF基础上，消除了非主属性对候选键的部分函数依赖。（候选键是单属性至少满足2NF）</p><p>3NF：在2NF基础上，消除了非主属性对候选键的传递函数依赖。（没有非主属性至少满足3NF）</p><p>BCNF：在3NF基础上，消除了主属性对候选键的部分函数依赖和传递函数依赖。</p><h2 id="32、查询"><a href="#32、查询" class="headerlink" title="32、查询"></a>32、查询</h2><p>SELECT [ALL|DISTINCT] &lt;目标表达式&gt; [， &lt;目标表达式&gt;]…</p><p>FROM &lt;表名&gt; [，&lt;表名&gt;]…</p><p>[WHERE &lt;条件表达式&gt;]</p><p>[GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt; ] ]</p><p>[ORDER BY &lt;列名2&gt; [ASC|DESC ] … ]；</p><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/z4wPSVV2nq.png" alt="1.png"></p><h2 id="33、事务特性（ACID）"><a href="#33、事务特性（ACID）" class="headerlink" title="33、事务特性（ACID）"></a>33、事务特性（ACID）</h2><p><strong>原子性A</strong>：事务是原子的，要么都做，要么都不做。</p><p><strong>一致性C</strong>：事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性的状态。</p><p><strong>隔离性I</strong>：事务相互隔离，当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的。</p><p><strong>持续性D：</strong>一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效。</p><h2 id="34、封锁协议"><a href="#34、封锁协议" class="headerlink" title="34、封锁协议"></a>34、封锁协议</h2><p><strong>共享锁</strong>（S锁、读锁）：若事务T对数据对象A添加了S锁，则只允许T读取A，但不能修改A。并且其他事务只能对A加S锁，不能加X锁。</p><p><strong>排他锁</strong>（X锁、写锁、独占锁）：若事务T对数据对象A添加了X锁，则只允许T读取和修改A，其他事务不能再对A加任何锁。</p><h2 id="35、OSI七层模型"><a href="#35、OSI七层模型" class="headerlink" title="35、OSI七层模型"></a>35、OSI七层模型</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/m5cYgn56G7.png" alt="1.png"></p><h2 id="36、TCP-IP协议簇四层模型"><a href="#36、TCP-IP协议簇四层模型" class="headerlink" title="36、TCP/IP协议簇四层模型"></a>36、TCP/IP协议簇四层模型</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/fZfu4dfcxa.png" alt="1.png"></p><h2 id="37、常见协议功能"><a href="#37、常见协议功能" class="headerlink" title="37、常见协议功能"></a>37、常见协议功能</h2><p>POP3：邮件收取</p><p>SMTP：邮件发送</p><p>FTP：20数据端口/21控制端口，文件传输协议</p><p>HTTP：超文本传输协议，网页传输</p><p>DHCP： IP地址自动分配</p><p>SNMP：简单网络管理协议</p><p>DNS：域名解析协议，记录域名与IP的映射关系</p><p>TCP：可靠的传输层协议</p><p>UDP：不可靠的传输层协议</p><p>ICMP：因特网控制协议，PING命令来自该协议</p><p>IGMP：组播协议</p><p>ARP：地址解析协议，IP地址转换为MAC地址</p><p>RARP：反向地址解析协议，MAC地址转IP地址</p><h2 id="38、常见网络诊断命令"><a href="#38、常见网络诊断命令" class="headerlink" title="38、常见网络诊断命令"></a>38、常见网络诊断命令</h2><p>ping：用于检查网络是否连通；</p><p>tracert（linux: traceroute）：用于确定 IP数据包访问目标所采取的路径，若网络不通，能定位到具体哪个结点不通；</p><p>ipconfig （ linux: ifconfig）：显示TCP/IP网络配置值，如：IP地址，MAC地址，网关地址等；</p><p>nslookup：查询DNS记录；</p><p>Netstat：用于显示网络连接、路由表和网络接口信息。</p><h2 id="39、特殊的IP地址"><a href="#39、特殊的IP地址" class="headerlink" title="39、特殊的IP地址"></a>39、特殊的IP地址</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/N52Wnvd28x.png" alt="1.png"></p><h2 id="40、层次化网络"><a href="#40、层次化网络" class="headerlink" title="40、层次化网络"></a>40、层次化网络</h2><p>核心层：主要是高速数据交换，实现高速数据传输、出口路由，常用冗余机制。</p><p>接入层：主要是针对用户端，实现用户接入、计费管理、MAC地址认证、MAC地址过滤、收集用户信息，可以使用集线器代替交换机。</p><p>汇聚层 ：网络访问策略控制、数据包处理和过滤、策略路由、广播域定义 、寻址。</p><h2 id="41、URL"><a href="#41、URL" class="headerlink" title="41、URL"></a>41、URL</h2><p>URL：协议名://主机名.组名.最高层域名</p><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/s6yyaQGqRL.png" alt="1.png"></p><h2 id="42、加密算法"><a href="#42、加密算法" class="headerlink" title="42、加密算法"></a>42、加密算法</h2><p>常见对称密钥加密算法（共享密钥加密技术）：DES、 3DES(三重DES)、 RC-5、IDEA、AES算法。</p><p>常见非对称密钥加密算法（公开密钥加密技术）： RSA、ECC</p><p>常见的摘要算法：MD5(128位)，SHA(160位)。</p><h2 id="43、加密技术应用"><a href="#43、加密技术应用" class="headerlink" title="43、加密技术应用"></a>43、加密技术应用</h2><p><strong>数字信封</strong>：用接收方公钥加密使用的对称密钥。</p><p><strong>数字签名</strong>：用发送方私钥签名，保证发送方身份真实性，发送者不可抵赖。与信息摘要结合，可防篡改。</p><p><strong>信息摘要</strong>：单向散列值函数，防篡改，保证消息完整性。</p><p><strong>数字证书</strong></p><p>数字证书的内容包括：CA签名、用户信息（用户名称）、用户公钥等。</p><p>证书中的CA签名验证数字证书的可靠性、验证网站真伪。</p><p><strong>用户公钥</strong>：客户端利用证书中的公钥加密，服务器利用自己的私钥解密。</p><h2 id="44、网络安全协议分层"><a href="#44、网络安全协议分层" class="headerlink" title="44、网络安全协议分层"></a>44、网络安全协议分层</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/gvXAVVvmu0.png" alt="1.png"></p><p>HTTPS协议是HTTP协议与SSL协议的结合，默认端口号443。</p><p>PGP协议是邮件安全协议。</p><p>SET协议是电子商务安全协议，涉及电子交易安全。</p><p>SSH：为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。</p><h2 id="45、网络攻击"><a href="#45、网络攻击" class="headerlink" title="45、网络攻击"></a>45、网络攻击</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/GCxxGjVRT0.png" alt="1.png"></p><h2 id="46、网络防御"><a href="#46、网络防御" class="headerlink" title="46、网络防御"></a>46、网络防御</h2><p><strong>防火墙技术</strong>：防外不防内，对于DMZ非军事区主要放置应用服务器（如邮件服务器，WEB服务器）。</p><p><strong>漏洞扫描</strong>：入侵者可以利用系统漏洞侵入系统，系统管理员可以通过漏洞扫描技术，及时了解系统存在的安全问题，并采取相应措施来提高系统的安全性。</p><p><strong>入侵检测IDS</strong>：根据攻击者行为和模式库记录的行为进行模式匹配，对攻击行为报警。</p><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/z3XQRa8xaE.png" alt="1.png"></p><h2 id="47、病毒"><a href="#47、病毒" class="headerlink" title="47、病毒"></a>47、病毒</h2><p><strong>病毒的特性</strong>：计算机病毒的特性包括隐蔽性、传染性、潜伏性、触发性和破坏性等</p><p><strong>分类</strong>：</p><p>文件型计算机病毒感染可执行文件（包括EXE和COM文件）。</p><p>引导型计算机病毒影响软盘或硬盘的引导扇区。</p><p>目录型计算机病毒能够修改硬盘上存储的所有文件的地址。</p><p>宏病毒感染的对象是使用某些程序创建的文本文档、数据库、电子表格等文件。</p><h2 id="48、常见的软件开发模型"><a href="#48、常见的软件开发模型" class="headerlink" title="48、常见的软件开发模型"></a>48、常见的软件开发模型</h2><p><strong>瀑布模型</strong></p><p>容易理解，管理成本低，每个阶段都有对应的成果产物，各个阶段有明显的界限划分和顺序要求，一旦发生错误，整个项目推倒重新开始。</p><p>适用于需求明确的项目，一般表述为需求明确、或二次开发，或者对于数据处理类型的项目</p><p><strong>V模型</strong></p><p>强调测试贯穿项目始终，而不是集中在测试阶段。是一种测试的开发模型。</p><p><strong>喷泉模型</strong></p><p>以用户需求为动力，以对象为驱动，适合于面向对象的开发方法。</p><p>特点是迭代、无间隙。</p><p><strong>原型模型</strong></p><p>典型的原型开发方法模型。适用于需求不明确的场景，可以帮助用户明确需求。</p><p><strong>增量模型</strong></p><p>可以有多个可用版本的发布，核心功能往往最先完成，在此基础上，每轮迭代会有新的增量发布，核心功能可以得到充分测试。强调每一个增量均发布一个可操作的产品。</p><h2 id="49、螺旋模型与RUP"><a href="#49、螺旋模型与RUP" class="headerlink" title="49、螺旋模型与RUP"></a>49、螺旋模型与RUP</h2><p><strong>螺旋模型</strong></p><p>典型特点是引入了风险分析。结合了瀑布模型和演化模型的优点，最主要的特点在于加入了风险分析。它是由制定计划、风险分析、实施工程、客户评估这一循环组成的，它最初从概念项目开始第一个螺旋。</p><p><strong>统一过程RUP</strong></p><p>典型特点：用例驱动、以架构为中心、迭代和增量。</p><p>构思阶段</p><p>强调定义和细化用例，并将其作为主要模型。</p><p>细化阶段</p><p>重点是创建分析和设计模型，强调类的定义和体系结构的表示。确定系统架构。</p><p>构建阶段</p><p>将设计转化为实现，并进行集成和测试。</p><p>移交阶段</p><p>将产品发布给用户进行测试评价，交付或再次进行迭代修改产品使之完善。</p><h2 id="50、敏捷方法"><a href="#50、敏捷方法" class="headerlink" title="50、敏捷方法"></a>50、敏捷方法</h2><p>敏捷开发是一种以人为核心、迭代、循序渐进的开发方法，适用于小团队和小项目，具有小步快跑的思想。</p><p>水晶法强调经常交付，认为每一种不同的项目都需要一套不同的策略、约定和方法论。</p><p>并列争球法的核心是迭代、增量交付，按照30天进行迭代开发交付可实际运行的软件。</p><p>自适应软件开发的核心是三个非线性的，重叠的开发阶段：猜测、合作、学习。</p><h2 id="51、极限编程"><a href="#51、极限编程" class="headerlink" title="51、极限编程"></a>51、极限编程</h2><p>极限编程是一种轻量级的开发方法。</p><p>它提出了<strong>四大价值观</strong>：沟通、简单、反馈、勇气。</p><p><strong>五大原则</strong>：快速反馈、简单性假设、逐步修改、提倡更改、优质工作。</p><p><strong>十二个最佳实践</strong>：计划游戏、隐喻、小型发布、简单设计、测试先行、重构、结对编程、集体代码所有制、持续集成、每周工作40小时、现场客户和编码标准。</p><h2 id="52、开发方法"><a href="#52、开发方法" class="headerlink" title="52、开发方法"></a>52、开发方法</h2><p><strong>结构化开发方法</strong>：用户至上，严格区分工作阶段，每阶段有任务和结果，强调系统开发过程的整体性和全局性，系统开发过程工程化，文档资料标准化，自顶向下，逐步求精。</p><p><strong>原型开发方法</strong>：适用于需求不明确的情况。</p><p><strong>面向对象开发方法</strong>：更好的复用性，关键在于建立一个全面、合理、统一的模型，分析、设计、实现三个阶段界限不明确。</p><h2 id="53、内聚性"><a href="#53、内聚性" class="headerlink" title="53、内聚性"></a>53、内聚性</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/zxe987ZJ6P.png" alt="1.png"></p><h2 id="54、耦合性"><a href="#54、耦合性" class="headerlink" title="54、耦合性"></a>54、耦合性</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/MdXvdWgv3w.png" alt="1.png"></p><h2 id="55、测试分类"><a href="#55、测试分类" class="headerlink" title="55、测试分类"></a>55、测试分类</h2><p>静态测试</p><p>桌前检查、代码走查、代码审查。</p><p>动态测试</p><p>黑盒测试</p><p>等价类划分(确定无效与有效等价类，设计用例尽可能多的覆盖有效类，设计用例只覆盖一个无效类)</p><p>边界值分析(处理边界情况时最容易出错，选取的测试数据应该恰好等于、稍小于或稍大于边界值)</p><p>错误推测</p><p>因果图</p><p>白盒测试：语句覆盖、判定覆盖、条件覆盖、条件/判定覆盖、路径覆盖。</p><h2 id="56、白盒测试"><a href="#56、白盒测试" class="headerlink" title="56、白盒测试"></a>56、白盒测试</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/mjCsh7eKMw.png" alt="1.png"></p><h2 id="57、特殊的测试阶段及任务"><a href="#57、特殊的测试阶段及任务" class="headerlink" title="57、特殊的测试阶段及任务"></a>57、特殊的测试阶段及任务</h2><p>验收测试：有效性测试、软件配置审查、验收测试。</p><p>系统测试：恢复测试、安全性测试、强度测试、性能测试、可靠性测试和安装测试。</p><p>集成测试：模块间的接口和通信。</p><p>单元测试：模块接口、局部数据结构、边界条件、独立的路径、错误处理。</p><p>回归测试：修改软件后进行的测试，防止引入新的错误。</p><p>负载测试：对软件负载能力的测试。</p><p>压力测试：对软件超负荷条件下运行情况的测试。</p><h2 id="58、McCabe复杂度计算"><a href="#58、McCabe复杂度计算" class="headerlink" title="58、McCabe复杂度计算"></a>58、McCabe复杂度计算</h2><p>McCabe复杂度计算公式：V(G)=m-n+2，其中m是有向弧的条数，n是结点数。</p><p>对于伪代码可以先转换为程序流程图，对程序流程图可以最终转换为结点图处理，转换时注意将交点的地方标注为新的结点，以最终的结点图带入公式结算其McCabe复杂度。</p><h2 id="59、维护"><a href="#59、维护" class="headerlink" title="59、维护"></a>59、维护</h2><p>更正性维护：针对真实存在并已经发生的错误进行的维护行为。</p><p>预防性维护：针对真实存在但还未发生的错误进行的维护。</p><p>适应性维护：指使应用软件适应信息技术变化和管理需求变化而进行的修改。企业的外部市场环境和管理需求的不断变化也使得各级管理人员不断提出新的信息需求。</p><p>完善性维护：扩充功能和改善性能而进行的修改。对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。</p><h2 id="60、质量属性与其依从属性"><a href="#60、质量属性与其依从属性" class="headerlink" title="60、质量属性与其依从属性"></a>60、质量属性与其依从属性</h2><p>功能性：适合性、准确性、互操作性、安全保密性。</p><p>可靠性：成熟性、容错性、易恢复性。</p><p>易用性：易理解性、易学性、易操作性、吸引性。</p><p>效率：时间特性、资源利用性。</p><p>维护性：易分析性、稳定性、易测试性、易改变性。</p><p>可移植性：适应性、易安装性、共存性、易替换性。</p><h2 id="61、CMMI（能力成熟度模型集成）阶段式"><a href="#61、CMMI（能力成熟度模型集成）阶段式" class="headerlink" title="61、CMMI（能力成熟度模型集成）阶段式"></a>61、CMMI（能力成熟度模型集成）阶段式</h2><p>初始的：过程不可预测且缺乏控制</p><p>已管理的：过程为项目服务</p><p>已定义的：过程为组织服务</p><p>定量管理的：过程已度量和控制</p><p>优化的：集中于过程改进。</p><p>62、CMMI（能力成熟度模型集成）连续式</p><p>CL0（未完成的）：过程域未执行或未得到CL1中定义的所有目标。</p><p>CL1（已执行的）：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标。</p><p>CL2（已管理的）：其共性目标是集中于已管理的过程的制度化。</p><p>CL3（已定义级的）：其共性目标集中于已定义的过程的制度化。</p><p>CL4（定量管理的）：其共性目标集中于可定量管理的过程的制度化。</p><p>CL5（优化的）：使用量化（统计学）手段改变和优化过程域，以满足客户的改变和持续改进计划中的过程域的功效。</p><h2 id="63、Gantt图与PERT图"><a href="#63、Gantt图与PERT图" class="headerlink" title="63、Gantt图与PERT图"></a>63、Gantt图与PERT图</h2><p>甘特图能够消晰描述每个任务的开始/结束时间及各任务之间的并行性，也可以动态地反映项目的开发进展情况，但难以反映多个任务之间存在的逻辑关系；</p><p>PERT利用项目的网络图和各活动所需时间的估计值（通过加权平均得到的）去计算项目总时间，强调任务之间的先后关系，但不能反映任务之间的并行性，以及项目的当前进展情况。</p><h2 id="64、PERT图"><a href="#64、PERT图" class="headerlink" title="64、PERT图"></a>64、PERT图</h2><p>关键路径是图中源点至汇点的最长路径，关键路径的时间称之为项目工期，也表述为项目完成所需的最少时间。</p><p>总时差：在不延误总工期的前提下，该活动的机动时间。一般在图中，以最晚结束时间减去最早结束时间求取，或以最晚开始时间减去最早开始时间求取。</p><h2 id="65、风险管理"><a href="#65、风险管理" class="headerlink" title="65、风险管理"></a>65、风险管理</h2><p><strong>风险的特性</strong>：具有不确定性，可能会造成损失。</p><p><strong>风险的类别</strong></p><p>项目风险涉及到各种形式的预算、进度、人员、资源以及客户相关的问题，并且可能导致项目损失。</p><p>技术风险涉及到技术相关的可能会导致项目损失的问题。</p><p>商业风险与市场因素相关。</p><p>社会风险涉及到政策、法规等因素。</p><p>风险曝光度(RiskExposure)=错误出现率(风险出现率) X错误造成损失(风险损失)。</p><h2 id="66、沟通路径"><a href="#66、沟通路径" class="headerlink" title="66、沟通路径"></a>66、沟通路径</h2><p>有主程序员：n个成员小组，1个主程序员，普通程序员只需要与主程序员沟通。沟通路径：n-1。</p><p>无主程序员：n个成员的项目小组，相互之间都可以沟通。沟通路径：n(n-1)/2。</p><h2 id="67、数据流图"><a href="#67、数据流图" class="headerlink" title="67、数据流图"></a>67、数据流图</h2><p>数据流常见的3种错误</p><p>黑洞：加工只有输入没有输出；</p><p>奇迹：加工只有输出没有输入；</p><p>灰洞：加工中输入不足以产生输出。</p><p>子图与父图保持平衡</p><p>父图与子图之间平衡是指任何一张DFD子图边界上的输入/输出数据流必须与其父图对应加工的输入/输出数据了保持一致。如果父图中某个加工的一条数据流对应于子图中的几条数据流，而子图中组成这些数据流的数据项全体正好等于父图中的这条数据流，那么它们仍然是平衡的。</p><h2 id="68、面向对象基本概念"><a href="#68、面向对象基本概念" class="headerlink" title="68、面向对象基本概念"></a>68、面向对象基本概念</h2><p>面向对象：对象+分类+继承+通过消息的通信</p><p>对象：属性（数据）+方法（操作）+对象ID</p><p>封装：隐藏对象的属性和实现细节,仅对外公开接口（信息隐藏技术）</p><p>类（实体类/控制类/边界类）：对对象的抽象。</p><p>接口：一种特殊的类，他只有方法定义没有实现</p><p>继承与泛化：复用机制</p><p>消息和消息通信：对象之间进行通信的一种构造叫做消息。消息是异步通信的。</p><p>重置/覆盖：在子类中重新定义父类中已经定义的方法。</p><p>重载：一个类可以有多个同名而参数类型不同的方法。</p><p>动态绑定：根据接收对象的具体情况将请求的操作与实现的方法进行连接（运行时绑定）。</p><p>多态：不同对象收到同样的消息产生不同的结果。（软设一般只涉及过载多态-同一个名字在不同的上下文中所代表的含义不同）</p><h2 id="69、面向对象设计原则"><a href="#69、面向对象设计原则" class="headerlink" title="69、面向对象设计原则"></a>69、面向对象设计原则</h2><p>单一职责原则：设计目的单一的类</p><p>开放-封闭原则：对扩展开放，对修改封闭</p><p>李氏（Liskov）替换原则：子类可以替换父类</p><p>依赖倒置原则：要依赖于抽象，而不是具体实现；针对接口编程，不要针对实现编程</p><p>接口隔离原则：使用多个专门的接口比使用单一的总接口要好</p><p>组合重用原则：要尽量使用组合，而不是继承关系达到重用目的</p><p>迪米特（Demeter）原则（最少知识法则）：一个对象应当对其他对象有尽可能少的了解</p><h2 id="70、UML图分类"><a href="#70、UML图分类" class="headerlink" title="70、UML图分类"></a>70、UML图分类</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/kPXyszXBQ2.png" alt="1.png"></p><h2 id="71、类图关系"><a href="#71、类图关系" class="headerlink" title="71、类图关系"></a>71、类图关系</h2><p>依赖关系：一个事物发生变化影响另一个事物。</p><p>泛化关系：特殊/一般关系</p><p>关联关系：描述了一组链，链是对象之间的连接。</p><p>聚合关系：整体与部分生命周期不同。</p><p>组合关系：整体与部分生命周期相同。</p><p>实现关系：接口与类之间的关系</p><h2 id="72、用例关系"><a href="#72、用例关系" class="headerlink" title="72、用例关系"></a>72、用例关系</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/uUrBdg5jN7.png" alt="1.png"></p><h2 id="73、设计模式分类"><a href="#73、设计模式分类" class="headerlink" title="73、设计模式分类"></a>73、设计模式分类</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ZptmmShCn4.png" alt="1.png"></p><h2 id="74、创建型设计模式应用场景"><a href="#74、创建型设计模式应用场景" class="headerlink" title="74、创建型设计模式应用场景"></a>74、创建型设计模式应用场景</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/MgNJJE5cr4.png" alt="1.png"></p><h2 id="75、结构型设计模式应用场景"><a href="#75、结构型设计模式应用场景" class="headerlink" title="75、结构型设计模式应用场景"></a>75、结构型设计模式应用场景</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/RGgRC2Ynp8.png" alt="1.png"></p><h2 id="76、行为型设计模式应用场景1"><a href="#76、行为型设计模式应用场景1" class="headerlink" title="76、行为型设计模式应用场景1"></a>76、行为型设计模式应用场景1</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/NW6LLpLwC2.png" alt="1.png"></p><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/C8D4eJFn8s.png" alt="1.png"></p><h2 id="77、顺序表和链表对比"><a href="#77、顺序表和链表对比" class="headerlink" title="77、顺序表和链表对比"></a>77、顺序表和链表对比</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/W2hq9tLJLB.png" alt="1.png"></p><h2 id="78、树的基本概念"><a href="#78、树的基本概念" class="headerlink" title="78、树的基本概念"></a>78、树的基本概念</h2><p>双亲、孩子和兄弟：结点的子树的根称为该结点的孩子；相应地，该结点称为其子结点的双亲。具有相同双亲的结点互为兄弟。</p><p>结点的度：一个结点的子树的个数记为该结点的度</p><p>叶子结点：也称为终端结点，指度为0的结点</p><p>内部结点：度不为0的结点，也称为分支结点或非终端结点。除根结点之外，分支结点也称为内部结点。</p><p>结点的层次：根为第一层，根的孩子为第二层，依次类推，若某结点在第i层，则其孩子结点在第i+1层</p><p>树的高度：一棵树的最大层次数记为树的高度（深度）</p><h2 id="79、二叉树的特性"><a href="#79、二叉树的特性" class="headerlink" title="79、二叉树的特性"></a>79、二叉树的特性</h2><p>在二叉树的第i层上最多有2i-1个结点（i≥1）；</p><p>深度为k的二叉树最多有2k -1个结点（k≥1）；</p><p>对任何一棵二叉树，如果其叶子结点数为n0，度为2的结点数为n2，则n0=n2+1。</p><p>对一棵有n个结点的完全二叉树的结点按层序编号，即从第1层到⌊〖log〗_2⁡n ⌋+1层，每层从左到右依次编号。</p><h2 id="80、特殊的二叉树"><a href="#80、特殊的二叉树" class="headerlink" title="80、特殊的二叉树"></a>80、特殊的二叉树</h2><p>满二叉树：任何结点，或者是树叶，或者恰有两棵非空子树。</p><p>完全二叉树：最多只有最小面的两层结点的度可以小于2，并且最下面一层的结点全都集中在该层左侧的若干位置。</p><p>平衡二叉树：树中任一结点的左右子树高度之差不超过1。</p><p>查找二叉树：又称之为排序二叉树。任一结点的权值，大于其左孩子结点，小于其右孩子结点。中序遍历结果有序。</p><p>线索二叉树：在每个结点中增加两个指针域来存放遍历时得到的前驱和后继信息。</p><h2 id="81、最优二叉树的概念"><a href="#81、最优二叉树的概念" class="headerlink" title="81、最优二叉树的概念"></a>81、最优二叉树的概念</h2><p>最优二叉树：又称为哈弗曼树，它是一类带权路径长度最短的树。</p><p>路径是从树中一个结点到另一个结点之间的通路，路径上的分支数目称为路径长度。</p><p>树的路径长度是从树根到每一个叶子之间的路径长度之和。结点的带权路径长度为从该结点到树根之间的路径长度与该结点权值的乘积。</p><p>树的带权路径长度为树中所有叶子结点的带权路径长度之和。</p><h2 id="82、二叉树的遍历操作"><a href="#82、二叉树的遍历操作" class="headerlink" title="82、二叉树的遍历操作"></a>82、二叉树的遍历操作</h2><p>前序遍历：又称为先序遍历，按根左右的顺序进行遍历。</p><p>后序遍历：按左右根的顺序进行遍历。</p><p>中序遍历：按左根右的顺序进行遍历。</p><p>层次遍历：按层次顺序进行遍历。</p><h2 id="83、图的概念"><a href="#83、图的概念" class="headerlink" title="83、图的概念"></a>83、图的概念</h2><p>完全图</p><p>在无向图中，若每对顶点之间都有一条边相连，则称该图为完全图（complete graph）。</p><p>在有向图中，若每对顶点之间都有二条有向边相互连接，则称该图为完全图。</p><p>强连通图：在有向图中，对于每一对顶点，从顶点vi到顶点vj和从顶点vj到顶点vi都存在路径，则称为强连通图。</p><h2 id="84、图的遍历特点"><a href="#84、图的遍历特点" class="headerlink" title="84、图的遍历特点"></a>84、图的遍历特点</h2><p>深度优先遍历：</p><p>当以邻接矩阵作为存储结构时，深度优先搜索遍历图的时间复杂度为O(n2)</p><p>当以邻接表作为存储结构时，深度优先搜索遍历图的时间复杂度为O(n+e)</p><p>广度优先遍历和深度优先搜索遍历图的运算时间复杂度相同，其不同之处仅仅在于对顶点的访问次序不同。</p><h2 id="85、算法特性"><a href="#85、算法特性" class="headerlink" title="85、算法特性"></a>85、算法特性</h2><p>有穷性：执行有穷步之后结束，且每一步都可在有穷时间内完成。</p><p>确定性：算法中每一条指令都必须有确切的含义，不能含糊不清。</p><p>输入（&gt;=0）</p><p>输出（&gt;=1）</p><p>有效性(可行性)：算法的每个步骤都能有效执行并能在执行有限次后得到确定的结果。例如a=0，b/a就无效</p><h2 id="86、常见算法策略"><a href="#86、常见算法策略" class="headerlink" title="86、常见算法策略"></a>86、常见算法策略</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/f3pwmaGKPe.png" alt="1.png"></p><h2 id="87、常见的对算法执行所需时间的度量"><a href="#87、常见的对算法执行所需时间的度量" class="headerlink" title="87、常见的对算法执行所需时间的度量"></a>87、常见的对算法执行所需时间的度量</h2><p>O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n2)&lt;O(n3)&lt;O(2n)</p><h2 id="88、常见排序算法对比"><a href="#88、常见排序算法对比" class="headerlink" title="88、常见排序算法对比"></a>88、常见排序算法对比</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/YwYZk2QJGS.png" alt="1.png"></p><h2 id="89、常见排序算法适用常见对比1"><a href="#89、常见排序算法适用常见对比1" class="headerlink" title="89、常见排序算法适用常见对比1"></a>89、常见排序算法适用常见对比1</h2><p>若待排序列的记录数目n较小，可采用直接插入排序和简单选择排序。由于直接插入排序所需的记录移动操作较简单选择排序多，因而当记录本身信息量大时，用简单选择排序方法较好。</p><p>若待排记录按关键字基本有序，宜采用直接插入排序或冒泡排序。</p><p>当n很大且关键字位数较少时，采用基数排序较好。</p><p>若n很大，则应采用时间复杂度为O(nlog2n)的排序方法，例如快速排序、堆排序或归并排序：</p><p>快速排序目前被认为是内部排序中最好的方法，当待排序的关键字为随机分布时，快速排序的平均运行时间最短；</p><p>堆排序只需要一个辅助空间，并且不会出现在快速排序中可能出现的最快情况。</p><p>快速排序和堆排序都是不稳定的排序方法，若要求排序稳定，可选择归并排序。</p><h2 id="90、编译与解释的区别"><a href="#90、编译与解释的区别" class="headerlink" title="90、编译与解释的区别"></a>90、编译与解释的区别</h2><p>编译方式下机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程，因此执行时效率较高；</p><p>解释方式下解释程序和源程序（或某种等价表示）要参与到程序的运行过程中，边解释边执行，执行效率较低。</p><p>即：解释方式，翻译程序不生成独立的目标程序，而编译方式则生成独立保持的目标程序。</p><h2 id="91、编译过程"><a href="#91、编译过程" class="headerlink" title="91、编译过程"></a>91、编译过程</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Hm9w2YvsN9.png" alt="1.png"></p><p>符号表</p><p>符号表的作用是记录源程序中各个符号的必要信息，以辅助语义的正确性检查和代码生成，在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。符号表的存在可以贯穿编译所有阶段。</p><p>错误管理</p><p>静态错误：编译时所发现的程序错误，分为语法错误和静态语义错误。</p><p>语法错误包含：单词拼写错误、标点符号错误、表达式中缺少操作数、括号不匹配等有关语言结构上的错误。</p><p>静态语义分析：运算符与运算对象类型不合法等错误。</p><p>动态错误：发生程序运行时，也叫动态语义错误。包括死循环、变量取零时做除数、引用数组元素下标越界等错误。</p><h2 id="92、文法和正规式"><a href="#92、文法和正规式" class="headerlink" title="92、文法和正规式"></a>92、文法和正规式</h2><p>一般的程序设计语言属于上下文无关文法。</p><p>正规文法，表示的语言集合是正规集，正规集的规律可以用正规式表示。</p><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/8PdY6rMVGk.png" alt="1.png"></p><h2 id="93、传值调用和引用调用"><a href="#93、传值调用和引用调用" class="headerlink" title="93、传值调用和引用调用"></a>93、传值调用和引用调用</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/xzKbFuvKx2.png" alt="1.png"></p><h2 id="94、常见的程序设计语言"><a href="#94、常见的程序设计语言" class="headerlink" title="94、常见的程序设计语言"></a>94、常见的程序设计语言</h2><p>Fortran语言(第一个高级程序设计语言，科学计算，执行效率高）</p><p>Pascal语言（结构化程序设计语言，表达能力强，Delphi）</p><p>C语言（通用、结构化程序设计语言，指针操作能力强，高效）</p><p>Lisp语言（函数式程序语言，符号处理，人工智能）</p><p>C++语言（C语言基础上增加了类机制，面向对象，高效，与C兼容）</p><p>Java语言（面向对象，中间代码，跨平台，通用的程序设计语言）</p><p>Python（面向对象，解释型程序设计语言，胶水语言，通用的脚本语言）</p><p>PHP（服务器端脚本语言，制作动态网页）</p><p>Ruby（简单快捷、面向对象、脚本语言）</p><p>Delphi（快速应用程序开发工具，可视化编程环境）</p><p>COBOL（数据处理领域最为广泛的程序设计语言，高级编程语言）</p><p>XML（可扩展标记语言，标准通用标记语言的子集 ）</p><p>PROLOG（逻辑式语言，间接性，表达能力强，建造专家系统、数据库、自然语言理解、智能知识库等）</p><p>注：C/C++常被用于操作系统开发；脚本语言是解释性语言。</p><h2 id="95、保护范围和保护对象"><a href="#95、保护范围和保护对象" class="headerlink" title="95、保护范围和保护对象"></a>95、保护范围和保护对象</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/QaVaUaRu5M.png" alt="1.png"></p><h2 id="96、保护期限"><a href="#96、保护期限" class="headerlink" title="96、保护期限"></a>96、保护期限</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/5huyj2K9FT.png" alt="1.png"></p><h2 id="97、知识产权人确定-职务作品判定"><a href="#97、知识产权人确定-职务作品判定" class="headerlink" title="97、知识产权人确定-职务作品判定"></a>97、知识产权人确定-职务作品判定</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/6cYtySR63R.png" alt="1.png"></p><h2 id="98、知识产权人确定-其他"><a href="#98、知识产权人确定-其他" class="headerlink" title="98、知识产权人确定-其他"></a>98、知识产权人确定-其他</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/Em3Jx82dt7.png" alt="1.png"></p><h2 id="99、侵权判断的特殊要求"><a href="#99、侵权判断的特殊要求" class="headerlink" title="99、侵权判断的特殊要求"></a>99、侵权判断的特殊要求</h2><p>中国公民、法人或者其他组织的作品，不论是否发表，都享有著作权。</p><p>开发软件所用的思想、处理过程、操作方法或者数学概念不受保护</p><p>著作权法不适用于下列情形：</p><p>法律、法规，国家机关的决议、决定、命令和其他具有立法、行政、司法性质的文件，及其官方正式译文；</p><p>时事新闻；</p><p>历法、通用数表、通用表格和公式。</p><h2 id="100、典型的合理引用和侵权行为"><a href="#100、典型的合理引用和侵权行为" class="headerlink" title="100、典型的合理引用和侵权行为"></a>100、典型的合理引用和侵权行为</h2><p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E4%B8%8A%E5%8D%88%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/DKfrB3agf5.png" alt="1.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;软件设计师知识点100条&quot;&gt;&lt;a href=&quot;#软件设计师知识点100条&quot; class=&quot;headerlink&quot; title=&quot;软件设计师知识点100条&quot;&gt;&lt;/a&gt;软件设计师知识点100条&lt;/h1&gt;&lt;p&gt;转载自 希赛网&lt;/p&gt;
&lt;p&gt;原网址：&lt;a href=&quot;https://www.educity.cn/rk/2213375.html&quot;&gt;https://www.educity.cn/rk/2213375.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、码制的表示&quot;&gt;&lt;a href=&quot;#1、码制的表示&quot; class=&quot;headerlink&quot; title=&quot;1、码制的表示&quot;&gt;&lt;/a&gt;1、码制的表示&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定点整数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原码与反码的0既有+0也有-0，数码的表示个数为2n-1个。补码与移码有人为定义，-0编码定义为最小数值-1，数码的表示个数为2n个，最小表示数值为2n-1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定点小数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数码的表示个数与定点整数一致。补码与移码的人为定义，将-0的编码定义为最小数值-1。&lt;/p&gt;</summary>
    
    
    
    <category term="软考" scheme="https://laylaycjl.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="软考中级" scheme="https://laylaycjl.github.io/tags/%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>软考后半部分知识点</title>
    <link href="https://laylaycjl.github.io/2021/05/16/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://laylaycjl.github.io/2021/05/16/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-05-16T08:16:07.000Z</published>
    <updated>2021-10-21T14:48:06.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八章、程序设计语言与语言处理程序"><a href="#第八章、程序设计语言与语言处理程序" class="headerlink" title="第八章、程序设计语言与语言处理程序"></a>第八章、程序设计语言与语言处理程序</h1><p>转载自www.educity.cn</p><h2 id="1、编译过程"><a href="#1、编译过程" class="headerlink" title="1、编译过程"></a>1、编译过程</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516161759590.png" alt="image-20210516161759590" style="zoom: 33%;"></p><h2 id="2、文法的定义以及语法推导树"><a href="#2、文法的定义以及语法推导树" class="headerlink" title="2、文法的定义以及语法推导树"></a>2、文法的定义以及语法推导树</h2><span id="more"></span><h3 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516162153021.png" alt="image-20210516162153021" style="zoom: 33%;"></p><h3 id="文法类型"><a href="#文法类型" class="headerlink" title="文法类型"></a>文法类型</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516162120819.png" alt="image-20210516162120819" style="zoom: 33%;"></p><h3 id="语法推导树"><a href="#语法推导树" class="headerlink" title="语法推导树"></a>语法推导树</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516162428060.png" alt="image-20210516162428060" style="zoom: 33%;"></p><h2 id="3、有限自动机与正规式"><a href="#3、有限自动机与正规式" class="headerlink" title="3、有限自动机与正规式"></a>3、有限自动机与正规式</h2><h3 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516162718862.png" alt="image-20210516162718862" style="zoom: 33%;"></p><p>从S输入1可以到A，从A输入0可以到f，f有两个圈 意思是是终止</p><h3 id="文法推导"><a href="#文法推导" class="headerlink" title="文法推导"></a>文法推导</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516164853777.png" alt="image-20210516164853777" style="zoom: 33%;"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516163220839.png" alt="image-20210516163220839" style="zoom: 33%;"></p><p>第一问：首先从S出发推导，把ABCD选项带进去看看能不能推出来</p><p>最后发现ABC可行 D不行，因为从S—bB—baS—babB—bab(aS|a) 此时B只能化成aS或者是a 不可能接b</p><p>第二问：解题技巧：因为第一问已经退出ABC选项是符合要求的，所以把第二问的几个选项依次看能不能表达出第一问ABC选项的三个串</p><p>==（）^*^ : 意思是循环括号里的内容==</p><p>A.可以表达第一问的ABC选项，但它也能表达D选项，不符合一一对应关系</p><p>B.无法表达第一问的BC选项</p><p>C.可以表达第一问的ABC选项，不能表达D选项，符合要求</p><p>D.无法实现以ba开头</p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516164649299.png" alt="image-20210516164649299" style="zoom: 33%;"></p><p>从A开始走吧数字带进去看能不能到C</p><h2 id="4、表达式"><a href="#4、表达式" class="headerlink" title="4、表达式"></a>4、表达式</h2><p>和树结合，前、中、后序遍历 对应 前、中、后序表达式</p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516165045589.png" alt="image-20210516165045589" style="zoom: 33%;"></p><h2 id="5、各种程序语言特点"><a href="#5、各种程序语言特点" class="headerlink" title="5、各种程序语言特点"></a>5、各种程序语言特点</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516165323210.png" alt="image-20210516165323210" style="zoom:33%;"></p><h1 id="第九章-法律法规"><a href="#第九章-法律法规" class="headerlink" title="第九章 法律法规"></a>第九章 法律法规</h1><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516170235910.png" alt="image-20210516170235910" style="zoom:33%;"></p><h2 id="1、保护期限问题"><a href="#1、保护期限问题" class="headerlink" title="1、保护期限问题"></a>1、保护期限问题</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516171422842.png" alt="image-20210516171422842" style="zoom:33%;"></p><h2 id="2、知识产权人确定"><a href="#2、知识产权人确定" class="headerlink" title="2、知识产权人确定"></a>2、知识产权人确定</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516172554065.png" alt="image-20210516172554065" style="zoom:33%;"><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516173005346.png" alt="image-20210516173005346"></p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516173037525.png" alt="image-20210516173037525" style="zoom:33%;"></p><h2 id="3、侵权判定"><a href="#3、侵权判定" class="headerlink" title="3、侵权判定"></a>3、侵权判定</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516174502498.png" alt="image-20210516174502498" style="zoom:33%;"></p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516174555092.png" alt="image-20210516174555092" style="zoom:33%;"></p><h2 id="4、标准化基础知识"><a href="#4、标准化基础知识" class="headerlink" title="4、标准化基础知识"></a>4、标准化基础知识</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516175246275.png" alt="image-20210516175246275" style="zoom:33%;"><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516175337756.png" alt="image-20210516175337756"></p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516175354888.png" alt="image-20210516175354888" style="zoom:33%;"></p><h1 id="第十章-软件工程"><a href="#第十章-软件工程" class="headerlink" title="第十章 软件工程"></a>第十章 软件工程</h1><h2 id="1、软件开发模型"><a href="#1、软件开发模型" class="headerlink" title="1、软件开发模型"></a>1、软件开发模型</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516175850386.png" alt="image-20210516175850386" style="zoom:33%;"></p><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>初期很常用 现在几乎不使用 因为瀑布模型很难高效完成项目</p><p>缺点：需求一开始是无法完全确定的，一旦后期需求发生改变瀑布模型通过回溯来修改</p><p>适合于需求明确，或者是二次开发</p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516180803014.png" alt="image-20210516180803014" style="zoom:33%;"></p><h3 id="原型模型、演化模型、增量模型"><a href="#原型模型、演化模型、增量模型" class="headerlink" title="原型模型、演化模型、增量模型"></a>原型模型、演化模型、增量模型</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516182733476.png" alt="image-20210516182733476" style="zoom:33%;"></p><h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><p>只用于开发需求阶段，最适用于需求不明确的情况，刚好弥补了瀑布模型的缺陷</p><p>在项目初期构造一个简易系统向用户演示（只做外观方面 不做具体功能）</p><h4 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h4><p>由原型演化而来，在原型模型基础上和客户沟通所确定出来</p><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>做一块功能就和客户沟通修改，再做下一模块的功能</p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516183327654.png" alt="image-20210516183327654" style="zoom:43%;"></p><h3 id="V模型-喷泉模型-RAD模型（快速开发模型）"><a href="#V模型-喷泉模型-RAD模型（快速开发模型）" class="headerlink" title="V模型 喷泉模型  RAD模型（快速开发模型）"></a>V模型 喷泉模型  RAD模型（快速开发模型）</h3><ul><li><p>V模型强调测试要贯穿整个开发过程</p><ul><li>在需求分析的阶段就开始写验收测试和系统测试计划，从而发现需求分析中存在的问题</li><li>在概要设计时就写集成测试</li><li>详细设计时就写单元测试</li></ul></li><li><p>喷泉模型属于面向对象的模型（瀑布模型属于结构化的模型）</p></li><li><p>RAD模型（快速开发模型）</p><p>先建模（快速构建应用系统）再开发</p></li></ul><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516183942938.png" alt="image-20210516183942938" style="zoom:33%;"></p><h3 id="构件组装模型（CBSD）"><a href="#构件组装模型（CBSD）" class="headerlink" title="构件组装模型（CBSD）"></a>构件组装模型（CBSD）</h3><p>把各个模块做成构件，将各个构建组装起来构成目的软件</p><p>增加软件的复用性 </p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516193726037.png" alt="image-20210516193726037" style="zoom:33%;"></p><h2 id="2、敏捷开发方法"><a href="#2、敏捷开发方法" class="headerlink" title="2、敏捷开发方法"></a>2、敏捷开发方法</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516193935370.png" alt="image-20210516193935370" style="zoom:33%;"></p><h2 id="3、信息系统开发方法"><a href="#3、信息系统开发方法" class="headerlink" title="3、信息系统开发方法"></a>3、信息系统开发方法</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516222610320.png" alt="image-20210516222610320" style="zoom:33%;"></p><h2 id="4、需求分类与获取"><a href="#4、需求分类与获取" class="headerlink" title="4、需求分类与获取"></a>4、需求分类与获取</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516223600204.png" alt="image-20210516223600204" style="zoom:33%;"></p><h2 id="5、结构化设计"><a href="#5、结构化设计" class="headerlink" title="5、结构化设计"></a>5、结构化设计</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516224343287.png" alt="image-20210516224343287" style="zoom:33%;"></p><p>多扇入，少扇出：相当于入度和出度，也就是被别人调用的多，调用别人少</p><p>​                                被调用的多：说明这个模块的价值比较高</p><p>​                                调用别人少：说明这个模块对其他模块依赖程度高</p><h3 id="内聚与耦合"><a href="#内聚与耦合" class="headerlink" title="内聚与耦合"></a>内聚与耦合</h3><p>高内聚 低耦合</p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516224553886.png" alt="image-20210516224553886" style="zoom:33%;"></p><h3 id="系统结构-模块结构"><a href="#系统结构-模块结构" class="headerlink" title="系统结构/模块结构"></a>系统结构/模块结构</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516225223017.png" alt="image-20210516225223017" style="zoom:33%;"></p><h2 id="6、软件测试"><a href="#6、软件测试" class="headerlink" title="6、软件测试"></a>6、软件测试</h2><h3 id="测试原则与类型"><a href="#测试原则与类型" class="headerlink" title="测试原则与类型"></a>测试原则与类型</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517082452247.png" alt="image-20210517082452247" style="zoom:33%;"></p><h3 id="黑盒测试与白盒测试"><a href="#黑盒测试与白盒测试" class="headerlink" title="黑盒测试与白盒测试"></a>黑盒测试与白盒测试</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517083238935.png" alt="image-20210517083238935" style="zoom:33%;"></p><p>黑盒测试：</p><ul><li>边界值：下边界下方-正下边界———正上边界-上边界上方</li><li>错误推测：凭经验来试错</li></ul><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517083950939.png" alt="image-20210517083950939" style="zoom:33%;"></p><ul><li><p>单元测试：关注局部模块功能的测试</p></li><li><p>集成测试：把各个模块组装起来测试</p><ul><li>组装有两种方式（一次性组装，增量式组装）<ul><li>其中增量式组装是拼一个模块上去就测一次，拼接模块的方式又分为三种（自顶向下、自底向上、混合）</li></ul></li></ul></li><li><p>确认测试：需求测试，看做出来的产品 是否符合用户需求</p><ul><li>alpha（在开发试验环境测试）、beta测试（用户在本地使用）针对产品</li><li>验收测试：用户参与进来，看是否达到要求</li></ul></li><li><p>系统测试：关注整体的性能、安全等</p><ul><li><p>性能测试：通常收集所有和测试有关的所有性能，通常被不同人在不同场合下进行使用</p><ul><li><p>压力测试：压力测试是在强负载（大数据量、大量并发用户等）下的测试</p></li><li><p>负载测试（模拟实际软件系统所承受的负载条件的系统负荷，通过不断加载来观察不同负载下系统的性能）</p></li><li>强度测试（在资源异常的情况下，系统能否正常工作）<ul><li>Spike testing：短时间的极端负载测试<br>Extreme testing：在过量用户下的负载测试<br>Hammer testing：连续执行所有能做的操作 </li></ul></li><li>容量测试（确定系统可处理同时在线的最大用户数 ）</li></ul></li></ul></li></ul><h3 id="McCabe复杂度"><a href="#McCabe复杂度" class="headerlink" title="McCabe复杂度"></a>McCabe复杂度</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517090232117.png" alt="image-20210517090232117" style="zoom:33%;"></p><p>复杂度=m-n+2（n可以记为node，表示点的数目）</p><p>上图示例中是把每个交叉点都抽象成了一个结点</p><p>也可以不用抽象为结点，比如默认3、4都连到7上，10连到9上，9连到12上，算出来的复杂度也是正确的</p><h2 id="7、系统运行与维护"><a href="#7、系统运行与维护" class="headerlink" title="7、系统运行与维护"></a>7、系统运行与维护</h2><p>可维护性类型 以及 维护的类型</p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517090921326.png" alt="image-20210517090921326" style="zoom:33%;"></p><h2 id="8、软件能力成熟度模型集成"><a href="#8、软件能力成熟度模型集成" class="headerlink" title="8、软件能力成熟度模型集成"></a>8、软件能力成熟度模型集成</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517091750856.png" alt="image-20210517091750856" style="zoom:33%;"></p><h2 id="9、项目管理基础知识"><a href="#9、项目管理基础知识" class="headerlink" title="9、项目管理基础知识"></a>9、项目管理基础知识</h2><h3 id="甘特图（Gantt）与PERT图"><a href="#甘特图（Gantt）与PERT图" class="headerlink" title="甘特图（Gantt）与PERT图"></a>甘特图（Gantt）与PERT图</h3><p>甘特图（Gantt）</p><p>可以简单明了的展示项目进度，缺点是没办法表示事件与事件之间先后顺序</p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517092859487.png" alt="image-20210517092859487" style="zoom:33%;"></p><p>PERT图（软件项目活动图）</p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517093316237.png" alt="image-20210517093316237" style="zoom:33%;"></p><h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517093356203.png" alt="image-20210517093356203"></p><h1 id="第十一章-面向对象设计"><a href="#第十一章-面向对象设计" class="headerlink" title="第十一章 面向对象设计"></a>第十一章 面向对象设计</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517093753354.png" alt="image-20210517093753354" style="zoom:33%;"></p><h2 id="2、设计原则"><a href="#2、设计原则" class="headerlink" title="2、设计原则"></a>2、设计原则</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517094443194.png" alt="image-20210517094443194" style="zoom:33%;"></p><p>开放封闭原则：尽量扩展类来增加功能，而不是通过修改原有的类来增加功能</p><p>李氏替换原则：要让子类可以替换父类，而不要去重载</p><p>依赖倒装原则：也就是低耦合，针对接口编程，方便更新换代</p><p>组合重用原则：因为继承是紧耦合，少用继承</p><p>最少知识法则：信息隐蔽，统一用标准的方式调用对象</p><h2 id="3、UML"><a href="#3、UML" class="headerlink" title="3、UML"></a>3、UML</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517095137026.png" alt="image-20210517095137026" style="zoom:33%;"></p><h2 id="4、设计模式"><a href="#4、设计模式" class="headerlink" title="4、设计模式"></a>4、设计模式</h2><h3 id="设计模式概念"><a href="#设计模式概念" class="headerlink" title="设计模式概念"></a>设计模式概念</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517095812442.png" alt="image-20210517095812442" style="zoom:33%;"></p><p>区分架构模式与设计模式：看全局还是局部</p><p>区分设计模式与惯用法：看是否与具体的语言相关</p><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517100528273.png" alt="image-20210517100528273" style="zoom:33%;"><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517100548573.png" alt="image-20210517100548573" style="zoom: 50%;"></p><h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517100548573.png" style="zoom:33%;"></p><h4 id="结构性模式"><a href="#结构性模式" class="headerlink" title="结构性模式"></a>结构性模式</h4><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517101325589.png" alt="image-20210517101325589" style="zoom:33%;"></p><h4 id="行为性模式"><a href="#行为性模式" class="headerlink" title="行为性模式"></a>行为性模式</h4><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517102156112.png" alt="image-20210517102156112" style="zoom:33%;"><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517102259256.png" alt="image-20210517102259256" style="zoom: 50%;"></p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517102259256.png" alt="image-20210517102259256" style="zoom:50%;"></p><h1 id="第十二章-数据流图（DFD）下午题01"><a href="#第十二章-数据流图（DFD）下午题01" class="headerlink" title="第十二章 数据流图（DFD）下午题01"></a>第十二章 数据流图（DFD）下午题01</h1><p>（下午题 第一道 15分）</p><h2 id="1、数据流图概念"><a href="#1、数据流图概念" class="headerlink" title="1、数据流图概念"></a>1、数据流图概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517102645218.png" alt="image-20210517102645218" style="zoom:33%;"></p><p>加工：函数or功能模块</p><p>数据存储：记录表、记录文件</p><h3 id="数据流图的分层"><a href="#数据流图的分层" class="headerlink" title="数据流图的分层"></a>数据流图的分层</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517103211516.png" alt="image-20210517103211516" style="zoom:33%;"></p><h2 id="2、数据字典"><a href="#2、数据字典" class="headerlink" title="2、数据字典"></a>2、数据字典</h2><p>配合数据流</p><p>符号：</p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517103251128.png" alt="image-20210517103251128" style="zoom:33%;"></p><h2 id="3、数据流图平衡原则"><a href="#3、数据流图平衡原则" class="headerlink" title="3、数据流图平衡原则"></a>3、数据流图平衡原则</h2><h3 id="父图与子图之间的平衡"><a href="#父图与子图之间的平衡" class="headerlink" title="父图与子图之间的平衡"></a>父图与子图之间的平衡</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517103936191.png" alt="image-20210517103936191" style="zoom:33%;"></p><h3 id="子图内平衡"><a href="#子图内平衡" class="headerlink" title="子图内平衡"></a>子图内平衡</h3><ul><li>既有输入也有输出——正常</li><li>只有输入——黑洞</li><li>只有输出——奇迹</li></ul><h2 id="4、例题"><a href="#4、例题" class="headerlink" title="4、例题"></a>4、例题</h2><h3 id="解题技巧"><a href="#解题技巧" class="headerlink" title="解题技巧"></a>解题技巧</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210517142822495.png" alt="image-20210517142822495" style="zoom:33%;"></p><h1 id="第十三章-数据库设计-下午题02"><a href="#第十三章-数据库设计-下午题02" class="headerlink" title="第十三章 数据库设计 下午题02"></a>第十三章 数据库设计 下午题02</h1><h2 id="1、数据库设计过程"><a href="#1、数据库设计过程" class="headerlink" title="1、数据库设计过程"></a>1、数据库设计过程</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210522223650929.png" alt="image-20210522223650929" style="zoom:33%;"></p><h2 id="2、ER模型"><a href="#2、ER模型" class="headerlink" title="2、ER模型"></a>2、ER模型</h2><h3 id="实体间的联系类型"><a href="#实体间的联系类型" class="headerlink" title="实体间的联系类型"></a>实体间的联系类型</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210522223901524.png" alt="image-20210522223901524" style="zoom:33%;"></p><h3 id="ER模型-lt-gt-关系模式"><a href="#ER模型-lt-gt-关系模式" class="headerlink" title="ER模型<=>关系模式"></a>ER模型&lt;=&gt;关系模式</h3><p>原则：实体和联系分别转换为关系，属性则转换成相应关系的属性</p><h1 id="第十四章-UML图-下午题03"><a href="#第十四章-UML图-下午题03" class="headerlink" title="第十四章 UML图 下午题03"></a>第十四章 UML图 下午题03</h1><h2 id="1、用例图"><a href="#1、用例图" class="headerlink" title="1、用例图"></a>1、用例图</h2><p>包含关系：include</p><p>扩展关系：extend</p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210525175942979.png" alt="image-20210525175942979" style="zoom:50%;"></p><h2 id="2、类图与对象图"><a href="#2、类图与对象图" class="headerlink" title="2、类图与对象图"></a>2、类图与对象图</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210525184412155.png" alt="image-20210525184412155" style="zoom:80%;"></p><p>考察内容：</p><ul><li><p>填类名（最常考），填方法名，填属性名</p></li><li><p>填多重度</p><ul><li>1：表示一个集合中的一个对象对应另一个集合中1个对象</li><li>0..*：表示一个集合中的一个对象对应另一个集合中的0个或多个对象</li><li>1..*：表示一个集合中的一个对象对应另一个集合中的1个或多个对象</li><li>*：表示一个集合中的一个对象对应另一个集合中的多个对象</li></ul></li><li><p>填关系</p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/UML%E5%85%B3%E7%B3%BB.jpg" style="zoom: 67%;"></p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210525180820181.png" alt="image-20210525180820181" style="zoom:63%;"></p></li></ul><h2 id="3、顺序图"><a href="#3、顺序图" class="headerlink" title="3、顺序图"></a>3、顺序图</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210525184539938.png" alt="image-20210525184539938" style="zoom:67%;"></p><p>考察方面：</p><p>根据处理流程和题目描述来填消息名称（如图的6、7）</p><p>填对象名称</p><h2 id="4、活动图"><a href="#4、活动图" class="headerlink" title="4、活动图"></a>4、活动图</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210525184818879.png" alt="image-20210525184818879" style="zoom:67%;"></p><h2 id="5、状态图"><a href="#5、状态图" class="headerlink" title="5、状态图"></a>5、状态图</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210525191301040.png" alt="image-20210525191301040" style="zoom: 67%;"></p><p>考察方面：</p><p>填触发事件（也就是状态发生变化的条件）</p><h2 id="6、通信图（协助图）"><a href="#6、通信图（协助图）" class="headerlink" title="6、通信图（协助图）"></a>6、通信图（协助图）</h2><p>和顺序图很像，所以两者有时统称为交互图，但是相比之下，通信图没那么强调时间顺序</p><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210525191833610.png" alt="image-20210525191833610" style="zoom:67%;"></p><h1 id="第十五章-数据结构与算法-下午题04"><a href="#第十五章-数据结构与算法-下午题04" class="headerlink" title="第十五章 数据结构与算法 下午题04"></a>第十五章 数据结构与算法 下午题04</h1><h2 id="1、分治法"><a href="#1、分治法" class="headerlink" title="1、分治法"></a>1、分治法</h2><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210527091439792.png" alt="image-20210527091439792" style="zoom: 50%;"></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><img src="/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210527091639568.png" alt="image-20210527091639568" style="zoom:50%;"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第八章、程序设计语言与语言处理程序&quot;&gt;&lt;a href=&quot;#第八章、程序设计语言与语言处理程序&quot; class=&quot;headerlink&quot; title=&quot;第八章、程序设计语言与语言处理程序&quot;&gt;&lt;/a&gt;第八章、程序设计语言与语言处理程序&lt;/h1&gt;&lt;p&gt;转载自www.educity.cn&lt;/p&gt;
&lt;h2 id=&quot;1、编译过程&quot;&gt;&lt;a href=&quot;#1、编译过程&quot; class=&quot;headerlink&quot; title=&quot;1、编译过程&quot;&gt;&lt;/a&gt;1、编译过程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/%E8%BD%AF%E8%80%83%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/image-20210516161759590.png&quot; alt=&quot;image-20210516161759590&quot; style=&quot;zoom: 33%;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、文法的定义以及语法推导树&quot;&gt;&lt;a href=&quot;#2、文法的定义以及语法推导树&quot; class=&quot;headerlink&quot; title=&quot;2、文法的定义以及语法推导树&quot;&gt;&lt;/a&gt;2、文法的定义以及语法推导树&lt;/h2&gt;</summary>
    
    
    
    <category term="软考" scheme="https://laylaycjl.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="软考中级" scheme="https://laylaycjl.github.io/tags/%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的C语言</title>
    <link href="https://laylaycjl.github.io/2021/04/01/Linux%E4%B8%AD%E7%9A%84C%E8%AF%AD%E8%A8%80/"/>
    <id>https://laylaycjl.github.io/2021/04/01/Linux%E4%B8%AD%E7%9A%84C%E8%AF%AD%E8%A8%80/</id>
    <published>2021-04-01T14:59:31.000Z</published>
    <updated>2021-04-10T06:13:55.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、在指定路径下新建目录"><a href="#1、在指定路径下新建目录" class="headerlink" title="1、在指定路径下新建目录"></a>1、在指定路径下新建目录</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir函数原型： </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </span><br><span class="line">参数： path是目录名，mode是目录权限</span><br><span class="line"></span><br><span class="line">在/home/laylay路径下建立可读可写目录lab<span class="number">-2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="string">"/home/laylay/lab-2"</span>,<span class="number">777</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h1 id="2、通过open-read-write函数实现“cp”功能"><a href="#2、通过open-read-write函数实现“cp”功能" class="headerlink" title="2、通过open read write函数实现“cp”功能"></a>2、通过open read write函数实现“cp”功能</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">flags:</span><br><span class="line">O_RDONLY 以只读方式打开文件</span><br><span class="line">O_WRONLY 以只写方式打开文件</span><br><span class="line">O_RDWR 以可读写方式打开文件。上述三种旗标是互斥的，也就是不可同时使用，但可与下列的旗标利用OR(|)运算符组合。</span><br><span class="line">O_CREAT 若欲打开的文件不存在则自动建立该文件。</span><br><span class="line">O_EXCL 如果O_CREAT 也被设置，此指令会去检查文件是否存在。文件若不存在则建立该文件，否则将导致打开文件错误。此外，若O_CREAT与O_EXCL同时设置，并且欲打开的文件为符号连接，则会打开文件失败。</span><br><span class="line">O_NOCTTY 如果欲打开的文件为终端机设备时，则不会将该终端机当成进程控制终端机。</span><br><span class="line">O_TRUNC 若文件存在并且以可写的方式打开时，此旗标会令文件长度清为0，而原来存于该文件的资料也会消失。</span><br><span class="line">O_APPEND 当读写文件时会从文件尾开始移动，也就是所写入的数据会以附加的方式加入到文件后面。</span><br><span class="line">O_NONBLOCK 以不可阻断的方式打开文件，也就是无论有无数据读取或等待，都会立即返回进程之中。</span><br><span class="line">O_NDELAY 同O_NONBLOCK。</span><br><span class="line">O_SYNC 以同步的方式打开文件。</span><br><span class="line">O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接，则会令打开文件失败。</span><br><span class="line">O_DIRECTORY 如果参数pathname 所指的文件并非为一目录，则会令打开文件失败。</span><br><span class="line">此为Linux2.2以后特有的旗标，以避免一些系统安全问题。参数mode 则有下列数种组合，只有在建立新文件时才会生效，此外真正建文件时的权限会受到umask值所影响，因此该文件权限应该为（mode-umaks）。</span><br><span class="line">S_IRWXU00700 权限，代表该文件所有者具有可读、可写及可执行的权限。</span><br><span class="line">S_IRUSR 或S_IREAD，00400权限，代表该文件所有者具有可读取的权限。</span><br><span class="line">S_IWUSR 或S_IWRITE，00200 权限，代表该文件所有者具有可写入的权限。</span><br><span class="line">S_IXUSR 或S_IEXEC，00100 权限，代表该文件所有者具有可执行的权限。</span><br><span class="line">S_IRWXG 00070权限，代表该文件用户组具有可读、可写及可执行的权限。</span><br><span class="line">S_IRGRP 00040 权限，代表该文件用户组具有可读的权限。</span><br><span class="line">S_IWGRP 00020权限，代表该文件用户组具有可写入的权限。</span><br><span class="line">S_IXGRP 00010 权限，代表该文件用户组具有可执行的权限。</span><br><span class="line">S_IRWXO 00007权限，代表其他用户具有可读、可写及可执行的权限。</span><br><span class="line">S_IROTH 00004 权限，代表其他用户具有可读的权限</span><br><span class="line">S_IWOTH 00002权限，代表其他用户具有可写入的权限。</span><br><span class="line">S_IXOTH 00001 权限，代表其他用户具有可执行的权限。</span><br></pre></td></tr></tbody></table></figure><h2 id="（1）open-函数"><a href="#（1）open-函数" class="headerlink" title="（1）open()函数"></a>（1）open()函数</h2><p><strong>注意打开了的函数用完要关掉释放内存</strong></p><p>表头文件 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>定义函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//参数列表：文件打开路径，打开方式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname,<span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">//参数列表：相比上面的，这一种加上了第三个参数mode，主要是搭配O_CREAT使用，同样地，这个参数规定了属主、同组和其他人对文件的文件操作权限</span></span><br><span class="line"><span class="comment">//mode_t mode规定文件操作权限</span></span><br><span class="line">eg.</span><br><span class="line">    open(argv[<span class="number">2</span>],O_WRONLY|O_CREAT|O_APPEND,<span class="number">0644</span>)</span><br><span class="line">    <span class="comment">//解读：以只写（O_WRONLY），附加（O_APPEND）方式打开argv[2]文件，若argv[2]文件不存在，则以0644权限（O_CREAT）建立该文件</span></span><br><span class="line">    <span class="comment">//0644:6表示owner有可读可写权限，group可读，others可读</span></span><br></pre></td></tr></tbody></table></figure><p>返回值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若所有欲核查的权限都通过了检查则返回0 值，表示成功，只要有一个权限被禁止则返回-1。</span><br></pre></td></tr></tbody></table></figure><h2 id="（2）read-函数"><a href="#（2）read-函数" class="headerlink" title="（2）read()函数"></a>（2）read()函数</h2><p>表头文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br></pre></td></tr></tbody></table></figure><p>定义函数 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> * buf ,<span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">//read()会把参数fd 所指的文件传送count个字节到buf指针所指的内存中。若参数count为0，则read()不会有作用并返回0</span></span><br><span class="line">eg.</span><br><span class="line">    read(from,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">//把from中的内容读入缓冲区</span></span><br></pre></td></tr></tbody></table></figure><p>返回值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动</span><br></pre></td></tr></tbody></table></figure><h2 id="（3）write-函数"><a href="#（3）write-函数" class="headerlink" title="（3）write()函数"></a>（3）write()函数</h2><p>表头文件 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>定义函数 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span> <span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> * buf,<span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">//write()会把参数buf所指的内存写入count个字节到参数fd所指的文件内。当然，文件读写位置也会随之移动。</span></span><br><span class="line">eg.</span><br><span class="line">    write(to,buf,n)</span><br><span class="line">    <span class="comment">//把buf缓冲区的内容写入to文件中</span></span><br></pre></td></tr></tbody></table></figure><p>返回值 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果顺利write()会返回实际写入的字节数。当有错误发生时则返回<span class="number">-1</span>，错误代码存入errno中</span><br></pre></td></tr></tbody></table></figure><p>（4）举例</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过open read write函数实现“cp”功能</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n,from,to;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">3</span>){</span><br><span class="line">perror(<span class="string">"argc error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((from=open(argv[<span class="number">1</span>],O_RDONLY))&lt;<span class="number">0</span>){</span><br><span class="line">                perror(<span class="string">"from fail\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"><span class="keyword">if</span>((to=open(argv[<span class="number">2</span>],O_WRONLY|O_CREAT|O_APPEND,<span class="number">0644</span>))&lt;<span class="number">0</span>){</span><br><span class="line">                perror(<span class="string">"to fail\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"><span class="keyword">while</span>((n=read(from,buf,<span class="keyword">sizeof</span>(buf)))&gt;<span class="number">0</span>)</span><br><span class="line">write(to,buf,n);</span><br><span class="line">close(to);</span><br><span class="line">close(from);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">执行该程序的指令：</span><br><span class="line">编译：gcc exp3<span class="number">-1.</span>c -o exp3<span class="number">-1</span></span><br><span class="line">执行：./exp3<span class="number">-1</span> /proc/meminfo /home/laylay/exp3/my.meminfo</span><br><span class="line">     (./exp3<span class="number">-1</span> 要复制的文件源文件 要复制到的目的文件（可以顺带改名）)</span><br></pre></td></tr></tbody></table></figure><h1 id="3、移动指针用lseek函数"><a href="#3、移动指针用lseek函数" class="headerlink" title="3、移动指针用lseek函数"></a>3、移动指针用lseek函数</h1><p>表头文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>函数原型</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">fd：文件描述符，指向打开的文件</span><br><span class="line">whence：粗定位，选项有：</span><br><span class="line">   SEEK_SET：调到文件起始位置</span><br><span class="line">   SEEK_CUR：调到文件当前读写的位置</span><br><span class="line">   SEEK_END：调到文件末尾位置</span><br><span class="line">offset：精定位：微调位置</span><br><span class="line">   从whence指定的位置，向前或者向后移动指定字节数。</span><br><span class="line">   为负数：向前移动指定字节数</span><br><span class="line">   为正数：向后移动指定字节数</span><br><span class="line"></span><br><span class="line">不过当whence被指定为SEEK_SET时，如果offset被指定为负数的话，是没有意义，因为已经到文件头上了，在向前移动就越界了，不再当前文件的范围内了，如果非要向前调整，lseek函数会报错。</span><br></pre></td></tr></tbody></table></figure><p>返回值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">调用成功</span><br><span class="line">返回当前读写位置相对于文件开始位置的偏移量（字节）。</span><br><span class="line">可以使用lseek函数获取文件的大小，将文件读写的位置移动到最末尾，然后获取返回值，这个返回值就是文件头与文件尾之间的字节数，也就是文件大小。</span><br><span class="line"></span><br><span class="line">调用失败</span><br><span class="line">返回-1，并给errno设置错误号。</span><br></pre></td></tr></tbody></table></figure><p>应用举例：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"my.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">      <span class="keyword">char</span> buf1[]=<span class="string">"0123456789"</span>;</span><br><span class="line">      <span class="keyword">char</span> buf2[]=<span class="string">"abcdefghij"</span>;</span><br><span class="line">      <span class="keyword">int</span> fd;</span><br><span class="line">      fd=open(<span class="string">"file.hole.1"</span>,O_WRONLY|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">      write(fd,buf1,<span class="number">10</span>);</span><br><span class="line">      lseek(fd,<span class="number">40</span>,SEEK_SET);</span><br><span class="line">      write(fd,buf2,<span class="number">10</span>);</span><br><span class="line">      close(fd);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">执行该程序的指令：</span><br><span class="line">编译：gcc exp3<span class="number">-2.</span>c -o exp3<span class="number">-2</span></span><br><span class="line">执行：./exp3<span class="number">-2</span></span><br><span class="line">查看当前目录详细信息：ls -l</span><br><span class="line">查看以只写方式创建的file.hole<span class="number">.1</span>文件：cat file.hole<span class="number">.1</span></span><br><span class="line">查看file.hole<span class="number">.1</span>的详细存储方式：od -c file.hole<span class="number">.1</span></span><br></pre></td></tr></tbody></table></figure><p>执行结果中可以看出</p><ul><li>以只写方式创建的文件中，写入数据时候，会按照lseek中的指示，将指针从起始位置移动40后再写入</li><li>可以看到此种情况下file.hole.1文件大小为50<ul><li>如果后边不加write写入操作，仅仅移动指针，结果file.hole.1文件大小为10，因为仅仅拨动指针是没办法改变文件大小的，必须写入数据才会改变文件大小</li></ul></li></ul><p><img src="/images/Linux%E4%B8%AD%E7%9A%84C%E8%AF%AD%E8%A8%80/image-20210408230331195.png" alt="image-20210408230331195"></p><p>如果将fd打开方式变为追加打开</p><p>即<code>fd=open("file.hole.1",O_WRONLY|O_CREAT|O_APPEND,0644);</code>时</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"my.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">      <span class="keyword">char</span> buf1[]=<span class="string">"0123456789"</span>;</span><br><span class="line">      <span class="keyword">char</span> buf2[]=<span class="string">"abcdefghij"</span>;</span><br><span class="line">      <span class="keyword">int</span> fd;</span><br><span class="line">      fd=open(<span class="string">"file.hole.2"</span>,O_WRONLY|O_CREAT|O_APPEND,<span class="number">0644</span>);</span><br><span class="line">      write(fd,buf1,<span class="number">10</span>);</span><br><span class="line">      lseek(fd,<span class="number">40</span>,SEEK_SET);</span><br><span class="line">      write(fd,buf2,<span class="number">10</span>);</span><br><span class="line">      close(fd);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">执行该程序的指令：</span><br><span class="line">编译：gcc exp3<span class="number">-2.</span>c -o exp3<span class="number">-2</span></span><br><span class="line">执行：./exp3<span class="number">-2</span></span><br><span class="line">查看当前目录详细信息：ls -l</span><br><span class="line">查看以只写方式创建的file.hole<span class="number">.1</span>文件：cat file.hole<span class="number">.2</span></span><br><span class="line">查看file.hole<span class="number">.1</span>的详细存储方式：od -c file.hole<span class="number">.2</span></span><br></pre></td></tr></tbody></table></figure><p>lseek就会不起作用，数据依旧按照顺序已追加方式写入（对比如下）</p><p>file.hole.1以只写方式创建</p><p>file.hole.2以只写追加方式创建</p><p><img src="/images/Linux%E4%B8%AD%E7%9A%84C%E8%AF%AD%E8%A8%80/image-20210408231408315.png" alt="image-20210408231408315"></p><h1 id="4、输出重定向"><a href="#4、输出重定向" class="headerlink" title="4、输出重定向"></a>4、输出重定向</h1><h2 id="（1）dup1-dup2"><a href="#（1）dup1-dup2" class="headerlink" title="（1）dup1()/dup2()"></a>（1）dup1()/dup2()</h2><p>表头文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>函数原型</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line">相同点：dup和dup2两个函数都可以用来复制一个已经存在的文件描述符。</span><br><span class="line">不同点：dup返回的新文件描述符一定是当前可用文件描述符中最小数值，</span><br><span class="line">       dup2则可以是用filedes2参数指定新的描述符。</span><br><span class="line">注意：如果filedes已经打开，则先将其关闭。若filedes2等于filedes，则dup2返回filedes2，而不关闭它。</span><br></pre></td></tr></tbody></table></figure><p>返回值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若成功则返回新的文件秒速符，若出错则返回-1</span><br></pre></td></tr></tbody></table></figure><p>应用举例</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"my.h"</span></span></span><br><span class="line"><span class="comment">//输出重定向</span></span><br><span class="line"><span class="comment">//将before redirct!直接输出，将after redirct!转到out文件中输出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="comment">//新建out文件</span></span><br><span class="line">        fd=open(<span class="string">"out"</span>,O_WRONLY|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"before redirct!\n"</span>);</span><br><span class="line">        dup2(fd,STDOUT_FILENO);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"after redirct!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">执行该程序的指令：</span><br><span class="line">编译：gcc exp3<span class="number">-3.</span>c -o exp3<span class="number">-3</span></span><br><span class="line">执行：./exp3<span class="number">-3</span></span><br><span class="line">查看out文件：vi out</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/Linux%E4%B8%AD%E7%9A%84C%E8%AF%AD%E8%A8%80/image-20210408233211954.png" alt="image-20210408233211954"></p><p><img src="/images/Linux%E4%B8%AD%E7%9A%84C%E8%AF%AD%E8%A8%80/image-20210408233144551.png" alt="image-20210408233144551"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、在指定路径下新建目录&quot;&gt;&lt;a href=&quot;#1、在指定路径下新建目录&quot; class=&quot;headerlink&quot; title=&quot;1、在指定路径下新建目录&quot;&gt;&lt;/a&gt;1、在指定路径下新建目录&lt;/h1&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir函数原型： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/stat.h&amp;gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mkdir&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *path, &lt;span class=&quot;keyword&quot;&gt;mode_t&lt;/span&gt; mode)&lt;/span&gt;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数： path是目录名，mode是目录权限&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在/home/laylay路径下建立可读可写目录lab&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mkdir&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;/home/laylay/lab-2&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;777&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://laylaycjl.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux-C" scheme="https://laylaycjl.github.io/tags/Linux-C/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令总结</title>
    <link href="https://laylaycjl.github.io/2021/03/14/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>https://laylaycjl.github.io/2021/03/14/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-14T10:23:12.000Z</published>
    <updated>2021-04-22T15:41:34.077Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、绝对定位"><a href="#1、绝对定位" class="headerlink" title="1、绝对定位"></a>1、绝对定位</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/laylay/filename</span><br></pre></td></tr></tbody></table></figure><h4 id="2、touch命令"><a href="#2、touch命令" class="headerlink" title="2、touch命令"></a>2、touch命令</h4><p>建立新文件、更新时间情况</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /home/laylay/filename</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h4 id="3、编译命令"><a href="#3、编译命令" class="headerlink" title="3、编译命令"></a>3、编译命令</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc filename.c -o /filepath/filename</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc filename.cpp -o /filepath/filename</span><br></pre></td></tr></tbody></table></figure><p>filepath是决定把编译生成的可执行文件放在哪里</p><p>执行生成的可执行文件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/filepath/filename</span><br><span class="line">或者./filename</span><br></pre></td></tr></tbody></table></figure><p>在后台执行生成的可执行文件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filename&amp;</span><br></pre></td></tr></tbody></table></figure><p>eg.回车之后可以再运行，进程自己更换pid了，也就是他会派生出子进程</p><p><img src="/images/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C.jpg" style="zoom:50%;"></p><p>且通过top查看 三者都在运行态R</p><p><img src="/images/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%80%81.jpg" style="zoom:50%;"></p><h4 id="4、复制"><a href="#4、复制" class="headerlink" title="4、复制"></a>4、复制</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /home/laylay(源文件路径)/filename /home/laylay(目的文件路径)/filename</span><br></pre></td></tr></tbody></table></figure><h4 id="5、新建目录-删除目录"><a href="#5、新建目录-删除目录" class="headerlink" title="5、新建目录/删除目录"></a>5、新建目录/删除目录</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir filename</span><br><span class="line"></span><br><span class="line">使用-p选项可以创建一个还不存在的目录，比如我要在backup目录下新建一个目录test，并且在test目录下新建一个目录abc，当前状态是不存在test目录的，此时可以执行mkdir -p /home/laylay/backup/test/abc</span><br><span class="line"></span><br><span class="line">使用-m选项可以设置你将要创建的目录的权限，例如，想创建一个任何人都有权限的目录</span><br><span class="line">此时可以执行mkdir -p -m 777 /home/laylay/backup/test/abc</span><br><span class="line">除了上述用数字777表示权限外，也可以通过字母来表示</span><br><span class="line">mkdir -p -m a=rwx /home/laylay/backup/test/abc</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rmdir filename</span><br><span class="line">只能删除目录，如果目录里还有文件就无法删除该目录</span><br></pre></td></tr></tbody></table></figure><h4 id="6、新建文件"><a href="#6、新建文件" class="headerlink" title="6、新建文件"></a>6、新建文件</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi filename.filetype</span><br></pre></td></tr></tbody></table></figure><p>vi可读可写，cat只能读取</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit filename.filetype</span><br></pre></td></tr></tbody></table></figure><p>用纯文本编辑器打开文件</p><h4 id="7、只读文件"><a href="#7、只读文件" class="headerlink" title="7、只读文件"></a>7、只读文件</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename.filetype</span><br></pre></td></tr></tbody></table></figure><h4 id="8、编写文件"><a href="#8、编写文件" class="headerlink" title="8、编写文件"></a>8、编写文件</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入文件后先按insert键</span><br><span class="line">然后开始编辑文件</span><br><span class="line">编辑完成后，按esc退出编辑</span><br><span class="line">再输入 :wq 退出当前文件</span><br></pre></td></tr></tbody></table></figure><h4 id="9、查看当前路径"><a href="#9、查看当前路径" class="headerlink" title="9、查看当前路径"></a>9、查看当前路径</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></tbody></table></figure><h4 id="10、返回到上级目录"><a href="#10、返回到上级目录" class="headerlink" title="10、返回到上级目录"></a>10、返回到上级目录</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></tbody></table></figure><h4 id="11、删除目录以及目录中的文件"><a href="#11、删除目录以及目录中的文件" class="headerlink" title="11、删除目录以及目录中的文件"></a>11、删除目录以及目录中的文件</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用rm -rf 目录名字 命令即可</span><br><span class="line"></span><br><span class="line">r 就是向下递归，不管有多少级目录，一并删除</span><br><span class="line">-f 就是直接强行删除，不作任何提示的意思</span><br></pre></td></tr></tbody></table></figure><h4 id="12、查看当前路径下的目录"><a href="#12、查看当前路径下的目录" class="headerlink" title="12、查看当前路径下的目录"></a>12、查看当前路径下的目录</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></tbody></table></figure><h4 id="13、查看指定路径下的目录"><a href="#13、查看指定路径下的目录" class="headerlink" title="13、查看指定路径下的目录"></a>13、查看指定路径下的目录</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l 路径</span><br></pre></td></tr></tbody></table></figure><h4 id="14、编译脚本文件（改变权限）"><a href="#14、编译脚本文件（改变权限）" class="headerlink" title="14、编译脚本文件（改变权限）"></a>14、编译脚本文件（改变权限）</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 exp1.sh</span><br><span class="line">Linux档案的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限</span><br><span class="line">owner：文件的属主（拥有者）group：用户组内成员other：其他用户</span><br><span class="line">r:4 w:2 x:1</span><br><span class="line">r (read)：可读取此一档案的实际内容，如读取文本文件的文字内容等；</span><br><span class="line">w (write)：可以编辑、新增戒者是修改该档案的内容(但丌吨删除该档案)；</span><br><span class="line">x (eXecute)：该档案具有可以被系统执行的权限。</span><br><span class="line">owner=4+2+1=7</span><br><span class="line">group=4+2+1=7</span><br><span class="line">others=4+2+1=7</span><br><span class="line">也就是修改exp1.sh的权限为owner/group/others均可读可写可执行</span><br></pre></td></tr></tbody></table></figure><h4 id="15、移动-amp-amp-换名"><a href="#15、移动-amp-amp-换名" class="headerlink" title="15、移动&amp;&amp;换名"></a>15、移动&amp;&amp;换名</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv</span><br><span class="line">文件移动：mv 目标文件所在路径 目的地路径</span><br><span class="line">文件换名：mv 旧名 新名</span><br></pre></td></tr></tbody></table></figure><h4 id="16、计算运行时间"><a href="#16、计算运行时间" class="headerlink" title="16、计算运行时间"></a>16、计算运行时间</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time 执行命令</span><br><span class="line">例如：</span><br><span class="line">time ./exp2</span><br></pre></td></tr></tbody></table></figure><h4 id="17、查看详细文件存储情况"><a href="#17、查看详细文件存储情况" class="headerlink" title="17、查看详细文件存储情况"></a>17、查看详细文件存储情况</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">od -c filename</span><br></pre></td></tr></tbody></table></figure><h4 id="18、kill向进程发送信号"><a href="#18、kill向进程发送信号" class="headerlink" title="18、kill向进程发送信号"></a>18、kill向进程发送信号</h4><p><img src="/images/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/kill1.jpg" style="zoom:50%;"></p><p><img src="/images/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/kill2.jpg" style="zoom:50%;"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -9 pid(进程号) </span><br><span class="line">向进程发送信号终止进程</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">参数： </span><br><span class="line">-l：列出目前 kill 能够使用的讯号 (signal) 有哪些</span><br><span class="line">signal：代表给予后面接的那个工作什么样的指令</span><br><span class="line">-1(数字1)：重新读取一次参数的配置文件 (类似 reload)；</span><br><span class="line">-2：代表与由键盘输入ctrl c同样的动作；</span><br><span class="line">-9：立刻强制删除一个工作； </span><br><span class="line">-15：以正常的程序方式终止一项工作。与-9是不一样的</span><br></pre></td></tr></tbody></table></figure><h4 id="19、查看历史命令"><a href="#19、查看历史命令" class="headerlink" title="19、查看历史命令"></a>19、查看历史命令</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history</span><br></pre></td></tr></tbody></table></figure><h4 id="20、观察程序进程"><a href="#20、观察程序进程" class="headerlink" title="20、观察程序进程"></a>20、观察程序进程</h4><p><img src="/images/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/proc.jpg" style="zoom: 50%;"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proc里记录了进程的运行状态</span><br><span class="line">可以通过ls /proc/</span><br><span class="line">来查看某个进程是否运行</span><br><span class="line">通过ls /proc/进程号(也就是pid)</span><br><span class="line">来查看某个进程的具体运行状态</span><br></pre></td></tr></tbody></table></figure><h5 id="（1）静态（ps）"><a href="#（1）静态（ps）" class="headerlink" title="（1）静态（ps）"></a>（1）静态（ps）</h5><p>将某个时间点的程序运作情况撷取下来</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ps所带参数含义</span><br><span class="line">参数：</span><br><span class="line">-A ：所有的进程均显示出来，与 -e 具有同样的效用；</span><br><span class="line">-a ： 显示现行终端机下的所有进程，包括其他用户的进程；</span><br><span class="line">-u ：以用户为主的进程状态 ；</span><br><span class="line">x ：通常与 a 这个参数一起使用，可列出较完整信息。</span><br><span class="line"></span><br><span class="line">输出格式规划：</span><br><span class="line">l ：较长、较详细的将该PID 的的信息列出；</span><br><span class="line">j ：工作的格式 (jobs format)</span><br><span class="line">-f ：做一个更为完整的输出。</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/ps.jpg" style="zoom:67%;"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输出信息的含义</span><br><span class="line">UID： 说明该程序被谁拥有</span><br><span class="line">PID：就是指该程序的PID号码</span><br><span class="line">PPID： 就是指该程序父级程序的PID号码</span><br><span class="line">C： 指的是 CPU 使用率，单位为百分比</span><br><span class="line">STIME： 程序的启动时间</span><br><span class="line">TTY： 指的是登录终端</span><br><span class="line">TIME : 指程序使用掉 CPU 的时间</span><br><span class="line">CMD： 下达的指令就是 command 的缩写</span><br></pre></td></tr></tbody></table></figure><h5 id="（2）动态（top）"><a href="#（2）动态（top）" class="headerlink" title="（2）动态（top）"></a>（2）动态（top）</h5><p>top可以持续侦测程序的变化</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top -d 2</span><br><span class="line">解释：动态观察程序状态，每两秒刷新一次</span><br><span class="line">选项与参数： </span><br><span class="line">   -d：后面可以接秒数，就是整个程序画面更新的秒数。预设是5秒；</span><br><span class="line">   -b：以批次的方式执行top</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/top.jpg" style="zoom:67%;"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出信息的含义:</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">上半部分：</span><br><span class="line">第一行：(top)</span><br><span class="line">04:03:28————目前的时间</span><br><span class="line">up 4:36————开机到目前为止所经过的时间</span><br><span class="line">1 user————已经登入系统的用户人数</span><br><span class="line">load average: 2.14,2.09,2.17————系统在1,5,15分钟的平均工作负载，负载高于1就有点繁复，显然我的过分繁复了，呜呜呜</span><br><span class="line"></span><br><span class="line">第二行：(任务Tasks)</span><br><span class="line">289 total————目前程序总量</span><br><span class="line">3个处在运行态，286个睡眠态，0个停止，0个僵尸</span><br><span class="line"></span><br><span class="line">第三行：(cpus)</span><br><span class="line">显示的是 CPU 的整体负载，每个顷目可使用? </span><br><span class="line">查阅。需要特别注意癿是 %wa ，那个项目代表的是 I/O wait， 通常你癿系统会变慢都是I/O产生癿问题比较大！因此这里得要注意这个项目耗用CPU的资源喔！</span><br><span class="line"></span><br><span class="line">第四行与第五行：表示目前的物理内存与虚拟内存 (Mem/Swap) 的使用情况</span><br><span class="line"></span><br><span class="line">第六行：这个是当在 top 程序当中输入指令时，显示状态的地方。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下半部分：</span><br><span class="line">PID ：每个process的ID 啦！</span><br><span class="line">USER：该process所属的使用者；</span><br><span class="line">PR ：Priority癿简写，程序的优先执行顺序，越小越早被执行；</span><br><span class="line">NI ：Nice的简写，与Priority有关，也是越小越早被执行；</span><br><span class="line"><span class="meta">%</span><span class="bash">CPU：CPU的使用率；</span></span><br><span class="line"><span class="meta">%</span><span class="bash">MEM：内存的使用率；</span></span><br><span class="line">TIME+：CPU 使用时间的累加；</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1、绝对定位&quot;&gt;&lt;a href=&quot;#1、绝对定位&quot; class=&quot;headerlink&quot; title=&quot;1、绝对定位&quot;&gt;&lt;/a&gt;1、绝对定位&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/home/laylay/filename&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2、touch命令&quot;&gt;&lt;a href=&quot;#2、touch命令&quot; class=&quot;headerlink&quot; title=&quot;2、touch命令&quot;&gt;&lt;/a&gt;2、touch命令&lt;/h4&gt;&lt;p&gt;建立新文件、更新时间情况&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;touch /home/laylay/filename&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://laylaycjl.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://laylaycjl.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
