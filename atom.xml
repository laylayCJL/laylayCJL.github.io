<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>laylayCJL&#39;s Blog</title>
  
  
  <link href="https://laylaycjl.github.io/atom.xml" rel="self"/>
  
  <link href="https://laylaycjl.github.io/"/>
  <updated>2024-05-22T15:03:53.153Z</updated>
  <id>https://laylaycjl.github.io/</id>
  
  <author>
    <name>laylayCJL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小程序测试</title>
    <link href="https://laylaycjl.github.io/2024/05/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/"/>
    <id>https://laylaycjl.github.io/2024/05/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/</id>
    <published>2024-05-21T01:46:53.000Z</published>
    <updated>2024-05-22T15:03:53.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、微信小程序介绍"><a href="#一、微信小程序介绍" class="headerlink" title="一、微信小程序介绍"></a>一、微信小程序介绍</h1><h3 id="1、-web、app和小程序的区别："><a href="#1、-web、app和小程序的区别：" class="headerlink" title="1、==*web、app和小程序的区别：=="></a>1、==*web、app和小程序的区别：==</h3><p><img src="/2024/05/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/image-20240521105540085.png" alt="image-20240521105540085"></p><h3 id="2、微信小程序的定义"><a href="#2、微信小程序的定义" class="headerlink" title="2、微信小程序的定义"></a>2、微信小程序的定义</h3><p>依附于微信，而且无需再次下载安装的移动端应用程序-CS架构</p><p>1.2微信小程序的特点</p><ul><li>无需下载，即用即走，方便快捷</li><li>功能丰富，清爽体验、优雅的体验性</li><li>流量大，用户群易变大</li></ul><h3 id="3、微信小程序的应用领域"><a href="#3、微信小程序的应用领域" class="headerlink" title="3、微信小程序的应用领域"></a>3、微信小程序的应用领域</h3><p>衣、食、住、行、用</p><h3 id="4、微信小程序的局限性"><a href="#4、微信小程序的局限性" class="headerlink" title="4、微信小程序的局限性"></a>4、微信小程序的局限性</h3><ul><li>数量：每个应用最大支持页面层级为10层</li><li>大小：小程序支持不超过8M的源码文件(如果分包加载，那么单个分包不超过2M)（针对开发来说的）</li><li>逻辑︰如果逻辑过于复杂,可能出现不可控的异常问题</li></ul><h3 id="5、如何开发小程序"><a href="#5、如何开发小程序" class="headerlink" title="5、如何开发小程序"></a>5、如何开发小程序</h3><p>1、注册小程序账号</p><ul><li>在微信公众平台上注册一个小程序账号，并完成相关认证和设置。</li><li><a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com/</a></li></ul><p>2、下载开发者工具</p><ul><li>下载微信官方提供的小程序开发者工具，安装并登录你的小程序账号</li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></li></ul><p>3、创建新项目</p><ul><li><p>在开发者工具中选择“新建小程序”，填写小程序名称、AppID等基本信息，并选择合适的框架类型。</p><p><img src="/2024/05/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/image-20240521095412088.png" alt="image-20240521095412088" style="zoom:33%;"></p></li></ul><p>4、编写代码</p><ul><li>使用开发者工具提供的代码编辑器编写小程序代码</li></ul><p>5、调试和测试</p><ul><li>在开发者工具中进行模拟器调试或手机真机调试，确保小程序正常运行</li></ul><p>6、提交审核</p><ul><li>完成开发后，在微信公众平台中提交小程序审核申请，并等待审核通过后发布上线</li></ul><p>7、更新迭代</p><ul><li>根据用户反馈和需求，不断完善小程序功能和体验，进行版本更新迭代</li></ul><span id="more"></span><h3 id="6、-小程序的测试版与正式版"><a href="#6、-小程序的测试版与正式版" class="headerlink" title="6、 小程序的测试版与正式版"></a>6、 小程序的测试版与正式版</h3><h4 id="2-1-如何获取小程序的测试版"><a href="#2-1-如何获取小程序的测试版" class="headerlink" title="2.1 ==如何获取小程序的测试版=="></a>2.1 ==如何获取小程序的测试版==</h4><p><img src="/2024/05/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/image-20240521105815100.png" alt="image-20240521105815100" style="zoom:50%;"></p><h4 id="2-2-正式版与测试版的区别"><a href="#2-2-正式版与测试版的区别" class="headerlink" title="2.2 正式版与测试版的区别"></a>2.2 正式版与测试版的区别</h4><p>1、权限不同</p><ul><li>体验版：被开发者添加为体验者，才能获得体验版的权限</li><li>正式版：没有这个限制，所有用户都可以搜索、下载、使用小程序</li></ul><p>2、功能不同</p><ul><li>体验版：有限制，某些高级接口、支付功能或与第三方平台的对接等，这是为了保护开发者的利益和小程序的安全性</li><li>正式版：完整的所有功能</li></ul><p>3、更新频率</p><ul><li>体验版：开发者进行修改或更新后，可以随时向体验者推送新版本</li><li>正式版：正式版的更新则需要经过开发者审核，通常会有一定的时间延迟</li></ul><p>4、操作流程</p><ul><li>体验版：在开发工具中直接生成体验版二维码，通过扫描二维码即可进入体验版</li><li>正式版：通过微信或其他平台的搜索、下载、安装等操作流程才能使用</li></ul><p>5、用户体验</p><ul><li>体验版：面向开发者和特定的测试用户，目的是为了收集用户的反馈和优化小程序的体验</li><li>正式版：所有用户使用的，需要更加稳定、流畅和易用</li></ul><h1 id="二、小程序测试点"><a href="#二、小程序测试点" class="headerlink" title="二、小程序测试点"></a>二、小程序测试点</h1><h3 id="1、-功能测试"><a href="#1、-功能测试" class="headerlink" title="1、==功能测试=="></a>1、==功能测试==</h3><ul><li>正常的功能测试，按照需求文档来测试就OK了，类似于类似web、app的功能测试</li><li>功能测试都一样，测试用户的显性需求及隐形需求即可</li><li>功能交互<ul><li>因为小程序是在微信里面，所以还需要验证一些跟微信的交互</li><li>a) 比如转发给朋友，微信群</li><li>b) 比如是否不能分享到朋友圈</li><li>c）分享到其他应用是否支持等</li></ul></li></ul><h3 id="2、-UI界面测试"><a href="#2、-UI界面测试" class="headerlink" title="2、==UI界面测试=="></a>2、==UI界面测试==</h3><ul><li>是否易于导航，导航是否直观、导航与页面结构、菜单、连接页面的风格是否一致</li><li>横向比较，各控件操作方式统一、页面际签风格是否统</li><li>自适应界面设计，内容根据窗口大小自适应，文字推荐sp比例像素单位</li><li>文案字体、字号、格式、规范一致</li><li>页面的图片清晰、尺寸一致、配色合理、风格一致</li><li>输入框说明文字的内容与系统功能是否一致</li><li>小程序界面上文字长度是否加以限制、文字内容是否表意不明</li><li>是否有错别字、信息是否为中文显示</li><li>是否有敏感性词汇、关健词、敏感性图片，如：涉及版权、专利、隐私等图片</li></ul><h3 id="3、-易用性测试"><a href="#3、-易用性测试" class="headerlink" title="3、==易用性测试=="></a>3、==易用性测试==</h3><ul><li>本地化界面应支持<strong>中文用户界面</strong>，中文界面的关键信息不应存在非中文字符，如选单项、标签和提示信息等。</li><li><strong>可辨识性</strong><ul><li>a)单一界面一次不宜载入和展示太多的信息，界面不宜出现模糊、拉伸变形Q等问题；</li><li>b)界而中按钮可点击范围应适中，按钮不宜出现点击无反应或报错等问题；</li><li>c)标签应与内容相关联，当切换标签的时候，界而內容应跟着切换；</li><li>d)不宜有空白或无任何信息内容的界面。</li></ul></li><li><strong>易学性软件界面设计</strong>，宜有引导用户去执行合适的操作，但不宜滥用用户引导功能或误导用户操作</li><li><strong>用户差错防御性</strong><ul><li>用户界面按钮处于不可用状虑时，应将接钮设置为灰色，避免误导用户</li></ul></li></ul><ul><li><p><strong>易操作性</strong></p><ul><li>a)菜单层次不宜超过三层；</li><li>b)交互流程分支不宜超过四个分支；</li><li>c)功能相关的选项不宜离得太远；</li><li>d)界面功能操作应有主次从属关系；</li><li>e)界面宜支持多点触控功能；</li><li>f)界面应有退出、返回按键或选单。</li></ul></li><li><p><strong>用户界面舒适性</strong></p><ul><li>a)宜支持横、竖屏模式自动切换，且能根据终端位置自适应展示竖屏或横屏；</li><li>b)推送的广告占屏不宜超过1/3,不应无法关闭或强制用户观不能超过10 S；</li><li>c)应支持字形大小可调整，界面和字型颜色应协调统一</li></ul></li></ul><ul><li><strong>帮助系统</strong><ul><li>a)用户首次使用应有授权说明；</li><li>b)功能使用说明或用户操作手册；</li><li>c)外部消息提醒和消息查看和删除等功能；</li><li>d)当内存或存储空间不⾜时，提示用户及时清理内存或存储。</li></ul></li></ul><h3 id="4、-兼容性测试"><a href="#4、-兼容性测试" class="headerlink" title="4、==兼容性测试=="></a>4、==兼容性测试==</h3><ul><li>不同的操作系统<ul><li>测兼容性的原因<ul><li>小程序低层调用依赖于具体的操作系统，按照官方文档描述，小程序在IOS上是运行在JavaScriptCore中，但Android上是通过X5JSCore来解析的</li></ul></li></ul></li><li>兼容屏幕尺寸<ul><li>不同的屏幕，如直面屏、全面屏、曲面屏、折叠屏等</li></ul></li><li>微信兼容性<ul><li>比如支持哪些微信版本号</li></ul></li><li>工具<ul><li>Wetest平台</li><li>真机</li></ul></li></ul><h3 id="5、-权限测试"><a href="#5、-权限测试" class="headerlink" title="5、==权限测试=="></a>5、==权限测试==</h3><ul><li><strong>测试授权方式</strong><ul><li>未授权微信登录小程序<ul><li>弹出提醒，先授权再操作</li></ul></li><li>已授权微信登录小程序<ul><li>自动以微信身份使用</li></ul></li><li>同一微信号在不同手机端登录授权查看数据权限<ul><li>数据和操作权限一致</li></ul></li></ul></li><li><strong>同一微信号在不同的手机的微信端授权访问后，数据是否保持一致</strong></li></ul><h3 id="6、入口测试"><a href="#6、入口测试" class="headerlink" title="6、入口测试"></a>6、入口测试</h3><ul><li>从不同的入口进入小程序，对应功能是否正常</li><li>例如：微信主入口、二维码分享、链接分享等</li></ul><h3 id="7、性能测试"><a href="#7、性能测试" class="headerlink" title="7、性能测试"></a>7、性能测试</h3><ul><li>跟app的性能测试类似</li><li>主要考虑是否白屏、首屏加载时间、资源占用、页面渲染时间、帧率等<ul><li>小程序的冷启动响应时间不宜超过3s。<ul><li>小程序的冷启动是指用户首次打开小程序，或者小程序在被销毁后再次被用户打开时，需要重新加载和启动的过程</li></ul></li><li>小程序的热启动响应时间不宜超过1s。<ul><li>用户已经打开过某个小程序，然后在一定时间内（如30分钟或5分钟）再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态。这个过程不需要重新加载启动，因此通常耗时非常低</li></ul></li><li>小程序在界面切换的过程中，如无特殊要求，帧率应不低于20FPS</li><li>小程序功能性操作的响应时间，如无特殊要求，应小于5s<ul><li>2-5-10</li></ul></li><li>注：用户有明确指标要求的，以用户要求为准。</li></ul></li><li>工具：PerfDog</li></ul><h3 id="8、安全测试"><a href="#8、安全测试" class="headerlink" title="8、安全测试"></a>8、安全测试</h3><ul><li>因为是内嵌到微信的，这个一般考虑比较少</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、微信小程序介绍&quot;&gt;&lt;a href=&quot;#一、微信小程序介绍&quot; class=&quot;headerlink&quot; title=&quot;一、微信小程序介绍&quot;&gt;&lt;/a&gt;一、微信小程序介绍&lt;/h1&gt;&lt;h3 id=&quot;1、-web、app和小程序的区别：&quot;&gt;&lt;a href=&quot;#1、-web、app和小程序的区别：&quot; class=&quot;headerlink&quot; title=&quot;1、==*web、app和小程序的区别：==&quot;&gt;&lt;/a&gt;1、==*web、app和小程序的区别：==&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2024/05/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/image-20240521105540085.png&quot; alt=&quot;image-20240521105540085&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、微信小程序的定义&quot;&gt;&lt;a href=&quot;#2、微信小程序的定义&quot; class=&quot;headerlink&quot; title=&quot;2、微信小程序的定义&quot;&gt;&lt;/a&gt;2、微信小程序的定义&lt;/h3&gt;&lt;p&gt;依附于微信，而且无需再次下载安装的移动端应用程序-CS架构&lt;/p&gt;
&lt;p&gt;1.2微信小程序的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无需下载，即用即走，方便快捷&lt;/li&gt;
&lt;li&gt;功能丰富，清爽体验、优雅的体验性&lt;/li&gt;
&lt;li&gt;流量大，用户群易变大&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3、微信小程序的应用领域&quot;&gt;&lt;a href=&quot;#3、微信小程序的应用领域&quot; class=&quot;headerlink&quot; title=&quot;3、微信小程序的应用领域&quot;&gt;&lt;/a&gt;3、微信小程序的应用领域&lt;/h3&gt;&lt;p&gt;衣、食、住、行、用&lt;/p&gt;
&lt;h3 id=&quot;4、微信小程序的局限性&quot;&gt;&lt;a href=&quot;#4、微信小程序的局限性&quot; class=&quot;headerlink&quot; title=&quot;4、微信小程序的局限性&quot;&gt;&lt;/a&gt;4、微信小程序的局限性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数量：每个应用最大支持页面层级为10层&lt;/li&gt;
&lt;li&gt;大小：小程序支持不超过8M的源码文件(如果分包加载，那么单个分包不超过2M)（针对开发来说的）&lt;/li&gt;
&lt;li&gt;逻辑︰如果逻辑过于复杂,可能出现不可控的异常问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;5、如何开发小程序&quot;&gt;&lt;a href=&quot;#5、如何开发小程序&quot; class=&quot;headerlink&quot; title=&quot;5、如何开发小程序&quot;&gt;&lt;/a&gt;5、如何开发小程序&lt;/h3&gt;&lt;p&gt;1、注册小程序账号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在微信公众平台上注册一个小程序账号，并完成相关认证和设置。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/&quot;&gt;https://mp.weixin.qq.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、下载开发者工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载微信官方提供的小程序开发者工具，安装并登录你的小程序账号&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、创建新项目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在开发者工具中选择“新建小程序”，填写小程序名称、AppID等基本信息，并选择合适的框架类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/05/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/image-20240521095412088.png&quot; alt=&quot;image-20240521095412088&quot; style=&quot;zoom:33%;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4、编写代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用开发者工具提供的代码编辑器编写小程序代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5、调试和测试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在开发者工具中进行模拟器调试或手机真机调试，确保小程序正常运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6、提交审核&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成开发后，在微信公众平台中提交小程序审核申请，并等待审核通过后发布上线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;7、更新迭代&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据用户反馈和需求，不断完善小程序功能和体验，进行版本更新迭代&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="小程序测试" scheme="https://laylaycjl.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>测试用例设计</title>
    <link href="https://laylaycjl.github.io/2024/05/17/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
    <id>https://laylaycjl.github.io/2024/05/17/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-05-17T02:35:31.000Z</published>
    <updated>2024-05-18T02:22:27.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、用例概念与构成要素"><a href="#1、用例概念与构成要素" class="headerlink" title="1、用例概念与构成要素"></a>1、用例概念与构成要素</h1><h2 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h2><p>1、测试用例是一份测试文档，它描述<strong>输入、动作、和一个期望的结果</strong>，其目的是确定应用程序的某个特性是否正常的工作。</p><p>2、测试用例是软件测试团队的主要工作成果之一</p><p>3、测试用例的质量与写该用例的测试人员的水平关系极大</p><p>4、执行测试用例：当一个软件版本被测试时，测试人员会使用一整套的测试用例（或者筛选其中的一部分），将这些用例逐个在被测的软件上执行，并判断其结果是否和预期相符，并以此评价软件版本的质量</p><h2 id="（2）-构成要素"><a href="#（2）-构成要素" class="headerlink" title="（2）==构成要素=="></a>（2）==构成要素==</h2><p><strong>测试编号</strong>：一般用英文+数字来组合：项目名称 _模块名称 _ 序号，例如: korei_shopMgt_001</p><p>对应的<strong>功能模块</strong></p><p><strong>测试标题</strong>：尽可能简洁明了无歧义</p><p><strong>用例级别</strong>：高:核心功能+正向用例；中:核心功能+反向用例、一般功能+正向用例；低:一般功能+反向用例</p><p><strong>前置条件</strong>：用例执行前需要什么条件，例如删除用户前确保该用户存在</p><p><strong>操作步骤</strong></p><p><strong>预期结果</strong></p><p>举例：</p><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/image-20240518095715104.png" alt="image-20240518095715104" style="zoom:50%;"></p><h1 id="2、测试用例的注意事项"><a href="#2、测试用例的注意事项" class="headerlink" title="2、测试用例的注意事项"></a>2、测试用例的注意事项</h1><p>1、用语简洁清晰，但不能过于简单</p><p>2、用语无歧义，尽量少用过长的句子</p><p>3、用例的各个基本要素要齐备，不能缺失</p><p>4、用例的步骤应该足够详细，操作应该明确</p><p>5、容易被其它测试工程师读懂，并能顺利执行</p><blockquote><p>==什么样的测试用例是高质量的用例/一份好的用例?==</p><p>1）覆盖度高</p><p>2）用例标题简洁明了，尽量少用长句，不能过于简单，无歧义</p><p>3）用例的步骤要详尽</p><p>4）可读性好：其他测试工程师容易读懂、容易执行，不容易遗漏</p></blockquote><h1 id="3、测试用例的编写粒度"><a href="#3、测试用例的编写粒度" class="headerlink" title="3、测试用例的编写粒度"></a>3、测试用例的编写粒度</h1><p>1、粒度，指的是粗细程度。粒度大，就是说一个用例所涵盖的关注内容比较多，反之同理</p><p>2、用例的粒度大，则总的用例数就少，用例看起来也简洁</p><p>3、用例的粒度小，则单条用例关注的测试点很集中，不容易遗漏，并且执行需要的时间比较好估计</p><blockquote><p>==怎么提高/保证测试用例的覆盖度==</p><p>1）理解需求:完整性、准确性</p><p>2）测试设计点：测试设计的思路：</p><p><strong>划分功能项、正向功能验证、子功能项验证、功能交互、考虑隐形需求</strong></p><p>3）测试设计方法的合理使用：等价类、边界值、因果图、场景法</p><p>4)测试用例的评审和优化</p></blockquote><span id="more"></span><h1 id="4、测试用例-执行状态"><a href="#4、测试用例-执行状态" class="headerlink" title="4、测试用例==执行状态=="></a>4、测试用例==执行状态==</h1><p>启动条件：软件测试是在项目启动、需求分析开始时随之启动</p><p>结束条件：需求覆盖率、用例执行率、缺陷遗留率、达到预定质量目标</p><p>1、当用例还尚未被执行时，是<strong>No Test未执行状态</strong></p><p>2、当执行结果与预期结果相符时，是<strong>Pass通过状态</strong></p><p>3、当执行结果与预期结果不符时，是<strong>Fail失败状态</strong></p><p>4、当因为软件有缺陷而妨碍了用例步骤的执行，且该缺陷并不是我们的测试点，则用例是<strong>Block阻碍状态</strong></p><p>5、当用例正在执行中，但是需要耗较多时间去观察其结果，是<strong>Investigate观察中状态</strong></p><h1 id="5、不断优化测试用例"><a href="#5、不断优化测试用例" class="headerlink" title="5、不断优化测试用例"></a>5、不断优化测试用例</h1><p>1、测试用例并不可能一开始就写得很完美，可能也有写错的，可能也有遗漏的测试点</p><p>2、随着软件的版本不断更新，软件本身的需求和规格以及设计都可能在不断地变更</p><p>3、随着测试的不断开展，测试人员对产品的理解逐渐加深</p><p>基于上诉，就使得我们完全有理由在测试用例执行的过程中，同时不断地优化我们的测试用例，使得用例的质量越来越高</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、用例概念与构成要素&quot;&gt;&lt;a href=&quot;#1、用例概念与构成要素&quot; class=&quot;headerlink&quot; title=&quot;1、用例概念与构成要素&quot;&gt;&lt;/a&gt;1、用例概念与构成要素&lt;/h1&gt;&lt;h2 id=&quot;（1）概念&quot;&gt;&lt;a href=&quot;#（1）概念&quot; class=&quot;headerlink&quot; title=&quot;（1）概念&quot;&gt;&lt;/a&gt;（1）概念&lt;/h2&gt;&lt;p&gt;1、测试用例是一份测试文档，它描述&lt;strong&gt;输入、动作、和一个期望的结果&lt;/strong&gt;，其目的是确定应用程序的某个特性是否正常的工作。&lt;/p&gt;
&lt;p&gt;2、测试用例是软件测试团队的主要工作成果之一&lt;/p&gt;
&lt;p&gt;3、测试用例的质量与写该用例的测试人员的水平关系极大&lt;/p&gt;
&lt;p&gt;4、执行测试用例：当一个软件版本被测试时，测试人员会使用一整套的测试用例（或者筛选其中的一部分），将这些用例逐个在被测的软件上执行，并判断其结果是否和预期相符，并以此评价软件版本的质量&lt;/p&gt;
&lt;h2 id=&quot;（2）-构成要素&quot;&gt;&lt;a href=&quot;#（2）-构成要素&quot; class=&quot;headerlink&quot; title=&quot;（2）==构成要素==&quot;&gt;&lt;/a&gt;（2）==构成要素==&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;测试编号&lt;/strong&gt;：一般用英文+数字来组合：项目名称 _模块名称 _ 序号，例如: korei_shopMgt_001&lt;/p&gt;
&lt;p&gt;对应的&lt;strong&gt;功能模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试标题&lt;/strong&gt;：尽可能简洁明了无歧义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用例级别&lt;/strong&gt;：高:核心功能+正向用例；中:核心功能+反向用例、一般功能+正向用例；低:一般功能+反向用例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前置条件&lt;/strong&gt;：用例执行前需要什么条件，例如删除用户前确保该用户存在&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预期结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/05/17/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/image-20240518095715104.png&quot; alt=&quot;image-20240518095715104&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;2、测试用例的注意事项&quot;&gt;&lt;a href=&quot;#2、测试用例的注意事项&quot; class=&quot;headerlink&quot; title=&quot;2、测试用例的注意事项&quot;&gt;&lt;/a&gt;2、测试用例的注意事项&lt;/h1&gt;&lt;p&gt;1、用语简洁清晰，但不能过于简单&lt;/p&gt;
&lt;p&gt;2、用语无歧义，尽量少用过长的句子&lt;/p&gt;
&lt;p&gt;3、用例的各个基本要素要齐备，不能缺失&lt;/p&gt;
&lt;p&gt;4、用例的步骤应该足够详细，操作应该明确&lt;/p&gt;
&lt;p&gt;5、容易被其它测试工程师读懂，并能顺利执行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;==什么样的测试用例是高质量的用例/一份好的用例?==&lt;/p&gt;
&lt;p&gt;1）覆盖度高&lt;/p&gt;
&lt;p&gt;2）用例标题简洁明了，尽量少用长句，不能过于简单，无歧义&lt;/p&gt;
&lt;p&gt;3）用例的步骤要详尽&lt;/p&gt;
&lt;p&gt;4）可读性好：其他测试工程师容易读懂、容易执行，不容易遗漏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;3、测试用例的编写粒度&quot;&gt;&lt;a href=&quot;#3、测试用例的编写粒度&quot; class=&quot;headerlink&quot; title=&quot;3、测试用例的编写粒度&quot;&gt;&lt;/a&gt;3、测试用例的编写粒度&lt;/h1&gt;&lt;p&gt;1、粒度，指的是粗细程度。粒度大，就是说一个用例所涵盖的关注内容比较多，反之同理&lt;/p&gt;
&lt;p&gt;2、用例的粒度大，则总的用例数就少，用例看起来也简洁&lt;/p&gt;
&lt;p&gt;3、用例的粒度小，则单条用例关注的测试点很集中，不容易遗漏，并且执行需要的时间比较好估计&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;==怎么提高/保证测试用例的覆盖度==&lt;/p&gt;
&lt;p&gt;1）理解需求:完整性、准确性&lt;/p&gt;
&lt;p&gt;2）测试设计点：测试设计的思路：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;划分功能项、正向功能验证、子功能项验证、功能交互、考虑隐形需求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3）测试设计方法的合理使用：等价类、边界值、因果图、场景法&lt;/p&gt;
&lt;p&gt;4)测试用例的评审和优化&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试基础" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>需求评审</title>
    <link href="https://laylaycjl.github.io/2024/05/17/%E9%9C%80%E6%B1%82%E8%AF%84%E5%AE%A1/"/>
    <id>https://laylaycjl.github.io/2024/05/17/%E9%9C%80%E6%B1%82%E8%AF%84%E5%AE%A1/</id>
    <published>2024-05-17T02:32:20.000Z</published>
    <updated>2024-05-17T02:33:05.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、需求评审"><a href="#一、需求评审" class="headerlink" title="一、需求评审"></a>一、需求评审</h1><h2 id="1、软件需求-需求文档-原型图"><a href="#1、软件需求-需求文档-原型图" class="headerlink" title="1、软件需求 = 需求文档 + 原型图"></a>1、软件需求 = 需求文档 + 原型图</h2><p>需求文档：需求规格说明书</p><p>原型图：表达大致的需求，后续还有UI设计，再进行代码实现。例如：蓝湖（高效的产品设计协作平台）</p><p>参考：合同（用户需求）、合同附件-SOW（有更详细的需求）、跟客户的沟通交流</p><h2 id="2、需求评审目的"><a href="#2、需求评审目的" class="headerlink" title="2、需求评审目的"></a>2、需求评审目的</h2><ul><li><p>同步需求：产品经理把需求同步给项目组的所有成员</p></li><li><p>尽早测试，提前发现需求不足、错误、遗漏等</p></li></ul><h2 id="3、怎么评审？"><a href="#3、怎么评审？" class="headerlink" title="3、怎么评审？"></a>3、怎么评审？</h2><ul><li><p>产品经理组织需求评审会议，项目组所有成员都参加</p></li><li><p>产品经理宣讲需求，其他人听—》提出疑问—-》讨论—-》澄清，如果涉及到了需要修改的需求，产品经理统一更新需求文档新版本给项目组</p></li><li><p>后续开发和测试都以更新后的版本需求文档为准</p></li></ul><h2 id="4、从哪些方面评审？"><a href="#4、从哪些方面评审？" class="headerlink" title="4、从哪些方面评审？"></a>4、从哪些方面评审？</h2><ul><li>完整性检查：重点关注<strong>功能要求、数据定义、接口定义、性能要求、安全性要求、可靠性要求、系统约束</strong>等方面，同时还应关注是否覆盖开发人员遗漏的、系统<strong>隐含的需求</strong></li><li>准确性检查：对于需求的准确度，判断标准是<u>每一项测试需求都可以作为测试用例设计的依据</u></li></ul><span id="more"></span><h2 id="5、需求评审模拟"><a href="#5、需求评审模拟" class="headerlink" title="5、需求评审模拟"></a>5、需求评审模拟</h2><ul><li><p>例如：成都政府网站需要支持在线留言功能？</p></li><li><p>需求评审</p><ul><li><p>谁可以留言？注册用户、游客</p></li><li><p>留言的内容：什么样的格式？文本 or 图片or视频？文本（输入多少个字符？可以输入哪些字符？）、图片和视频（什么文件格式？文件大小？）</p></li><li><p>后台对留言版块的管理：能否回复？能否删除？后台能否分页显示？后台能否对留言分类统计？</p></li><li><p>支持多少人同时留言？性能如何？</p></li></ul></li></ul><h2 id="6、面试题"><a href="#6、面试题" class="headerlink" title="6、面试题"></a>6、面试题</h2><ul><li><p>你们的需求评审是怎么做的？</p></li><li><p>你们的需求文档什么格式？</p></li><li><p>在你的XX项目中，提出过建设性或高质量的需求问题吗？</p></li></ul><h2 id="7、项目：科睿教务管理系统需求评审"><a href="#7、项目：科睿教务管理系统需求评审" class="headerlink" title="7、项目：科睿教务管理系统需求评审"></a>7、项目：科睿教务管理系统需求评审</h2><ul><li><p>客户：科睿，针对青少年的机器人编程的培训公司。有十几家门店。它的主要部门：市场、销售、教学、公共部门</p></li><li><p>用户：门店管理员、市场、销售、教学、行政人员</p></li><li><p>市场部门：组织一些市场活动，获取线索（青少年的家长联系方式）；</p><p>下一步销售部门：根据市场部提供的线索，进行课程销售；</p></li><li><p>教学部门：主要负责课程研发、授课、课后的辅导；</p><p>行政前台：排课、学员管理等</p></li><li><p>客户的需求：开发一套教务管理系统，对公司的<strong>市场—-》销售—-》教学</strong>统一进行管理，对销售、学员等进行数据统计，方便管理者参考，进行管理</p></li><li><p>需求文档</p><ul><li><p>结构：</p><p>一、导言</p><p>二、项目介绍（项目背景、项目目标）</p><p>三、应用环境（网络环境、硬件环境）</p><p>四、功能规格</p><p>五、非功能规格</p><p>六、设计约束</p></li></ul></li><li><p>B/S架构</p><ul><li>浏览器/服务器：用户通过浏览器进行访问</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、需求评审&quot;&gt;&lt;a href=&quot;#一、需求评审&quot; class=&quot;headerlink&quot; title=&quot;一、需求评审&quot;&gt;&lt;/a&gt;一、需求评审&lt;/h1&gt;&lt;h2 id=&quot;1、软件需求-需求文档-原型图&quot;&gt;&lt;a href=&quot;#1、软件需求-需求文档-原型图&quot; class=&quot;headerlink&quot; title=&quot;1、软件需求 = 需求文档 + 原型图&quot;&gt;&lt;/a&gt;1、软件需求 = 需求文档 + 原型图&lt;/h2&gt;&lt;p&gt;需求文档：需求规格说明书&lt;/p&gt;
&lt;p&gt;原型图：表达大致的需求，后续还有UI设计，再进行代码实现。例如：蓝湖（高效的产品设计协作平台）&lt;/p&gt;
&lt;p&gt;参考：合同（用户需求）、合同附件-SOW（有更详细的需求）、跟客户的沟通交流&lt;/p&gt;
&lt;h2 id=&quot;2、需求评审目的&quot;&gt;&lt;a href=&quot;#2、需求评审目的&quot; class=&quot;headerlink&quot; title=&quot;2、需求评审目的&quot;&gt;&lt;/a&gt;2、需求评审目的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;同步需求：产品经理把需求同步给项目组的所有成员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽早测试，提前发现需求不足、错误、遗漏等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3、怎么评审？&quot;&gt;&lt;a href=&quot;#3、怎么评审？&quot; class=&quot;headerlink&quot; title=&quot;3、怎么评审？&quot;&gt;&lt;/a&gt;3、怎么评审？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;产品经理组织需求评审会议，项目组所有成员都参加&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;产品经理宣讲需求，其他人听—》提出疑问—-》讨论—-》澄清，如果涉及到了需要修改的需求，产品经理统一更新需求文档新版本给项目组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后续开发和测试都以更新后的版本需求文档为准&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;4、从哪些方面评审？&quot;&gt;&lt;a href=&quot;#4、从哪些方面评审？&quot; class=&quot;headerlink&quot; title=&quot;4、从哪些方面评审？&quot;&gt;&lt;/a&gt;4、从哪些方面评审？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;完整性检查：重点关注&lt;strong&gt;功能要求、数据定义、接口定义、性能要求、安全性要求、可靠性要求、系统约束&lt;/strong&gt;等方面，同时还应关注是否覆盖开发人员遗漏的、系统&lt;strong&gt;隐含的需求&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;准确性检查：对于需求的准确度，判断标准是&lt;u&gt;每一项测试需求都可以作为测试用例设计的依据&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试基础" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>测试设计方法</title>
    <link href="https://laylaycjl.github.io/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <id>https://laylaycjl.github.io/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</id>
    <published>2024-05-17T02:12:37.000Z</published>
    <updated>2024-05-18T01:54:19.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、测试设计概念"><a href="#一、测试设计概念" class="headerlink" title="一、测试设计概念"></a>一、测试设计概念</h1><ul><li>测试设计主要解决“测什么”的问题，即指明被测对象中什么需要测试</li><li>测试需求通常是以<strong>软件需求</strong>为基础进行分析，通过对需求的细化和分解，形成可测试的内容（测试点）</li><li>测试需求应全部覆盖已定义的<u>业务流程</u>，以及<strong>功能和非功能</strong>方面的需求</li></ul><h1 id="二、测试思路"><a href="#二、测试思路" class="headerlink" title="二、测试思路"></a>二、测试思路</h1><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517110238391.png" alt="image-20240517110238391" style="zoom:50%;"></p><h2 id="1、划分功能项"><a href="#1、划分功能项" class="headerlink" title="1、划分功能项"></a>1、划分功能项</h2><p>分析一个页面有哪些功能模块</p><p>例1：一个登录页面可以划分为5个子模块</p><p>关闭按钮、账号密码登录、海外手机号登录、验证码快捷登录、第三方登录</p><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517104305449.png" alt="image-20240517104305449" style="zoom:50%;"></p><p>例2：用户管理页面可以划分为7个子模块</p><p>退出用户管理、查询用户、添加用户、删除用户（勾选功能）、编辑用户、导出用户信息、分页展示</p><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517110620134.png" alt="image-20240517110620134" style="zoom:50%;"></p><h2 id="2、正向功能验证"><a href="#2、正向功能验证" class="headerlink" title="2、正向功能验证"></a>2、正向功能验证</h2><p>查看正常的操作下，功能是否能正确实现</p><p>例1：以账号密码登录这个子模块为例：</p><p>输入正确的手机号（邮箱）和密码，登录成功</p><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517104340164.png" alt="image-20240517104340164" style="zoom:50%;"></p><p>例2：</p><p>1）以用户管理页面的查询用户这个子模块为例</p><ul><li>输入正确的用户姓名和门店，可以成功查询到该用户</li></ul><p>2）以用户管理页面的删除用户这个子模块为例</p><ul><li>验证单个删除用户时弹出确认对话框，点击确认按钮后用户删除成功</li><li>验证单个删除用户时弹出确认对话框，点击取消按钮或X按钮不进行用户删除</li><li>验证选择1个或多个用户批量删除时弹出确认对话框，点击确认按钮后选中的用户删除成功</li><li>验证选择1个或多个用户批量删除时弹出确认对话框，点击取消按钮或X按钮后不进行删除选中的用户</li></ul><span id="more"></span><h2 id="3、-单个功能项验证"><a href="#3、-单个功能项验证" class="headerlink" title="3、==单个功能项验证=="></a>3、==单个功能项验证==</h2><p>对每个子模块划分出单个模块，进行单个功能验证，包括正常和异常两种情形</p><p>（1）对于输入框类的功能项，一般从四个方面去思考如何设计测试用例</p><ul><li><strong>数据长度验证</strong></li><li><strong>教据类型验证</strong></li><li><strong>是否必填验证</strong></li><li><strong>限制约束验证</strong></li></ul><p>（等价类、边界值）</p><p>（2）举例</p><p>例1：以账号这个输入框为例，可以如何设计测试用例</p><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517104933576.png" alt="image-20240517104933576" style="zoom:50%;"></p><p>有两种账号登录方式，手机、邮箱</p><ul><li><p>手机号</p><p>账号输入10位数字，输入符合要求的密码，点击登录——&gt;展示手机号错误</p><p>账号输入12位数字，输入符合要求的密码，点击登录——&gt;展示手机号错误</p><p>账号输入11位包含非数字，输入符合要求的密码，点击登录——&gt;提示用户名或者密码错误</p><p>账号输入未注册的手机号，输入符合要求的密码，点击登录——&gt;提示用户名或者密码错误</p><p>账号为空，输入符合要求的密码，点击登录——&gt;提示账号不能为空</p></li><li><p>邮箱<br>账号输入错误的邮箱格式，输入符合要求的密码，点击登录——&gt;提示用户名或者密码错误<br>输入没有注册的邮箱，输入符合要求的密码，点击登录——&gt;提示用户名或者密码错误</p></li></ul><p>例2：</p><p>1）以查询用户这个子模块为例，如何设计单个功能验证</p><ul><li>验证不输入姓名和门店，查询到所有用户</li><li>验证输入姓名的部分字段，可以模糊查询到姓名中包含这个字段的所有用户</li><li>验证输入不存在的用户姓名，查询不到用户信息</li><li>验证点击展开/收起按钮，能展开/收起查询条件框</li><li>验证点击重置按钮，清空查询条件</li></ul><p>2）以删除用户这个子模块为例，如何设计单个功能验证：</p><ul><li>验证没有选中用户将进行批量删除时，给出提示信息</li><li>验证管理员用户不能删除其他的管理员</li></ul><h2 id="4、功能之间交互验证"><a href="#4、功能之间交互验证" class="headerlink" title="4、功能之间交互验证"></a>4、功能之间交互验证</h2><p>例如第三方登录功能</p><h2 id="5、避免隐形需求"><a href="#5、避免隐形需求" class="headerlink" title="5、避免隐形需求"></a>5、避免隐形需求</h2><p>例如：</p><p>输入密码时展示为*</p><p>未勾选导出项目时，弹出提示：未勾选导出项目</p><h1 id="三、测试设计方法"><a href="#三、测试设计方法" class="headerlink" title="三、测试设计方法"></a>三、测试设计方法</h1><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240518094516507.png" alt="image-20240518094516507" style="zoom:50%;"></p><h2 id="1、等价类划分法（测单个输入域）"><a href="#1、等价类划分法（测单个输入域）" class="headerlink" title="1、等价类划分法（测单个输入域）"></a>1、等价类划分法（测单个输入域）</h2><p>打印机举例：</p><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517145011541.png" alt="image-20240517145011541"></p><p>等价类划分的办法是把程序的输入域划分成若干等价类，然后从每个部分中选取<strong>少数代表性数据</strong>当作测试输入数据，使用少数测试数据检验程序在一大类情况下的反映</p><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><ul><li><p>等价类：某个输入域的集合，在这个集合中每个输入条件都是等效的，如果其中一个的输入不能导致问题发生，那么集合中其它输入条件进行测试也是不可能发生错误</p></li><li><p>有效等价类：有效等价类指的是对程序的规范是有意义的、合理的输入数据所构成的集合（可以是一个也可以是多个）</p></li><li><p>无效等价类：指对程序的规范是不合理的或无意义的输入数据所构成的集合（至少有一个）</p></li></ul><h3 id="（2）等价类划分法使用举例"><a href="#（2）等价类划分法使用举例" class="headerlink" title="（2）等价类划分法使用举例"></a>（2）等价类划分法使用举例</h3><p>1）如果输入条件规定了<strong>取值范围</strong>或<strong>值的个数</strong>，则可确定<u>一个有效等价类</u>和<u>两个无效等价类</u></p><ul><li>例如：程序的输入项n满足“从1-999”<ul><li>有效等价类位“1&lt;=n&lt;=999”</li><li>无效等价类为“n&lt;1” 及“n&gt;999<!--1”--></li></ul></li></ul><p>2）输入条件规定了输入值的集合，或是规定了“<strong>必须如何</strong>”的条件，则可确定<u>一个有效等价类</u>和<u>一个无效等价类</u></p><ul><li>例如：某标识符，条件规定“以字母开头”<ul><li>“以字母开头”作为有效等价类</li><li>“以非字母开头”作为无效等价类</li></ul></li></ul><p>3）如果已划分的等价类中各元素在程序中的处理方式是不同的，则应将此等价类进一步划分成更小等价类</p><ul><li><p>例如：-10&lt;n&lt;10,且有算法m/n</p><p> 有效等价类（ -10,0 ）,（ 0，10 ）</p><p> 无效：&lt;=-10，&gt;=10，0</p></li></ul><p>4）在输入条件是一个<strong>布尔量</strong>的情况下，可以确定<u>一个有效等价类</u>和<u>一个无效等价类</u></p><ul><li>例如：界面输入只提供单选框，是与否</li></ul><h3 id="（3）根据等价类生成测试用例的原则"><a href="#（3）根据等价类生成测试用例的原则" class="headerlink" title="（3）根据等价类生成测试用例的原则"></a>（3）根据等价类生成测试用例的原则</h3><p>根据等价类表，然后从划分出的等价类中按以下三个原则设计测试用例</p><ul><li>为每一个等价类规定一个唯一的编号</li><li>设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地<strong>有效等价类</strong>，重复第一步，直到所有的有效等价类都被覆盖为止</li><li>设计一个新的测试用例，使其切覆盖一个尚未被覆盖的<strong>无效等价类</strong>，重复这一步，直到所有的无效等价类都被覆盖为止</li></ul><h3 id="（4）等价类划分的局限性"><a href="#（4）等价类划分的局限性" class="headerlink" title="（4）等价类划分的局限性"></a>（4）等价类划分的局限性</h3><ul><li>该方法孤立地考虑各个输入数据的测试功效，而没有考虑多个输入数据的组合效应，可能会遗漏了输入数据易于出错的组合情况，可以采用因果图设计法弥补上述不足</li><li>多个输入数据孤立的测试，导致测试用例数量非常庞大，不利于维护和执行，可以采用边界值法解决上述不足</li></ul><h2 id="2、边界值法（测单个输入域）"><a href="#2、边界值法（测单个输入域）" class="headerlink" title="2、边界值法（测单个输入域）"></a>2、边界值法（测单个输入域）</h2><p>边界分析法是列出单元功能、输入、状态及控制的<strong>合法边界值</strong>和<strong>非法边界值</strong>，设计测试用例，包含全部边界值的方法</p><h4 id="1）闭区间："><a href="#1）闭区间：" class="headerlink" title="1）闭区间："></a>1）闭区间：</h4><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517145522646.png" alt="image-20240517145522646" style="zoom:67%;"></p><p>例如：1&lt;=m&lt;=999</p><ul><li>上点：边界上的点（1,999）</li><li>内点：区间内的点（500）</li><li>离点：离边界值最近且与上点不属于同一等价类的点（0,1000）</li><li><strong>对于小数，没有离点，不可取</strong></li></ul><h4 id="2）半开区间："><a href="#2）半开区间：" class="headerlink" title="2）半开区间："></a>2）半开区间：</h4><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517145606252.png" alt="image-20240517145606252" style="zoom:67%;"></p><p>例如：1&lt;m&lt;=999</p><ul><li>上点：边界上的点（1,999）</li><li>内点：区间内的点（500）</li><li>离点：离边界值最近且与上点不属于同一等价类的点（2,1000）</li><li>对于小数，没有离点，不可取</li></ul><h4 id="3）开区间："><a href="#3）开区间：" class="headerlink" title="3）开区间："></a>3）开区间：</h4><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517145835613.png" alt="image-20240517145835613" style="zoom:67%;"></p><p>例如：1&lt;m&lt;999</p><ul><li>上点：边界上的点（1,999）</li><li>内点：区间内的点（500）</li><li>离点：离边界值最近且与上点不属于同一等价类的点（2,998）</li><li>对于小数，没有离点，不可取</li></ul><h2 id="3、错误猜测法（根据经验和直觉）"><a href="#3、错误猜测法（根据经验和直觉）" class="headerlink" title="3、错误猜测法（根据经验和直觉）"></a>3、错误猜测法（根据经验和直觉）</h2><ul><li><p>基于<strong>经验和直觉</strong>推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法</p></li><li><p>错误推测法的基本思想：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们设计测试用例</p></li></ul><h3 id="（1）错误推测法的常见依据"><a href="#（1）错误推测法的常见依据" class="headerlink" title="（1）错误推测法的常见依据"></a>（1）错误推测法的常见依据</h3><ul><li><p>在单元测试时理出的在模块中的常见错误</p></li><li><p>以前产品测试中曾经发现的错误</p></li><li><p>产品在客户实际使用过程中发现的错误</p><p>回溯流程（从产品、设计、开发、测试不同的角度进行分析、怎么引入、怎么避免再次出现类似的问题、改进措施)</p></li><li><p>容易发生错误的情况</p><p>例如：参数校验</p></li><li><p>一些公共模块，功能</p><p>模块之间的关联可能导致的bug</p></li><li><p>修复了bug的功能和模块</p><p>分析修改所产生的影响，进行推测</p></li></ul><h3 id="（2）常在测试用例评审中使用"><a href="#（2）常在测试用例评审中使用" class="headerlink" title="（2）常在测试用例评审中使用"></a>（2）常在测试用例评审中使用</h3><ul><li>猜错法充分发挥人的经验，在一个测试小组中集思广益，方便实用</li><li>组织测试小组（也可以有外来人员）进行错误猜测，是有效的测试方法</li></ul><h2 id="4、因果图法（多个条件组合）"><a href="#4、因果图法（多个条件组合）" class="headerlink" title="4、因果图法（多个条件组合）"></a>4、因果图法（多个条件组合）</h2><h3 id="（1）等价类划分的局限性"><a href="#（1）等价类划分的局限性" class="headerlink" title="（1）等价类划分的局限性"></a>（1）等价类划分的局限性</h3><ul><li>等价类没有考虑输入情况的组合，这样虽然各个输入条件单独可能出错的情况已经看到了，但多个输入情况组合起来可能出错的情况却被忽略</li><li>采用因果图方法能帮助我们考虑输入条件的联系、相互组合等情况</li></ul><h3 id="（2）因果图法概述"><a href="#（2）因果图法概述" class="headerlink" title="（2）因果图法概述"></a>（2）因果图法概述</h3><ul><li>分析需求规格说明中的描述中那些是原因，那些是结果，原因是输入条件，结果是输出条件</li><li>因果图最终生成判定表，它适合于程序输入条件的各种组合情况，如果有N个条件，每个条件有2个取值，那么将产生2的N次方条路径</li></ul><h3 id="（3）因果图法适用范围"><a href="#（3）因果图法适用范围" class="headerlink" title="（3）因果图法适用范围"></a>（3）因果图法适用范围</h3><p>如果在测试时考虑输入条件的各种组合，可使用一种适合于描述多种条件的组合，相应产生多个动作的形式来设计测试用例</p><h3 id="（4）如何生成测试用例"><a href="#（4）如何生成测试用例" class="headerlink" title="（4）如何生成测试用例"></a>（4）如何生成测试用例</h3><ul><li>分析程序规范描述中哪些是原因，哪些是结果（原因常常是输入条件或是输入条件等价类，结果是输出条件）</li><li>分析程序规范的描述中语义的内容，并将其表示成连接各个原因与各个结果的“因果图”</li><li>由于语法或环境的限制，有些原因和结果的组合情况是不可能出现的。为表明这些特定的情况，在因果图上使用特殊的符号标明约束条件。把因果图转换成判定表。==把判定表的每一列写成一个测试用例==</li></ul><h3 id="（5）判定表"><a href="#（5）判定表" class="headerlink" title="（5）判定表"></a>（5）判定表</h3><ul><li>判定表是分析和表达多条件下执行不同操作的情况下的工具</li></ul><h4 id="1）判定表的组成部分"><a href="#1）判定表的组成部分" class="headerlink" title="1）判定表的组成部分"></a>1）判定表的组成部分</h4><ul><li>条件桩：列出了问题的所有条件</li><li>动作桩：列出了问题规定可能采取的操作</li><li>条件项：列出特定条件的取值</li><li>动作项：列出在条件项目的各种取值情况下应该采取的动作</li></ul><h4 id="2）创建判定表的步骤"><a href="#2）创建判定表的步骤" class="headerlink" title="2）创建判定表的步骤"></a>2）创建判定表的步骤</h4><ul><li>确定规则的个数</li><li>列出所有的条件桩和动作桩</li><li>填入条件项</li><li>填入动作项</li><li>合并相似规则</li></ul><h4 id="3）判定表举例"><a href="#3）判定表举例" class="headerlink" title="3）判定表举例"></a>3）判定表举例</h4><p>需求：订购单的检查</p><p>如果金额超过500元且未过期，则发出批准单和提货单；若金额超过500元且已过期，则不发批准单和提货单；如果金额低于500元，则不论过期与否都发批准单和提货单，在过期的情况下还发出过期通知书</p><div class="table-container"><table><thead><tr><th>金额</th><th>大于等于500</th><th>大于等于500</th><th>小于500</th><th>小于500</th></tr></thead><tbody><tr><td>保质期</td><td>未过期</td><td>已过期</td><td>未过期</td><td>已过期</td></tr><tr><td>发出批准单</td><td>发</td><td></td><td>发</td><td>发</td></tr><tr><td>发出提货单</td><td>发</td><td></td><td>发</td><td>发</td></tr><tr><td>发出通知单</td><td></td><td></td><td></td><td>发</td></tr></tbody></table></div><h4 id="4）根据判定表导出测试用例"><a href="#4）根据判定表导出测试用例" class="headerlink" title="4）根据判定表导出测试用例"></a>4）根据判定表导出测试用例</h4><p>以大于等于500这一列为例，导出为测试用例</p><div class="table-container"><table><thead><tr><th>用例编号</th><th>ODER_CHECK_001</th></tr></thead><tbody><tr><td>测试项目</td><td>订购单检查</td></tr><tr><td>测试标题</td><td>验证系统金额小于500，未过期时系统发批准单和提货单</td></tr><tr><td>重要级别</td><td>高</td></tr><tr><td>预置条件</td><td>无</td></tr><tr><td>输入</td><td>499</td></tr><tr><td>操作步骤</td><td>1、输入金额：499； 2、选择未过期；3、点击确定</td></tr><tr><td>预期输出</td><td>发出批准单和提货单</td></tr></tbody></table></div><h2 id="5、场景法（测功能和业务流程）"><a href="#5、场景法（测功能和业务流程）" class="headerlink" title="5、场景法（测功能和业务流程）"></a>5、场景法（测功能和业务流程）</h2><ul><li>运用场景来对系统的<strong>功能点</strong>或<strong>业务流程</strong>的描述，从而提高测试效果的一种方法</li><li>模拟特定场景发生的事情，通过事件来触发某个动作的发生，观察事件的最终结果，从而用来发现软件存在的问题</li></ul><h3 id="（1）场景法路径"><a href="#（1）场景法路径" class="headerlink" title="（1）场景法路径"></a>（1）场景法路径</h3><p>场景法一般包括<strong>基本流</strong>和<strong>备选流</strong>。从一个流程开始，图中经过用例的每条路径都可以用基本流和备选流来表示。（基本流，是经过用例的最简单路径）</p><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240518093426262.png" alt="image-20240518093426262" style="zoom:50%;"></p><h3 id="（2）场景法设计步骤"><a href="#（2）场景法设计步骤" class="headerlink" title="（2）场景法设计步骤"></a>（2）场景法设计步骤</h3><ul><li><p>根据说明，描述出程序的基本流及各项备选流</p></li><li><p>根据基本流和各项备选流生成不同的场景</p></li><li><p><strong>对每一个场景生成相应的测试用例</strong></p></li><li><p>对生成的所有测试用例重新复审，去掉多余的测试用例，测试用例确定后，对每一个测试用例确定测试数据值</p></li></ul><h3 id="（3）流程图"><a href="#（3）流程图" class="headerlink" title="（3）流程图"></a>（3）流程图</h3><p><img src="/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240518094038029.png" alt="image-20240518094038029" style="zoom: 67%;"></p><h3 id="（4）测试用例"><a href="#（4）测试用例" class="headerlink" title="（4）测试用例"></a>（4）测试用例</h3><div class="table-container"><table><thead><tr><th>用例编号</th><th>TC_LOGIN_001</th></tr></thead><tbody><tr><td>测试项目</td><td>项目登录</td></tr><tr><td>测试标题</td><td>验证系统输入合法用户名和密码正常登录</td></tr><tr><td>重要级别</td><td>高</td></tr><tr><td>预置条件</td><td>系统数据库内存在该用户名及密码</td></tr><tr><td>输入</td><td>用户名：A1， Aa1-Bb2_Cc3.Dd4E ; <br>密码：000000， 999999.</td></tr><tr><td>操作步骤</td><td>1、启动系统<br>2、分别输入用户名：A1， Aa1-Bb2_Cc3.Dd4E   <br>3、输入密码：100000， 999999999  <br>4、点击确定</td></tr><tr><td>预期输出</td><td>进入系统</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、测试设计概念&quot;&gt;&lt;a href=&quot;#一、测试设计概念&quot; class=&quot;headerlink&quot; title=&quot;一、测试设计概念&quot;&gt;&lt;/a&gt;一、测试设计概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;测试设计主要解决“测什么”的问题，即指明被测对象中什么需要测试&lt;/li&gt;
&lt;li&gt;测试需求通常是以&lt;strong&gt;软件需求&lt;/strong&gt;为基础进行分析，通过对需求的细化和分解，形成可测试的内容（测试点）&lt;/li&gt;
&lt;li&gt;测试需求应全部覆盖已定义的&lt;u&gt;业务流程&lt;/u&gt;，以及&lt;strong&gt;功能和非功能&lt;/strong&gt;方面的需求&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;二、测试思路&quot;&gt;&lt;a href=&quot;#二、测试思路&quot; class=&quot;headerlink&quot; title=&quot;二、测试思路&quot;&gt;&lt;/a&gt;二、测试思路&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517110238391.png&quot; alt=&quot;image-20240517110238391&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、划分功能项&quot;&gt;&lt;a href=&quot;#1、划分功能项&quot; class=&quot;headerlink&quot; title=&quot;1、划分功能项&quot;&gt;&lt;/a&gt;1、划分功能项&lt;/h2&gt;&lt;p&gt;分析一个页面有哪些功能模块&lt;/p&gt;
&lt;p&gt;例1：一个登录页面可以划分为5个子模块&lt;/p&gt;
&lt;p&gt;关闭按钮、账号密码登录、海外手机号登录、验证码快捷登录、第三方登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517104305449.png&quot; alt=&quot;image-20240517104305449&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;例2：用户管理页面可以划分为7个子模块&lt;/p&gt;
&lt;p&gt;退出用户管理、查询用户、添加用户、删除用户（勾选功能）、编辑用户、导出用户信息、分页展示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517110620134.png&quot; alt=&quot;image-20240517110620134&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、正向功能验证&quot;&gt;&lt;a href=&quot;#2、正向功能验证&quot; class=&quot;headerlink&quot; title=&quot;2、正向功能验证&quot;&gt;&lt;/a&gt;2、正向功能验证&lt;/h2&gt;&lt;p&gt;查看正常的操作下，功能是否能正确实现&lt;/p&gt;
&lt;p&gt;例1：以账号密码登录这个子模块为例：&lt;/p&gt;
&lt;p&gt;输入正确的手机号（邮箱）和密码，登录成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/05/17/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/image-20240517104340164.png&quot; alt=&quot;image-20240517104340164&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;例2：&lt;/p&gt;
&lt;p&gt;1）以用户管理页面的查询用户这个子模块为例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入正确的用户姓名和门店，可以成功查询到该用户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2）以用户管理页面的删除用户这个子模块为例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证单个删除用户时弹出确认对话框，点击确认按钮后用户删除成功&lt;/li&gt;
&lt;li&gt;验证单个删除用户时弹出确认对话框，点击取消按钮或X按钮不进行用户删除&lt;/li&gt;
&lt;li&gt;验证选择1个或多个用户批量删除时弹出确认对话框，点击确认按钮后选中的用户删除成功&lt;/li&gt;
&lt;li&gt;验证选择1个或多个用户批量删除时弹出确认对话框，点击取消按钮或X按钮后不进行删除选中的用户&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试基础" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>测试计划</title>
    <link href="https://laylaycjl.github.io/2024/05/16/%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/"/>
    <id>https://laylaycjl.github.io/2024/05/16/%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/</id>
    <published>2024-05-16T15:40:22.000Z</published>
    <updated>2024-05-17T06:03:23.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1项目概述"><a href="#1-1项目概述" class="headerlink" title="1.1项目概述"></a>1.1项目概述</h2><h2 id="1-2目的和范围"><a href="#1-2目的和范围" class="headerlink" title="1.2目的和范围"></a>1.2目的和范围</h2><p>编写目的：本文档涵盖了测试目的、测试计划、人员安排、风险分析以及测试进度等内容，为后续的测试工作提供更清晰的流程，确保测试工作有效地进行。</p><p>适用范围：本文档适用于本项目的整个测试流程和回归测试。</p><h2 id="1-3定义、首字母缩写词和缩略语"><a href="#1-3定义、首字母缩写词和缩略语" class="headerlink" title="1.3定义、首字母缩写词和缩略语"></a>1.3定义、首字母缩写词和缩略语</h2><div class="table-container"><table><thead><tr><th>缩写、术语</th><th>解释</th></tr></thead><tbody><tr><td>缺陷定义</td><td>已经实现的功能与它对应的需求不一致，即交付工作产品未能正确完成需求所要求的功能</td></tr><tr><td>缺陷密度</td><td>缺陷数与代码量的比值</td></tr><tr><td>边界值法</td><td>等价值法的合理补充，指输入或输出的边界（大于、小于1或无限接近、小范围内的值）或者说刚刚达到、刚刚超过规定值</td></tr><tr><td>优先级</td><td>这里指测试用例的优先级，在测试执行过程中，优先级越高的用例要先执行<br>1)高：所涉及的功能影响很大，阻碍性的、流程性的用例。例如登陆按钮不可用<br>2)中：跟大的功能点有关，已经会阻碍少部分用例的执行。例如新增按钮，如不能通过，很多功能都不可测试 <br>3)低：UI样式和建议等，例如小的UI的问题，位置，大小，验证，建议等等</td></tr><tr><td>缺陷严重程度</td><td>1、<strong>致命</strong>：导致系统无法为用户提供服务。包括：  a)     由于程序所引起的死机，非法退出，死循环；  b)     关键性、核心功能未实现或实现错误，无法正常执行；  c)     数据库发生死锁；  d)     因错误操作导致的程序中断；  e)     功能错误；  f)     与数据库连接错误；  g)     数据通讯错误；  <br>2、<strong>严重</strong>：严重地影响系统要求或基本功能的实现。包括：  a)     程序错误；  b)     程序接口错误；  c)     严重的数值计算错误；  d)     关键功能实现有偏差；  e)     用户可越权操作（安全性问题），包括非法用户可访问系统、修改数据、POST非法数据等。  f)     数据库的表、业务规则、缺省值未加完整性等约束条件  <br>3、<strong>一般</strong>：使操作者不方便或遇到麻烦，但它不影响执行工作功能或重要功能。影响程度小，但属软件、功能、业务上的缺陷/遗漏等。包括：  a)     操作界面错误（包括数据窗口内列名定义、含义是否一致）；  b)     页面提示信息乱码（非一般用户能识别的，非标准页面编码）；  c)     打印内容、格式错误；  d)     显示报表数据错误，如显示错位；  e)     Js错误（不影响业务流程的）；  f)     简单的输入限制未放在前台进行控制；  g)     系统边界值引起轻微错误。  h)     数据库表中有过多的空字段<br>4、<strong>提示</strong>：操作者认为操作不合理或操作不方便或操作麻烦。在已经正确实现功能的基础上，改进与优化，增强用户体验等。包括：    a)     界面颜色、排版，非关键性文字错误；  b)     辅助说明描述不清楚；  c)     显示格式不规范、查询报告格式错误；  d)     长时间操作未给用户进度提示；  e)     提示窗口文字未采用行业术语；  f)     删除等操作成功与否未给出提示；  g)     系统操作不方便；  h)     数据格式化问题，如千分位统一用半角逗号、取小数点后两位等；  i)      系统一致性问题，如提示用语、类似功能相关执行过程；  j)     系统处理未优化。</td></tr><tr><td>QA</td><td>质量监管人员</td></tr><tr><td>Korei</td><td>科睿</td></tr><tr><td>CRM</td><td>Customers Relation Management 客户关系管理系统</td></tr></tbody></table></div><h2 id="1-4测试通过准则"><a href="#1-4测试通过准则" class="headerlink" title="1.4测试通过准则"></a>1.4测试通过准则</h2><h3 id="1）测试充分性"><a href="#1）测试充分性" class="headerlink" title="1）测试充分性"></a>1）测试充分性</h3><p>​    a.用例已全面覆盖需求：测试用例覆盖率一般要求达到100%。</p><p>​    b.原则上要求所有用例都100%执行，即优先级高、中、低的用例都必须100%执行。</p><p>​    c.工作投入充分性：项目测试工作要充分投入，保障测试投入的合理性。</p><h3 id="2）测试有效性"><a href="#2）测试有效性" class="headerlink" title="2）测试有效性"></a>2）测试有效性</h3><p>​    a.严重程度及以上的缺陷解决率必须达到100%。</p><p>​    b.一般和轻微缺陷遗留率低于5%。    </p><p>​    c.相关责任部门认可测试结果,包括客户的试用、验收测试等。</p><span id="more"></span><h2 id="1-5读者对象"><a href="#1-5读者对象" class="headerlink" title="1.5读者对象"></a>1.5读者对象</h2><p>本项目的测试工程师 </p><p>本项目的测试经理</p><p>本项目的开发人员 </p><p>本项目的开发经理</p><p>本项目的QA</p><p>本项目的项目经理</p><h2 id="1-6测试参考资料"><a href="#1-6测试参考资料" class="headerlink" title="1.6测试参考资料"></a>1.6测试参考资料</h2><div class="table-container"><table><thead><tr><th>资料名称</th><th>责任人</th><th>应交付日期</th></tr></thead><tbody><tr><td>《象过河进销存软件项目用户==需求说明书==》</td><td>张三</td><td>2024-10-08</td></tr><tr><td>《象过河进销存软件项目==概要设计说明书==》</td><td>张三</td><td>2024-10-14</td></tr><tr><td>《象过河进销存软件项目==详细设计说明书==》</td><td>张三</td><td>2024-10-25</td></tr></tbody></table></div><h2 id="1-7测试交付件"><a href="#1-7测试交付件" class="headerlink" title="1.7测试交付件"></a>1.7测试交付件</h2><div class="table-container"><table><thead><tr><th>交互件名称</th><th>责任人</th><th>应交付日期</th></tr></thead><tbody><tr><td>《象过河进销存软件项目==测试计划==》</td><td>张三</td><td>2024-11-13</td></tr><tr><td>《象过河进销存软件项目==测试设计==》</td><td>张三、李四</td><td>2024-11-27</td></tr><tr><td>《象过河进销存软件项目==测试用例==》</td><td>张三、李四</td><td>2024-12-22</td></tr><tr><td>《象过河进销存软件项目==测试执行bug单==》</td><td>张三</td><td>2025-02-10</td></tr><tr><td>《象过河进销存软件项目==测试报告==》</td><td>张三</td><td>2025-02-11</td></tr></tbody></table></div><h1 id="2、测试需求分析"><a href="#2、测试需求分析" class="headerlink" title="2、测试需求分析"></a>2、测试需求分析</h1><h2 id="2-1测试目标"><a href="#2-1测试目标" class="headerlink" title="2.1测试目标"></a>2.1测试目标</h2><p>验证系统是否实现需求规格中要求的功能，是否满足用户的明确需求和隐含需求，系统可以按计划发布</p><h1 id="3、测试策略"><a href="#3、测试策略" class="headerlink" title="3、测试策略"></a>3、测试策略</h1><h2 id="3-1-功能测试"><a href="#3-1-功能测试" class="headerlink" title="3.1==功能测试=="></a>3.1==功能测试==</h2><div class="table-container"><table><thead><tr><th><strong>测试目标</strong></th><th>测试各功能模块是否满足需求。</th></tr></thead><tbody><tr><td><strong>测试范围</strong></td><td>【系统菜单】【工具栏】【采购管理】【销售管理】【库存管理】【财务管理】【基本信息】功能模块的测试</td></tr><tr><td><strong>方法</strong></td><td>1.针对各个功能点使用有效数据时得到预期的结果；  <br>2.针对各个功能点在使用无效数据时显示相应的错误或警告消息；  <br>3.各业务规则得到了正确的执行。</td></tr><tr><td><strong>完成标准</strong></td><td>1.所计划的测试点和测试用例已全部覆盖；  <br>2.在测试过程中发现的Bug已全部记录下来。</td></tr><tr><td><strong>需考虑的特殊事项</strong></td></tr></tbody></table></div><h2 id="3-2安全性测试"><a href="#3-2安全性测试" class="headerlink" title="3.2安全性测试"></a>3.2安全性测试</h2><div class="table-container"><table><thead><tr><th><strong>测试目标</strong></th><th>核实以下内容：  系统安全性，不同用户的操作权限。</th></tr></thead><tbody><tr><td><strong>方法</strong></td><td>用正常用户和非法用户是否正常登录系统，用户登录后超出一定时间没操作，是否自动退出。</td></tr><tr><td><strong>完成标准</strong></td><td>各种已知的角色类型都可访问相应的功能而且都按照预期的方式运行。</td></tr><tr><td><strong>需考虑的特殊事项</strong></td><td>在同一台测试机器上测试不同用户登录，留意cache以及session对切换用户登录的影响。测试session过期后系统的处理。</td></tr></tbody></table></div><h2 id="3-3-兼容性测试"><a href="#3-3-兼容性测试" class="headerlink" title="3.3==兼容性测试=="></a>3.3==兼容性测试==</h2><div class="table-container"><table><thead><tr><th><strong>测试目标</strong></th><th>验证软件在主流系统下能否正常工作：  Windows XP、2003、7及以上版本</th></tr></thead><tbody><tr><td><strong>方法</strong></td><td>在以上系统下分别测试新增、修改、删除等功能是否兼容。</td></tr><tr><td><strong>完成标准</strong></td><td>软件正常工作，没有Medium级别及以上的缺陷，或者发现的错误被修改。</td></tr></tbody></table></div><h2 id="3-4-回归测试"><a href="#3-4-回归测试" class="headerlink" title="3.4==回归测试=="></a>3.4==回归测试==</h2><div class="table-container"><table><thead><tr><th><strong>测试目标</strong></th><th>在程序有修改情况下保证原有整个软件系统功能正常。</th></tr></thead><tbody><tr><td><strong>方法</strong></td><td>重点测试Bug修改，Bug修改关联模块，新增功能，重点模块，时间允许的情况下测试全部用例。</td></tr><tr><td><strong>完成标准</strong></td><td>软件系统功能正常，没有“一般”级别及以上的缺陷。</td></tr><tr><td><strong>需考虑的特殊事项</strong></td><td>如果系统在回归测试期间发现“一般”级别及以上的缺陷，需要重新构建候选版本，并在新的候选版本上重新回归，直到系统稳定运行。</td></tr></tbody></table></div><h2 id="3-5可靠性测试"><a href="#3-5可靠性测试" class="headerlink" title="3.5可靠性测试"></a>3.5可靠性测试</h2><div class="table-container"><table><thead><tr><th><strong>测试目标</strong></th><th>测试其在反复点击按钮和注册不同的用户时, 是否会出现错误</th></tr></thead><tbody><tr><td><strong>方法</strong></td><td>反复点击”注册”, “登录”,是否会发生错误;  注册大量不同的合法用户名,  是否会出错.</td></tr><tr><td><strong>完成标准</strong></td><td>所有反复点击测试, 注册不同合法用户后都可正常操作</td></tr><tr><td><strong>需考虑的特殊事项</strong></td></tr></tbody></table></div><h2 id="3-6集成测试"><a href="#3-6集成测试" class="headerlink" title="3.6集成测试"></a>3.6集成测试</h2><div class="table-container"><table><thead><tr><th><strong>测试目标</strong></th><th>检测需求中业务流程，数据流的正确性；需求中明确的业务流程，或组合不同功能模块而形成一个大的功能。</th></tr></thead><tbody><tr><td><strong>方法</strong></td><td>利用有效的和无效的数据来执行各个用例、用例流或功能，以核实以下内容：  在使用有效数据时得到预期的结果。  在使用无效数据时显示相应的错误消息或警告消息。  各业务规则都得到了正确的应用。  各种可能的业务流程符合预期的结果。</td></tr><tr><td><strong>完成标准</strong></td><td>所计划的测试已全部执行。  所发现的缺陷已全部解决<em>。</em></td></tr><tr><td><strong>需考虑的特殊事项</strong></td><td>各功能模块间的衔接以及数据传递</td></tr></tbody></table></div><h2 id="3-7易用性测试"><a href="#3-7易用性测试" class="headerlink" title="3.7易用性测试"></a>3.7易用性测试</h2><div class="table-container"><table><thead><tr><th><strong>测试目标</strong></th><th>检查应用程序的使用是否有难度，是否有异义</th></tr></thead><tbody><tr><td><strong>测试范围</strong></td><td>所有界面</td></tr><tr><td><strong>测试技术</strong></td><td>对所有界面进行测试，操作顺畅，理解直观，无难懂操作</td></tr><tr><td><strong>开始标准</strong></td><td>功能测试过程中</td></tr><tr><td><strong>完成标准</strong></td><td>应用程序操作无异义</td></tr><tr><td><strong>测试重点和优先级</strong></td><td>应用程序操作无异义</td></tr><tr><td><strong>需考虑的特殊事项</strong></td><td>站在用户角度理解程序操作</td></tr></tbody></table></div><h2 id="3-8用户界面测试"><a href="#3-8用户界面测试" class="headerlink" title="3.8用户界面测试"></a>3.8用户界面测试</h2><div class="table-container"><table><thead><tr><th><strong>测试目标</strong></th><th>通过以下内容来验证：  <br>1、通过浏览测试对象可正确反映业务的功能和需求，这种浏览包括窗口与窗口之间、字段与字段之间的浏览，以及各种访问方法（Tab 健、鼠标移动和快捷键）的使用<br>2、窗口的对象和特征（例如：菜单、大小、位置、状态和中心）都符合标准。测试系统的界面和对话框，可正确反映业务的功能和需求，这种测试包括界面整体测试和界面元素测试，整体测试包括规范性测试、合理性测试、一致性测试、界面定制性测试，界面元素测试包括窗口测试、菜单测试、图标测试、鼠标测试</th></tr></thead><tbody><tr><td><strong>测试范围</strong></td><td>所有界面</td></tr><tr><td><strong>测试技术</strong></td><td>对每个窗口进行测试，以核实各个应用程序窗口和对象都可正确地进行浏览、切换，并处于正常的对象状态。</td></tr><tr><td><strong>开始标准</strong></td><td>与功能测试同时进行</td></tr><tr><td><strong>完成标准</strong></td><td>用户界面符合需求</td></tr><tr><td><strong>测试重点和优先级</strong></td><td>重点是主要业务流程展示页面</td></tr><tr><td><strong>需考虑的特殊事项</strong></td><td>准备界面检查单</td></tr></tbody></table></div><h2 id="3-9-文档测试"><a href="#3-9-文档测试" class="headerlink" title="3.9==文档测试=="></a>3.9==文档测试==</h2><div class="table-container"><table><thead><tr><th><strong>测试目标</strong></th><th>通过测试产品相关文档，提高文档的质量</th></tr></thead><tbody><tr><td><strong>测试范围</strong></td><td>用户文档（用户手册、操作手册）、测试文档（测试计划、测试用例、测试总结报告）、管理文档（例会记录、工作日志）</td></tr><tr><td><strong>测试技术</strong></td><td>对每份文档进行测试，保证文档的正确性</td></tr><tr><td><strong>开始标准</strong></td><td>测试整个周期</td></tr><tr><td><strong>完成标准</strong></td><td>文档正确</td></tr><tr><td><strong>测试重点和优先级</strong></td><td>不同阶段的文档符合文档要求规范</td></tr><tr><td><strong>需考虑的特殊事项</strong></td><td>不同人测试，提高准确度</td></tr></tbody></table></div><h1 id="4、测试计划"><a href="#4、测试计划" class="headerlink" title="4、测试计划"></a>4、测试计划</h1><h2 id="4-1资源需求"><a href="#4-1资源需求" class="headerlink" title="4.1资源需求"></a>4.1资源需求</h2><h3 id="4-1-1硬件环境"><a href="#4-1-1硬件环境" class="headerlink" title="4.1.1硬件环境"></a>4.1.1硬件环境</h3><div class="table-container"><table><thead><tr><th><strong>资源名称</strong></th><th><strong>资源项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>测试硬件环境</td><td>硬件配置</td><td>CPU：Intel（R）Core（TM）2 Duo  <br>内存：2G   <br>硬盘：80G  <br>网络：局域网100M</td></tr></tbody></table></div><h3 id="4-1-2软件环境"><a href="#4-1-2软件环境" class="headerlink" title="4.1.2软件环境"></a>4.1.2软件环境</h3><div class="table-container"><table><thead><tr><th><strong>资源名称</strong></th><th><strong>资源项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>测试应用软件</td><td>操作系统</td><td>Windows XP</td></tr><tr><td></td><td>数据库</td><td>数据库FireBird</td></tr></tbody></table></div><h3 id="4-1-3人员需求"><a href="#4-1-3人员需求" class="headerlink" title="4.1.3人员需求"></a>4.1.3人员需求</h3><div class="table-container"><table><thead><tr><th>角色</th><th>姓名</th><th>数量</th><th>职责描述</th></tr></thead><tbody><tr><td>测试组长</td><td>张三</td><td>1</td><td>负责完成测试需求分析，编写测试计划和测试报告，组织测试工作。</td></tr><tr><td>测试工程师</td><td>李四，王五</td><td>2</td><td>编写测试用例，执行测试用例，找出系统存在的缺陷并报告。</td></tr></tbody></table></div><h2 id="4-2过程条件"><a href="#4-2过程条件" class="headerlink" title="4.2过程条件"></a>4.2过程条件</h2><h3 id="4-2-1启动条件"><a href="#4-2-1启动条件" class="headerlink" title="4.2.1启动条件"></a>4.2.1启动条件</h3><p>测试用例、测试代码准备完成，冒烟测试通过，测试环境搭建完毕</p><h3 id="4-2-2结束条件（参考通过准则"><a href="#4-2-2结束条件（参考通过准则" class="headerlink" title="4.2.2结束条件（参考通过准则)"></a>4.2.2结束条件（参考通过准则)</h3><p>所有测试用例全部执行，版本稳定，达到预定质量目标</p><h2 id="4-3进度计划"><a href="#4-3进度计划" class="headerlink" title="4.3进度计划"></a>4.3进度计划</h2><h3 id="4-3-1测试周期"><a href="#4-3-1测试周期" class="headerlink" title="4.3.1测试周期"></a>4.3.1测试周期</h3><p>多少个工作日，何时开始，何时结束</p><h3 id="4-3-2人力投入"><a href="#4-3-2人力投入" class="headerlink" title="4.3.2人力投入"></a>4.3.2人力投入</h3><p>几个人工作几天</p><h3 id="4-3-3任务分配及进度"><a href="#4-3-3任务分配及进度" class="headerlink" title="4.3.3任务分配及进度"></a>4.3.3任务分配及进度</h3><p>分配任务和各自的工作周期安排</p><h1 id="5、相关约束"><a href="#5、相关约束" class="headerlink" title="5、相关约束"></a>5、相关约束</h1><h2 id="5-1研发流程"><a href="#5-1研发流程" class="headerlink" title="5.1研发流程"></a>5.1研发流程</h2><p>迭代模型</p><h2 id="5-2-Bug流程"><a href="#5-2-Bug流程" class="headerlink" title="5.2 Bug流程"></a>5.2 Bug流程</h2><p><img src="/2024/05/16/%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/clip_image002.jpg" alt="img" style="zoom:50%;"></p><h1 id="6、风险分析"><a href="#6、风险分析" class="headerlink" title="6、风险分析"></a>6、风险分析</h1><div class="table-container"><table><thead><tr><th><strong>序号</strong></th><th><strong>风险描述</strong></th><th><strong>规避措施</strong></th><th><strong>责任人</strong></th></tr></thead><tbody><tr><td>1</td><td>测试时间短导致测试用例覆盖不全面</td><td>与PM申请更多测试时间，</td><td>PM</td></tr><tr><td>2</td><td>测试人力不足导致测试进度滞后</td><td>与PM沟通  1）建议再增加2-3名测试，或到后期调用公司技术支持、市场、财务等人员进行全员测试  2）适当推迟产品上市时间</td><td>PM</td></tr><tr><td>3</td><td>客户需求更改导致工作计划被打乱</td><td>提出双赢的解决办法</td><td>产品人员</td></tr><tr><td>4</td><td>开发部门不能按时发布版本，导致测试周期缩短</td><td>要求开发人员赶工</td><td>开发人员</td></tr><tr><td>5</td><td>质量标准不统一，某些优先级方面，测试与研发意见不统一</td><td>QA制定出统一标准</td><td>QA</td></tr><tr><td>6</td><td>测试人员经验不足导致测试结果分析不全面</td><td>多组织培训、多进行技术、经验交流</td><td>测试总监</td></tr><tr><td>7</td><td>设计文档不全导致测试设计不准确</td><td>多与开发人员沟通</td><td>开发人员</td></tr><tr><td>8</td><td>市场上同类竞争产品较多，且更新升级速度较快</td><td>1）充分做好市场调研，明确竞争对手的优势、劣势  2）产品正确定位，明确目标客户群体</td><td>产品人员</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot; class=&quot;headerlink&quot; title=&quot;1、概述&quot;&gt;&lt;/a&gt;1、概述&lt;/h1&gt;&lt;h2 id=&quot;1-1项目概述&quot;&gt;&lt;a href=&quot;#1-1项目概述&quot; class=&quot;headerlink&quot; title=&quot;1.1项目概述&quot;&gt;&lt;/a&gt;1.1项目概述&lt;/h2&gt;&lt;h2 id=&quot;1-2目的和范围&quot;&gt;&lt;a href=&quot;#1-2目的和范围&quot; class=&quot;headerlink&quot; title=&quot;1.2目的和范围&quot;&gt;&lt;/a&gt;1.2目的和范围&lt;/h2&gt;&lt;p&gt;编写目的：本文档涵盖了测试目的、测试计划、人员安排、风险分析以及测试进度等内容，为后续的测试工作提供更清晰的流程，确保测试工作有效地进行。&lt;/p&gt;
&lt;p&gt;适用范围：本文档适用于本项目的整个测试流程和回归测试。&lt;/p&gt;
&lt;h2 id=&quot;1-3定义、首字母缩写词和缩略语&quot;&gt;&lt;a href=&quot;#1-3定义、首字母缩写词和缩略语&quot; class=&quot;headerlink&quot; title=&quot;1.3定义、首字母缩写词和缩略语&quot;&gt;&lt;/a&gt;1.3定义、首字母缩写词和缩略语&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;缩写、术语&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;缺陷定义&lt;/td&gt;
&lt;td&gt;已经实现的功能与它对应的需求不一致，即交付工作产品未能正确完成需求所要求的功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺陷密度&lt;/td&gt;
&lt;td&gt;缺陷数与代码量的比值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;边界值法&lt;/td&gt;
&lt;td&gt;等价值法的合理补充，指输入或输出的边界（大于、小于1或无限接近、小范围内的值）或者说刚刚达到、刚刚超过规定值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;优先级&lt;/td&gt;
&lt;td&gt;这里指测试用例的优先级，在测试执行过程中，优先级越高的用例要先执行&lt;br&gt;1)高：所涉及的功能影响很大，阻碍性的、流程性的用例。例如登陆按钮不可用&lt;br&gt;2)中：跟大的功能点有关，已经会阻碍少部分用例的执行。例如新增按钮，如不能通过，很多功能都不可测试 &lt;br&gt;3)低：UI样式和建议等，例如小的UI的问题，位置，大小，验证，建议等等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺陷严重程度&lt;/td&gt;
&lt;td&gt;1、&lt;strong&gt;致命&lt;/strong&gt;：导致系统无法为用户提供服务。包括：  a)     由于程序所引起的死机，非法退出，死循环；  b)     关键性、核心功能未实现或实现错误，无法正常执行；  c)     数据库发生死锁；  d)     因错误操作导致的程序中断；  e)     功能错误；  f)     与数据库连接错误；  g)     数据通讯错误；  &lt;br&gt;2、&lt;strong&gt;严重&lt;/strong&gt;：严重地影响系统要求或基本功能的实现。包括：  a)     程序错误；  b)     程序接口错误；  c)     严重的数值计算错误；  d)     关键功能实现有偏差；  e)     用户可越权操作（安全性问题），包括非法用户可访问系统、修改数据、POST非法数据等。  f)     数据库的表、业务规则、缺省值未加完整性等约束条件  &lt;br&gt;3、&lt;strong&gt;一般&lt;/strong&gt;：使操作者不方便或遇到麻烦，但它不影响执行工作功能或重要功能。影响程度小，但属软件、功能、业务上的缺陷/遗漏等。包括：  a)     操作界面错误（包括数据窗口内列名定义、含义是否一致）；  b)     页面提示信息乱码（非一般用户能识别的，非标准页面编码）；  c)     打印内容、格式错误；  d)     显示报表数据错误，如显示错位；  e)     Js错误（不影响业务流程的）；  f)     简单的输入限制未放在前台进行控制；  g)     系统边界值引起轻微错误。  h)     数据库表中有过多的空字段&lt;br&gt;4、&lt;strong&gt;提示&lt;/strong&gt;：操作者认为操作不合理或操作不方便或操作麻烦。在已经正确实现功能的基础上，改进与优化，增强用户体验等。包括：    a)     界面颜色、排版，非关键性文字错误；  b)     辅助说明描述不清楚；  c)     显示格式不规范、查询报告格式错误；  d)     长时间操作未给用户进度提示；  e)     提示窗口文字未采用行业术语；  f)     删除等操作成功与否未给出提示；  g)     系统操作不方便；  h)     数据格式化问题，如千分位统一用半角逗号、取小数点后两位等；  i)      系统一致性问题，如提示用语、类似功能相关执行过程；  j)     系统处理未优化。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QA&lt;/td&gt;
&lt;td&gt;质量监管人员&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Korei&lt;/td&gt;
&lt;td&gt;科睿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CRM&lt;/td&gt;
&lt;td&gt;Customers Relation Management 客户关系管理系统&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&quot;1-4测试通过准则&quot;&gt;&lt;a href=&quot;#1-4测试通过准则&quot; class=&quot;headerlink&quot; title=&quot;1.4测试通过准则&quot;&gt;&lt;/a&gt;1.4测试通过准则&lt;/h2&gt;&lt;h3 id=&quot;1）测试充分性&quot;&gt;&lt;a href=&quot;#1）测试充分性&quot; class=&quot;headerlink&quot; title=&quot;1）测试充分性&quot;&gt;&lt;/a&gt;1）测试充分性&lt;/h3&gt;&lt;p&gt;​    a.用例已全面覆盖需求：测试用例覆盖率一般要求达到100%。&lt;/p&gt;
&lt;p&gt;​    b.原则上要求所有用例都100%执行，即优先级高、中、低的用例都必须100%执行。&lt;/p&gt;
&lt;p&gt;​    c.工作投入充分性：项目测试工作要充分投入，保障测试投入的合理性。&lt;/p&gt;
&lt;h3 id=&quot;2）测试有效性&quot;&gt;&lt;a href=&quot;#2）测试有效性&quot; class=&quot;headerlink&quot; title=&quot;2）测试有效性&quot;&gt;&lt;/a&gt;2）测试有效性&lt;/h3&gt;&lt;p&gt;​    a.严重程度及以上的缺陷解决率必须达到100%。&lt;/p&gt;
&lt;p&gt;​    b.一般和轻微缺陷遗留率低于5%。    &lt;/p&gt;
&lt;p&gt;​    c.相关责任部门认可测试结果,包括客户的试用、验收测试等。&lt;/p&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试基础" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>APP测试</title>
    <link href="https://laylaycjl.github.io/2024/05/16/APP%E6%B5%8B%E8%AF%95/"/>
    <id>https://laylaycjl.github.io/2024/05/16/APP%E6%B5%8B%E8%AF%95/</id>
    <published>2024-05-16T07:18:24.000Z</published>
    <updated>2024-05-16T07:31:26.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、App测试概念"><a href="#一、App测试概念" class="headerlink" title="一、App测试概念"></a>一、App测试概念</h1><h2 id="1、App的分类"><a href="#1、App的分类" class="headerlink" title="1、App的分类"></a>1、App的分类</h2><ul><li><p>iOS是基于Unix内核深度定制的一个移动设备操作系统；Android是一个Linux发行版，用于移动设备；Linux是类Unix系统；iOS是闭源的，Android是开源的；iOS是苹果公司主导，Android是谷歌主导的；</p></li><li><p>从操作系统平台来分，主要分为如下两种类型：</p><ul><li>iOS App<ul><li>安装在苹果的iOS操作系统上，主要是iPhone、iPad、iWatch等</li><li>同一款应用，通常对iPhone和iPad要出两个不同的版本，因为要针对iPhone和iPad两种终端的不同分辨率、屏幕尺寸分别适配</li><li>iOS App的安装包后缀为.ipa</li></ul></li><li>Android App<ul><li>安装在Android操作系统上，主要是Android手机和Android平板</li><li>同一款应用，通常对Android手机和Android平板要出两个不同的版本，因为要针对Android手机和Android平板两种终端的不同分辨率、屏幕尺寸分别适配</li><li>Android App的安装包后缀为.apk</li></ul></li></ul></li><li><p>从技术实现上，目前主流的App可以分为原生App、混合App和Web App两种类型：</p><ul><li><p>原生App</p><ul><li>原生App又称Native App，就是利用Android、iOS平台官方的开发语言、开发类库、工具进行开发。比如安卓的Java语言，iOS的Object-c语言。在应用性能上和交互体验上应该是好的。原生App需要针对Android和iOS平台开发两套不同代码，成本高。</li></ul></li><li><p>Web App</p><ul><li>指的是移动端的Web浏览器，主要借助H5网页技术进行开发，相当于开发一个网页，然后分别生成Android和iOS的壳。这种App只需要一套编程开发语言，技术简单，人力少，周期短。缺点是用户体验相对差。</li></ul></li><li><p>混合App</p><ul><li>混合App又称Hybrid App，是介于原生App和Web App之间的一种App形式。</li><li>uni-app是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等14个平台。</li><li>了解uni-app：<a href="https://uniapp.dcloud.io/README">https://uniapp.dcloud.io/README</a></li></ul><p><strong>目前国内基本只有大厂还在玩原生App，中小企业以混合App为主。</strong></p></li></ul><span id="more"></span></li></ul><h2 id="2、App应用商店"><a href="#2、App应用商店" class="headerlink" title="2、App应用商店"></a>2、App应用商店</h2><ul><li>常用的App应用商店：<ul><li>App Store：苹果应用商店，所有非越狱的苹果设备，只能从App Store上下载App</li><li>Google Play：谷歌应用商店，国外的智能手机默认使用的应用商店</li><li>App Gallery：华为应用商店，华为手机和平板使用的应用商店</li><li>小米商店应用：小米手机和平板使用的应用商店</li><li>OPPO软件商店：OPPO手机使用的应用商店</li><li>百度手机助手、360手机助手、腾讯应用宝、豌豆荚等其它应用商店，中国有超过400个Android应用商店。</li></ul></li><li><strong>注意：凡是在以上商店能下载的App都是正式版本，测试版本不可能从上面去下载。</strong></li></ul><h2 id="3、B-S架构与C-S架构"><a href="#3、B-S架构与C-S架构" class="headerlink" title="3、B/S架构与C/S架构"></a>3、B/S架构与C/S架构</h2><p>B/S架构：<img src="https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/image-20210728092110573.png" alt="image-20210728092110573" style="zoom: 67%;"></p><p>C/S架构：<img src="https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/image-20210728092130821.png" alt="image-20210728092130821" style="zoom:67%;"></p><ol><li><p><strong>访问方式</strong>不同</p><p>B/S：浏览器/服务器，用浏览器去打开的系统</p><p>C/S：客户端/服务器，客户端又分手机客户端（App）以及PC客户端</p></li><li><p><strong>业务处理</strong>方式不同</p><p>B/S架构下核心的业务处理在服务端完成</p><p>C/S架构下可以将业务合理地分配到客户端和服务器端来实现</p></li><li><p>C/S能更好地利用客户端设备的处理能力，具有更好的<strong>用户体验</strong>，响应速度更快，安全性也更高</p><p>对于安全性：</p><p>B/S：browser与服务器之间传输数据用的是http协议，客户端与服务器之间可以定制协议，安全性更高</p></li><li><p>兼容性不同</p><p>在开发、测试时，B/S需要考虑兼容不同的浏览器（内核），相对开发周期更短，共享性更强；</p><ul><li>所有浏览器，按内核分，有如下几种内核：<ul><li>Apple Webkit（谷歌内核）：<strong>Chrome、Safari</strong>、<strong>Edge</strong>、QQ浏览器、360极速版、世界之窗等</li><li>Gecko（火狐内核）：<strong>Firefox</strong></li><li>Trident（IE内核）：<strong>IE</strong>、360兼容版</li></ul></li></ul><p>C/S需要兼容不同的操作系统版本及设备</p><p>因为iOS和Android系统的差异，iOS App和Android App的开发语言是不一样的，对开发人员的能力要求也是不一样的，需要不同的开发人员分别开发出iOS App和Android App两套开发包，同时因为Android系统的碎片化严重，Android App在开发测试阶段需要花费大量的精力适配不同厂家的系统及设备，最后因为手机和平板的尺寸不一样，还需要分别出手机版和平板版（HD）两个版本</p></li><li><p>从维护的角度</p><p>C/S工作量会更大，因为B/S的升级只需要在服务器上升级即可，C/S的升级往往需要同时升级服务器端和客户端；iOS和Android系统有重大更新的时候会需要开发者同步更新App以适配最新的操作系统</p></li></ol><h2 id="4、iOS-App与Android-App的区别"><a href="#4、iOS-App与Android-App的区别" class="headerlink" title="4、iOS App与Android App的区别"></a>4、iOS App与Android App的区别</h2><ol><li><p>开发语言（原生应用）</p><p>iOS App用object-c开发，对应的是iOS开发工程师</p><p>Android App用Java开发，对应的是Android开发工程师</p></li><li><p>上架（商用上线）的市场</p><p>iOS App是统一上架到苹果的App Store，苹果设备只要没有越狱，只能从AppStore上下载app安装</p><p>Android app是上架到各个手机厂家的应用市场上，比如谷歌的Google Play，华为的App Galary等等</p></li><li><p>在做兼容性测试时，Android App会更复杂；</p></li><li><p>iOS是一个相对封闭的操作系统，是苹果基于Unix内核深度定制的一个移动设备操作系统；Android是一个开放的操作系统，谷歌会定期发布基线版本，各个手机厂家会在基线版本的基础上再进行本地化定制，结果就导致Android系统出现很多分支（碎片化），导致Android App对不同分支版本的适配难度会更大；</p></li><li><p>AppStore对应用的审核会更严格，所以iOS APP会相对更安全；</p></li><li><p>Android App的包后缀是.apk，iOS App的包后缀是.ipa；</p><ul><li>MyCamera.apk：Android手机版App</li><li>MyCameraHD.apk：Android平板App</li><li>MyCamera.ipa：iPhone手机版App</li><li>MyCameraHD.ipa：iPad版App</li></ul></li></ol><h1 id="二-App的测试点"><a href="#二-App的测试点" class="headerlink" title="二. App的测试点"></a>二. App的测试点</h1><h2 id="1-、功能测试"><a href="#1-、功能测试" class="headerlink" title="1 、功能测试"></a>1 、功能测试</h2><p>就功能测试而言，App测试和Web测试没有区别，都是基于软件的功能性需求编写测试用例</p><p>设计测试用例的方法都可以采用场景分析、等价类、边界值、错误猜测等</p><p>写好用例之后先安装环境，然后执行用例，对发现的问题提交Bug单跟进解决</p><h2 id="2、UI易用性测试"><a href="#2、UI易用性测试" class="headerlink" title="2、UI易用性测试"></a>2、UI易用性测试</h2><ul><li><p>检测界面是否美观，操作是否简单易用，是否符合用户的操作行为，产品是否有相关的帮助文档，FAQ（常问问题）等</p></li><li><p>参考：UI设计图，检查系统的实现是否与UI设计图一致</p></li></ul><h2 id="3、-兼容性测试"><a href="#3、-兼容性测试" class="headerlink" title="3、 ==兼容性测试=="></a>3、 ==兼容性测试==</h2><h3 id="（1）测试策略"><a href="#（1）测试策略" class="headerlink" title="（1）测试策略"></a>（1）测试策略</h3><ul><li>Web需要兼容不同内核的浏览器（Chrome、Firefox、IE等）</li><li>App需要兼容不同版本的操作系统（iOS14、iOS15、Android10、Android11、Android12、鸿蒙OS等）、<strong>设备尺寸</strong>、<strong>屏幕的类型</strong>（曲面屏、折叠屏、刘海屏、挖孔屏、全面屏）、<strong>分辨率</strong>、网络环境、语言等</li></ul><h3 id="（2）测试点（测试方法）"><a href="#（2）测试点（测试方法）" class="headerlink" title="（2）测试点（测试方法）"></a>（2）测试点（测试方法）</h3><p>在不同的设备上进行安装、启动、运行、卸载测试，需要大量的测试设备才能做好兼容性测试</p><h3 id="（3）兼容测试的难点"><a href="#（3）兼容测试的难点" class="headerlink" title="（3）兼容测试的难点"></a>（3）兼容测试的难点</h3><p>设备类型太多，iPhone目前有20多款设备，Android手机就更多了，Android碎片化严重，想要做充分的兼容性测试，成本很大</p><h3 id="（4）测试工具"><a href="#（4）测试工具" class="headerlink" title="（4）测试工具"></a>（4）测试工具</h3><ul><li><p>真机（优先）</p></li><li><p>wetest平台</p><p>1、注册、登录wetest平台<br>2、提交app、选择测试机型，提交测试<br>3、分析兼容性测试报告（可分享、可导出），对缺陷进行管理</p></li><li><p>模拟器（夜神、mumu、蓝叠）</p></li></ul><h2 id="4、安装、卸载、升级测试"><a href="#4、安装、卸载、升级测试" class="headerlink" title="4、安装、卸载、升级测试"></a>4、安装、卸载、升级测试</h2><h3 id="（1）安装测试"><a href="#（1）安装测试" class="headerlink" title="（1）安装测试"></a>（1）安装测试</h3><h4 id="1）测试点"><a href="#1）测试点" class="headerlink" title="1）测试点"></a>1）测试点</h4><p>直接安装能否安装成功，卸载后再次安装能够成功，安装的App能否正常启动</p><h4 id="2）安装测试方法"><a href="#2）安装测试方法" class="headerlink" title="2）安装测试方法"></a>2）安装测试方法</h4><ul><li><p>Android app</p><ul><li><p>对Android App来讲，可以直接把apk发到手机上下载并安装；</p></li><li><p>通过adb（安卓调试桥）命令安装（仅限于Android App）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install xxx.apk</span><br></pre></td></tr></tbody></table></figure></li><li><p>通过爱思助手等工具安装（iOS App和Android App都可以）</p></li></ul></li></ul><ul><li>iOS app<ul><li>手机助手<ul><li>通过助手工具连接iOS设备前，需要先在电脑上安装iTunes工具</li><li>安装iOS App，需要先获取测试手机的UDID，由开发写入到App的配置文件中再打包，这时得到的App才可以在测试设备上安装</li></ul></li><li>testflight软件<ul><li>测试机上安装Testflight</li><li>获取到邀请码，打开Testflight，输入邀请码</li><li>点击安装，在测试机上就会安装待测的app</li></ul></li></ul></li></ul><h3 id="（2）卸载测试"><a href="#（2）卸载测试" class="headerlink" title="（2）卸载测试"></a>（2）卸载测试</h3><h4 id="1）测试点-1"><a href="#1）测试点-1" class="headerlink" title="1）测试点"></a>1）测试点</h4><p>App能够卸载成功，卸载后是否可以再次安装</p><h4 id="2）卸载方法"><a href="#2）卸载方法" class="headerlink" title="2）卸载方法"></a>2）卸载方法</h4><ol><li><p>在手机上直接卸载</p></li><li><p>通过adb命令卸载（Android）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall 包名</span><br></pre></td></tr></tbody></table></figure></li><li><p>通过助手工具卸载</p></li></ol><h3 id="（3）升级测试"><a href="#（3）升级测试" class="headerlink" title="（3）升级测试"></a>（3）升级测试</h3><h4 id="1）测试点-2"><a href="#1）测试点-2" class="headerlink" title="1）测试点"></a>1）测试点</h4><ul><li>先安装老版本，再安装新版本，看是否能安装成功并覆盖老版本</li><li>新版本覆盖旧版本后，版本号应该为新版本号</li><li>数据是否有丢失</li><li>功能正常：包括原有功能和新增功能</li></ul><h4 id="2）App的升级方案"><a href="#2）App的升级方案" class="headerlink" title="2）App的升级方案"></a>2）App的升级方案</h4><ul><li><p>在线升级：当应用商店已经有新版本时，提示更新，用户点击更新，下载最新版本，进行安装升级，这种就是在线升级</p><ul><li>强制升级：强制更新就是当检测到有新版本时，弹出提示，这个提示框没有关闭按钮，只能更新，一般需要强制更新的版本，主要是功能模板改动较大，或业务比较重要，和功能模板存在风险等</li><li>非强制升级：非强制更新就可以让用户选择是否现在更新或以后更新，旧版本的功能正常使用</li></ul></li><li><p>离线升级：不从线上下载升级包，通过线下的方式安装升级包进行升级，这种就是离线升级</p></li></ul><h4 id="3）升级场景设计："><a href="#3）升级场景设计：" class="headerlink" title="3）升级场景设计："></a>3）升级场景设计：</h4><ul><li><p>第一个版本：用户只有新安装的场景</p></li><li><p>第二个版本：用户有新安装的场景、也有从第一个版本升级到第二个版本的场景</p></li><li><p>第三个版本：用户有新安装的场景、也有从第一个版本升级到第三个版本的场景、也有从第二个版本升级到第三个版本的场景</p></li><li><p>版本越多，跨版本升级的场景也越复杂，一般也不可能把所有场景都验证一遍，通常的做法是分析生产环境的数据，看绝大部分用户都在哪几个版本上，重点考虑从这几个版本升级到新版本的场景。如果App做了强制升级的方案，这种情况下用户的版本就比较新，升级的场景也更简单。</p></li></ul><h2 id="5、-弱网测试"><a href="#5、-弱网测试" class="headerlink" title="5、==弱网测试=="></a>5、==弱网测试==</h2><h3 id="（1）测试点"><a href="#（1）测试点" class="headerlink" title="（1）测试点"></a>（1）测试点</h3><p>观察弱网场景下, app是否会出现crash、anr等异常</p><h3 id="（2）测试工具"><a href="#（2）测试工具" class="headerlink" title="（2）测试工具"></a>（2）测试工具</h3><p>QNET、fiddler、360wifi、修改网络制式到2G、3G模拟弱网环境</p><h4 id="1）QNET"><a href="#1）QNET" class="headerlink" title="1）QNET"></a>1）QNET</h4><ul><li>1、在测试机上安装QNET(独立的app)</li><li>2、打开QNET，选择弱网场景（系统自带的模版、用户自定义的模版)、选择要测试的应用(默认是全局生效，手机上的所有应用都起作用）</li><li>3、启动测试，成功将待测app模拟到弱网场景</li><li>4、操作APP的各项功能，观察app是否出现crash、ANR</li><li>5、分析日志，有缺陷就做缺陷管理</li></ul><h4 id="2）fiddler"><a href="#2）fiddler" class="headerlink" title="2）fiddler"></a>2）fiddler</h4><ul><li>1、fiddler作为手机的代理，所以可以修改fiddler的配置文件，打开限速开关，设置上行和下行的速率，从而将app模拟到弱网环境</li><li>2、操作app，观察是否有crash、ANR</li><li>3、分析日志，有缺陷做缺陷管理</li></ul><h2 id="6、-App稳定性测试"><a href="#6、-App稳定性测试" class="headerlink" title="6、==App稳定性测试=="></a>6、==App稳定性测试==</h2><h3 id="（1）工具"><a href="#（1）工具" class="headerlink" title="（1）工具"></a>（1）工具</h3><p>monkey命令来做压力测试</p><p>工作原理：长时间模拟人对手机的各种操作（点击、二指缩放等12种事件)</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey</span><br><span class="line">-p 包名：对指定的app进行测试</span><br><span class="line">-v -v -v：打印最详细的信息</span><br><span class="line">-s 种子值：种子值，对应一种操作序列，用来复现bug，回归测试使用</span><br><span class="line"></span><br><span class="line">忽略异常，直到完成指定的测试次数：</span><br><span class="line">--ignore-crashes</span><br><span class="line">--ignore-native-crashes</span><br><span class="line">--ignore-timeouts</span><br><span class="line">--ignore-security-exceptions</span><br><span class="line">--monitor-native-crashes</span><br><span class="line"></span><br><span class="line">--throtte 5：设置事件之间等待时间为5ms（毫秒）</span><br><span class="line"></span><br><span class="line">--pct-touch 20：设置touch事件占比20%</span><br><span class="line"></span><br><span class="line">经典例子：</span><br><span class="line">测试10000次，重定向错误和输出：</span><br><span class="line">adb shell monkey -p tv.danmaku.bili -v -v -v --ignore-crashes --ignore-native-crashes --ignore-timeouts --ignore-security-exceptions 10000&gt;D:\monkey1.txt 2&gt;&amp;1</span><br><span class="line">修改bug后，回归测试：</span><br><span class="line">adb shell monkey -p tv.danmaku.bili -v -v -v --ignore-crashes --ignore-native-crashes --ignore-timeouts --ignore-security-exceptions -s 1637762067514 10000&gt;D:\monkey2.txt 2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure><h3 id="（2）测试点"><a href="#（2）测试点" class="headerlink" title="（2）测试点"></a>（2）测试点</h3><p>长时间、频繁操作APP，观察APP是否能够稳定运行</p><h3 id="（3）日志分析"><a href="#（3）日志分析" class="headerlink" title="（3）日志分析"></a>（3）日志分析</h3><p>对定向的日志文件进行分析，搜索: crash、anr、error、exception等</p><h2 id="7、-APP性能测试"><a href="#7、-APP性能测试" class="headerlink" title="7、==APP性能测试=="></a>7、==APP性能测试==</h2><h3 id="（1）测试点-1"><a href="#（1）测试点-1" class="headerlink" title="（1）测试点"></a>（1）测试点</h3><p>APP性能测试，检测的是移动端（手机、pad等)的资源占用情况</p><h3 id="（2）测试工具perfDog"><a href="#（2）测试工具perfDog" class="headerlink" title="（2）测试工具perfDog"></a>（2）测试工具perfDog</h3><ul><li>1、PC连接到测试机（数据线、wifi），选择测试设备</li><li>2、选择要测试的参数，例如，CPU、memory、battery（只能在wifi连接下才能测）、network、fps</li><li>3、选择待测应用，启动测试，操作app的各项功能一段时间后结束测试</li><li>4、可以生成测试报告（可分享），对测试报告进行分析<ul><li>将测试结果平均值与需求规格说明书中的性能规格要求进行对比，如果没有性能规格要求，就与竞品对比，来确定规格。如果有缺陷，对缺陷进行管理</li></ul></li></ul><h2 id="8、-交叉事件测试"><a href="#8、-交叉事件测试" class="headerlink" title="8、==交叉事件测试=="></a>8、==交叉事件测试==</h2><p>交叉事件测试也叫中断测试，是指App执行过程中，有其它事件或者应用中断当前应用执行的测试。比如在App使用过程中出现来电、来消息、响闹钟、弹出电量低、打开其它App等其它事件，验证当其它事件出现的时候，是否会中断当前App的事件</p><p>交叉测试一般采用手工测试的方式在真机上进行</p><h2 id="9、耗电量测试"><a href="#9、耗电量测试" class="headerlink" title="9、耗电量测试"></a>9、耗电量测试</h2><ul><li><p>目的就是检查App的耗电是否过高，电量消耗跟CPU有关系。</p></li><li><p>可以通过手机的电池统计来查看App的耗电情况，也可以通过adb命令来查看，还可以通过第三方工具PerfDog（性能狗）、GT等来检查耗电情况</p></li></ul><h2 id="10、流量测试"><a href="#10、流量测试" class="headerlink" title="10、流量测试"></a>10、流量测试</h2><ul><li>流量测试，指的是监控App的流量使用是否合理，目的是优化App的流量使用，比如有些数据需要缓存到客户端上来避免过多地消耗流量</li><li>有很多方法可以获取App的流量，比如对于Android系统，网络流量信息通常存放在/proc/net/dev目录下，可以直接利用adb工具获取实时的流量信息。另外，推荐一款Android的轻量级性能监控小工具Emmagee。对于iOS系统，可以使用XCode自带的性能分析工具集中的Network Activity，分析具体的流量使用情况</li><li>推荐：使用PerfDog（性能狗）可以很方便地监控App的流量</li></ul><h2 id="11、-边界测试"><a href="#11、-边界测试" class="headerlink" title="11、==边界测试=="></a>11、==边界测试==</h2><p>边界测试是指，移动App在一些临界状态下的行为功能是否正常，基本思想是找出各种潜在的临界场景，并对每一类临界场景做验证和测试。</p><p>比如：</p><ul><li><p>手机提示内存空间不足</p></li><li><p>飞行模式来回切换的场景</p></li><li>App 不具有某些系统访问权限的场景，比如 App 由于隐私设置不能访问相册或者通讯录等</li><li>长时间使用App，系统资源是否有异常，比如内存泄漏、过多的链接数等</li><li>出现ANR的场景（网络差、操作频繁、手机上起的应用过多、不同App之间切换等）</li><li>操作系统时间早于或者晚于标准时间的场景</li><li>时区切换的场景  GMT</li><li>等等……</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1、Web测试和App测试有什么区别？"><a href="#1、Web测试和App测试有什么区别？" class="headerlink" title="1、Web测试和App测试有什么区别？"></a>1、Web测试和App测试有什么区别？</h3><ul><li>功能、UI、易用性方面的测试，Web和App没有区别</li><li>兼容性: Web兼容不同的浏览器。App兼容不同操作系统的手机、不同的屏幕类型、分辨率、尺寸大小</li><li>App还有一些专项测试:安装卸载升级测试、弱网测试、稳定性测试、性能测试(耗电量、流量、CPU、内存)、边界测试、交叉事件测试等</li></ul><h3 id="2、一个APP，一般有哪些测试方面"><a href="#2、一个APP，一般有哪些测试方面" class="headerlink" title="2、一个APP，一般有哪些测试方面"></a>2、一个APP，一般有哪些测试方面</h3><p>功能、UI、兼容性、卸载安装升级、弱网、稳定性、性能、边界</p><h3 id="3、兼容性怎么测的"><a href="#3、兼容性怎么测的" class="headerlink" title="3、兼容性怎么测的"></a>3、兼容性怎么测的</h3><p>回答要点：Web和App的侧重点不一样、测试工具(真机、wetest、模拟器），怎么观察结果</p><h3 id="4、稳定性怎么测的"><a href="#4、稳定性怎么测的" class="headerlink" title="4、稳定性怎么测的"></a>4、稳定性怎么测的</h3><p>回答要点：用什么工具(monkey)，原理是什么，用的参数，怎么观察结果</p><h3 id="5、弱网怎么测"><a href="#5、弱网怎么测" class="headerlink" title="5、弱网怎么测"></a>5、弱网怎么测</h3><p>回答要点：怎么模拟弱网环境（QNET、fiddler）、怎么观察结果</p><h3 id="6、app性能怎么测"><a href="#6、app性能怎么测" class="headerlink" title="6、app性能怎么测"></a>6、app性能怎么测</h3><p>回答要点：perfdog关注哪些指标，怎么判断指标是否达标</p><h1 id="三、测试工具"><a href="#三、测试工具" class="headerlink" title="三、测试工具"></a>三、测试工具</h1><h2 id="1、uni-app打包"><a href="#1、uni-app打包" class="headerlink" title="1、uni-app打包"></a>1、uni-app打包</h2><p>IDE工具：HBuilder X</p><p>打包前需要准备签名证书，Android证书的生成是自助和免费的，不需要审批或付费，iOS证书需要向苹果官方申请。其中iOS证书分为测试证书和正式证书，测试证书用于打测试版的App（可以在绑定了UDID的苹果设备上安装），正式证书用于打最终上架的App。</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152058480.png" alt="image-20240516152058480" style="zoom:50%;"></p><p>App的包名：就是App的名字，包名一般用反写域名的方式来命名</p><p>一级域名：www.jd.com</p><p>二级域名：discount.jd.com    ——&gt;包名：com.jd.discount</p><h2 id="2、Android模拟器的使用"><a href="#2、Android模拟器的使用" class="headerlink" title="2、Android模拟器的使用"></a>2、Android模拟器的使用</h2><ul><li>模拟器的作用<ul><li>在实际工作中，因为某些原因，没有足够的测试机的时候，可以通过模拟器来模拟部分手机进行测试。</li><li>但需要注意的是，模拟器始终跟真机存在差异，如果想确保App在真机上运行没有问题，必须在真机上进行测试。</li></ul></li><li>常用的Android模拟器有：夜神、逍遥、MUMU、雷电等</li><li>iOS模拟器：因为iOS是闭源的，做iOS模拟器的技术难度较大，目前国内的iOS模拟有黑雷、水果等，但都是收费软件。</li><li>演示：夜神模拟的使用。</li></ul><h2 id="3、常用的adb命令"><a href="#3、常用的adb命令" class="headerlink" title="3、常用的adb命令"></a>3、常用的adb命令</h2><h3 id="（1）什么是adb"><a href="#（1）什么是adb" class="headerlink" title="（1）什么是adb"></a>（1）什么是adb</h3><p>adb：Android Debug Bridge，安卓调试桥，是一种命令行工具，可实现对Android设备的操作，比如安装、卸载apk，往安卓设备上传、下载文件，打印安卓设备的日志等。</p><h3 id="（2）adb环境配置"><a href="#（2）adb环境配置" class="headerlink" title="（2）adb环境配置"></a>（2）adb环境配置</h3><p>下载地址：<a href="https://android-sdk.en.softonic.com/，下载最新版本的Android">https://android-sdk.en.softonic.com/，下载最新版本的Android</a> SDK，解压。</p><p>配置环境变量，把adb命令的目录配置到PATH中。<strong>记住：配置Path环境变量的时候，只能增加，不能覆盖之前的配置。</strong></p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152115823.png" alt="image-20240516152115823" style="zoom:50%;"></p><p>检查是否配置成功，在dos命令中输入adb version回车，出现版本信息表示配置成功</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo&gt;adb version</span><br><span class="line">Android Debug Bridge version 1.0.41</span><br><span class="line">Version 29.0.2-5738569</span><br><span class="line">Installed as C:\android-sdk-windows\android-sdk-windows\tools\adb.exe</span><br></pre></td></tr></tbody></table></figure><p>通过adb连接Android设备，有两种方法：</p><p><strong>方法1</strong>：</p><p>通过数据线连接，<strong>注意是数据线不是充电线</strong>，在手机上先开启开发者模式，然后再开启USB调试模式，然后在dos窗口敲adb devices命令查看是否连接成功，如果显示如下就表示连接成功</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo&gt;adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">D5F0219815004432        device</span><br></pre></td></tr></tbody></table></figure><p>步骤：1、打开开发者模式；2、开启USB调试。</p><p><strong>方法2</strong>：</p><p>通过Wi-Fi连接，首先将电脑和手机连接到同一个Wi-Fi，然后将手机通过数据线连接到电脑，执行adb tcpip 5555在手机上开启adb无线模式服务</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo&gt;adb tcpip 5555</span><br><span class="line">restarting in TCP mode port: 5555</span><br></pre></td></tr></tbody></table></figure><p>最后在dos窗口执行adb connect 手机IP连接手机，如下就表示连接成功了</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo&gt;adb connect 192.168.2.101:5555</span><br><span class="line">connected to 192.168.2.101:5555</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">断开Wi-Fi连接</span></span><br><span class="line">C:\Users\lenovo&gt;adb disconnect 192.168.2.101:5555</span><br></pre></td></tr></tbody></table></figure><p>扩展：IP地址、掩码地址、网关地址的关系</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152128679.png" alt="image-20240516152128679" style="zoom:50%;"></p><p>192.168.7.82            11000000.10101000.00000111.01010010</p><p>255.255.255.0          11111111.11111111.11111111.00000000      ——24个1，所以也叫24位掩码   192.168.7.82/24</p><p>192.168.7.0               11000000.10101000.00000111.00000000     ——-网络地址    192.168.7.0/24</p><p>对IP地址192.168.7.82的解释是：网络地址是192.168.7.0，主机地址是82，主机地址的范围是0~255，其中0表示网络地址，255表示广播地址，1通常用来作为网关地址，所以在这个网络中可用的主机地址有2-254，总共253个。</p><p>1&amp;1=1</p><p>1&amp;0=0</p><p>0&amp;1=0</p><p>0&amp;0=0</p><h3 id="（3）-常用的adb命令"><a href="#（3）-常用的adb命令" class="headerlink" title="（3）==常用的adb命令=="></a>（3）==常用的adb命令==</h3><h4 id="1）基本指令"><a href="#1）基本指令" class="headerlink" title="1）基本指令"></a>1）基本指令</h4><ul><li>查看adb 的版本号</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb version</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo&gt;adb version</span><br><span class="line">Android Debug Bridge version 1.0.41</span><br><span class="line">Version 29.0.2-5738569</span><br><span class="line">Installed as C:\android-sdk-windows\android-sdk-windows\tools\adb.exe</span><br></pre></td></tr></tbody></table></figure><ul><li><p>查看连接设备及状态</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line"></span><br><span class="line">查出来的设备状态有3种</span><br><span class="line">- offline 表示离线</span><br><span class="line">- device 表示连接正常</span><br><span class="line">- unauthorized 表示未授权（如果手机上没有允许USB调试，就会显示未授权）</span><br></pre></td></tr></tbody></table></figure></li><li><p>开启Android设备的adb无线模式服务：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb tcpip 端口</span><br><span class="line"></span><br><span class="line">比如adb tcpip 5555</span><br></pre></td></tr></tbody></table></figure></li><li><p>通过Wi-Fi的方式连接设备</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect 设备IP:端口</span><br></pre></td></tr></tbody></table></figure></li><li><p>断开设备</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb disconnect 设备IP:端口</span><br></pre></td></tr></tbody></table></figure></li><li><p>安装app</p><ul><li><code>adb install apk的路径</code>，如果是在真机上安装，需要在手机上点击弹出的允许安装才能成功</li><li><code>adb install -r apk的路径</code> ，-r表示覆盖安装，如果之前已经安装了该apk，直接安装会失败，需要覆盖安装</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo&gt;adb install C:\蓉华学院\项目\占数家营销助手\安装包\PromotionAssist-debug.apk(拖动到dos里即可)</span><br><span class="line">Performing Streamed Install</span><br><span class="line">Success</span><br></pre></td></tr></tbody></table></figure></li><li><p>卸载app</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">卸载apk并删除数据:</span><br><span class="line">adb uninstall 包名</span><br><span class="line">卸载apk，保留数据:</span><br><span class="line">adb uninstall -k 包名</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo&gt;adb uninstall com.summer.evs</span><br><span class="line">Success</span><br></pre></td></tr></tbody></table></figure></li><li><p>==查看所有包名==</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list package</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">包名是app的唯一标识，一般采用反写域名的方式命名，比如com.taobao.taobao</span></span><br><span class="line">www.ronghuanet.com           一级域名</span><br><span class="line">students.ronghuanet.com     ---&gt;com.ronghuanet.students</span><br><span class="line">teachers.ronghuanet.com      ---&gt;com.ronghuanet.teachers</span><br></pre></td></tr></tbody></table></figure></li><li><p>查看系统包名</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list package -s</span><br></pre></td></tr></tbody></table></figure></li><li><p>查看第三方包名</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list package -3</span><br></pre></td></tr></tbody></table></figure></li><li><p>==查看包的安装位置==</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list package -f</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看指定包的安装位置(-i 包名)</span></span><br><span class="line">adb shell pm list package -f -i sidoumi</span><br></pre></td></tr></tbody></table></figure></li><li><p>==查找指定app的包名==</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">当只有一台设备时：</span><br><span class="line">adb shell dumpsys activity activities | findstr mResumedActivity （执行命令之前打开应用在前台运行）</span><br><span class="line"></span><br><span class="line">两台设备需要指定设备名：</span><br><span class="line">adb -s 127.0.0.1.62027  shell dumpsys activity activities | findstr mResumedActivity </span><br><span class="line"></span><br><span class="line">C:\Users\lenovo&gt;adb shell dumpsys activity activities | findstr mResumedActivity</span><br><span class="line">    mResumedActivity: ActivityRecord{84a6383 u0 com.ifeng.news2/.activity.IfengTabMainActivity t185}</span><br><span class="line">    </span><br><span class="line">注：</span><br><span class="line">com.ifeng.news2是包名</span><br><span class="line">.activity.IfengTabMainActivity t185是活动窗口</span><br></pre></td></tr></tbody></table></figure></li><li><p>查看app的版本号：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm dump 包名 | findstr "version"</span><br><span class="line"></span><br><span class="line">举例：adb shell pm dump com.test.hm | findstr "version"</span><br><span class="line">注：命令中的参数：com.test.hm是app的包名。</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo&gt;adb shell pm dump com.sidoumi.his | findstr "version"</span><br><span class="line">    versionCode=100 minSdk=19 targetSdk=28</span><br><span class="line">    versionName=1.0.0</span><br><span class="line">    signatures=PackageSignatures{a14bc9f version:2, signatures:[637809ff], past signatures:[]}</span><br></pre></td></tr></tbody></table></figure></li><li><p>打开APP：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start 包名/活动窗口名</span><br><span class="line">需要指定包名和活动窗口</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo&gt;adb shell am start com.ifeng.news2/.activity.IfengTabMainActivity t185</span><br><span class="line"></span><br><span class="line">Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.ifeng.news2/.activity.IfengTabMainActivity }</span><br></pre></td></tr></tbody></table></figure></li><li><p>关闭打开的APP（放到后台）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell am force-stop 包名</span><br><span class="line"></span><br><span class="line">C:\Users\lenovo&gt;adb shell am force-stop com.ifeng.news2</span><br></pre></td></tr></tbody></table></figure></li><li><p>进入shell：进入shell后可以执行linux命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell(只有一个设备时)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果电脑连接了多个设备，使用adb -s 设备名 shell来指定进入某个设备</span></span><br><span class="line"><span class="meta">#</span><span class="bash">例如：</span></span><br><span class="line">adb -s 127.0.0.1.62027</span><br></pre></td></tr></tbody></table></figure></li><li><p>==把Android设备上的文件下载到本地==</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb pull Android设备上文件路径 本地目的路径</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">用途：从测试设备上取文件、日志等到本地，给开发分析</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>==把本地文件上传到Android设备中==</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb push 本地文件所在路径(拖动到dos里即可) Android设备的目的路径</span><br><span class="line"></span><br><span class="line">adb push: 把本地文件推到Android设备上，相当于上传文件</span><br><span class="line">比如adbpush C:\Users\Administrator\Desktop\123\app.log /data/anr </span><br><span class="line">表示把windows上的C:\Users\Administrator\Desktop\123\app.log上传到Android设备上的/data/anr目录（如果没有写入权限：adb remount）</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">用途：当开发修改完一个问题的时候，如果要快速验证，一般开发会提供一个补丁文件，需要把这个文件推到Android设备的某个目录下替换原有的文件，替换后重启App再次验证；</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>删除文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell rm 文件</span><br><span class="line"><span class="meta">#</span><span class="bash">也可以先执行adb shell进入到安卓设备上，然后通过rm命令删除</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="2）adb-logcat打印日志"><a href="#2）adb-logcat打印日志" class="headerlink" title="2）adb logcat打印日志"></a>2）adb logcat打印日志</h4><p><code>adb logcat</code>：打印日志到屏幕</p><p>注：<code>adb logcat</code>   和   <code>adb shell logcat</code>   他们打印的内容是一模一样的，区别在于adb logcat中的logcat是以参数的形式存在，而adb shell logcat中的logcat是以shell 命令的形式存在</p><ul><li><p>-v参数：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -v color 做颜色区分</span><br><span class="line">adb logcat -v time 查看日志输出时间</span><br><span class="line">adb logcat -v brief 输出简要信息</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure></li><li><p>—help参数：查看帮助信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat --help </span><br></pre></td></tr></tbody></table></figure></li><li><p>tag参数：做日志筛选（tag省略）</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152153394.png" alt="image-20240516152153394" style="zoom:50%;"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">日志默认级别是V，如果错误日志我们选择E就可以</span><br><span class="line">tag参数：</span><br><span class="line">V verbose级别</span><br><span class="line">D debug级别</span><br><span class="line">I info级别</span><br><span class="line">W warn级别</span><br><span class="line">E Error级别</span><br><span class="line">F Fatal致命级别</span><br><span class="line">S Slilent级别</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">adb logcat *:W 展示warn级别以上的日志信息</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>-c参数：清除缓存的日志，在打印日志前可以先清理缓存的日志再打，这样会更有针对性</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -c</span><br></pre></td></tr></tbody></table></figure></li><li><p>重定向日志到本地磁盘</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat&gt;D:\test\app.log</span><br></pre></td></tr></tbody></table></figure></li><li><p>最常用的命令组合</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、展示时间信息，且只显示warn级别以上的日志，重定向到c盘中</span><br><span class="line">adb logcat -v time *:w&gt; c:\2111.txt</span><br><span class="line"></span><br><span class="line">2、先清空日志信息，然后设置显示日志时间，最后重定向到c盘中</span><br><span class="line">adb logcat -c &amp;&amp; adb logcat -v time&gt;C:\app.log</span><br></pre></td></tr></tbody></table></figure></li><li><p>日志结果分析：</p><ul><li><p><strong>ANR，Exception , Null , Error, Crash</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、ANR(application not responding)：程序无响应问题</span><br><span class="line">注：ANR：Application Not Responding，应用无响应，当一个app出现一次ANR问题时，Android系统会自动生成一个日志文件放到/data/anr目录下，这时需要把这个文件取下来分析</span><br><span class="line"></span><br><span class="line">2、exception：</span><br><span class="line">异常，参数异常，空指针异常都会报exception；</span><br><span class="line">崩溃：</span><br><span class="line">null、NullPointerException：空指针异常</span><br><span class="line">IllegalStateException：debug异常</span><br><span class="line">OutOfMemoryError：低内存异常</span><br><span class="line">TimerOut（KeyDispatchingTimedOut提示）：操作无响应异常</span><br><span class="line">RuntimeException：操作无响应或应用的服务无法启动或连接异常</span><br><span class="line">StaleDataException/readException：android 数据库出现异常</span><br><span class="line">IllegalArgumentException：向函数传递了一个不正确或不合法的参数</span><br><span class="line"></span><br><span class="line">3、crash：闪退问题</span><br><span class="line"></span><br><span class="line">4、forceclosed：异常导致的强制退出</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="3）adb-monkey压力测试（-稳定性测试-）"><a href="#3）adb-monkey压力测试（-稳定性测试-）" class="headerlink" title="3）adb monkey压力测试（==稳定性测试==）"></a>3）adb monkey压力测试（==稳定性测试==）</h4><ul><li><p>什么是monkey</p><ul><li><p>adb monkey是一款稳定性测试工具，通过<strong>随机</strong>操作app一段时间，看app会不会出现崩溃、无响应，能够正常维持运行的测试。是由android系统自带应用，可以通过adb shell monkey直接使用。（伪随机）</p></li><li><p>monkey命令的路径</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127|HWCLT:/ $ ls -l /system/bin/monkey</span><br><span class="line">-rwxr-xr-x 1 root shell 268 2018-08-08 00:01 /system/bin/monkey</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>monkey的12种随机事件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0：触摸事件，参数--pct-touch，触摸事件指的是在屏幕某处按下并抬起的操作，我们可以模拟点击的操作；</span><br><span class="line">1：手势事件（滑动事件），参数--pct-motion，滑动事件指的是在屏幕某处按下、随机移动、抬起的操作，类似我们滑动手机屏幕翻页的操作。</span><br><span class="line">2：二指缩放事件，参数--pct-pinchzoom，缩放事件指的是在屏幕上的两处同时按下，又同时移动，最后同时抬起，模拟我们在手机放大缩小的操作</span><br><span class="line">3：轨迹事件，参数--pct-trackball，指的是由一个或者多个随机的移动组成，有时会伴随点击。</span><br><span class="line">4：屏幕旋转事件，参数--pct-rotation，模拟手机的横竖屏切换，degree指的是旋转方向，顺时针旋转，0表示旋转90°，1表示旋转180°，2表示旋转270°，3表示旋转360°</span><br><span class="line">5：permission事件</span><br><span class="line">6：基本导航事件，参数--pct-nav，指的是点击方向输入设备的上下左右按键的操作，现在的手机很少有这样的方向键了，所以应用较少</span><br><span class="line">7：主要导航事件，参数--pct-majornav，指的是点击“主要导航”按键的操作，例如app的中间键，返回键，菜单按键等</span><br><span class="line">8：系统按键事件，参数--pct-syskeys，指的是系统保留的按键事件，比如Home键、返回键、音量调节按键等</span><br><span class="line">9：启动activity事件，参数--pct-appswitch，指的是在手机上启动一个Activity的操作，在随机的时间间隔内，Monkey 将执行一个 startActivity() 方法， 作为最大程度上覆盖被测包中全部 Activity 的一种方法</span><br><span class="line">10：键盘事件，参数--pct-flip，键盘事件指的是一些与键盘相关的操作，比如点击输入框、键盘弹起等</span><br><span class="line">11：其他类事件，参数--pct-anyevent，指的是除了上述事件之外的其他事件，比如其它不常用的设备按钮等</span><br></pre></td></tr></tbody></table></figure></li><li><p>举例：adb shell monkey 1000  表示对手机整机进行1000次随机操作</p></li><li><p>部分参数：</p><ul><li><font color="red">==-p==：指定有效的package（如不指定，则对系统中所有package有效）</font><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个-p对应一个有效:</span><br><span class="line">package-p com.ckt -p com.ckt.asura</span><br></pre></td></tr></tbody></table></figure></li><li><font color="red">==-v==：指定打印信息的详细级别，一个 -v增加一个级别 ， 默认级别为 0，三个-v表示最详细的级别</font><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对安装的app进行稳定性测试，分别测试1000次，把最详细的测试记录保存在PC的目录bili_test_log下</span><br><span class="line">adb shell monkey -p tv.danmaku.bili -v -v -v &gt;d:\bili_test_log 2&gt;&amp;1  1000</span><br></pre></td></tr></tbody></table></figure></li><li><font color="red">==-s==：指定产生随机事件种子值（seed），相同的种子值产生相同的事件序列</font><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p tv.danmaku.bili -v -v -v -s 1637762067514 1000</span><br></pre></td></tr></tbody></table></figure><ul><li>一个种子值对应一个操作序列（操作事件比例、顺序）</li><li>通常用来重现问题、回归测试</li></ul></li><li><p><strong>—throttle</strong>：每个事件结束后的间隔时间——降低系统的压力（如不指定，系统会尽快的发送事件序列）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p tv.danmaku.bili -v -v -v --throttle 100 1000</span><br></pre></td></tr></tbody></table></figure></li><li><p>指定各种事件百分比的参数：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--pct-touch：指定触摸事件的百分比</span><br><span class="line">如：--pct-touch 5 表示触摸事件占5%的比例</span><br><span class="line">--pct-motion 百分比 （滑动事件）</span><br><span class="line">--pct-pinchzoom 百分比（二指缩放事件）</span><br><span class="line">--pct-trackball 百分比 （轨迹球事件）</span><br><span class="line">--pct-rotation 百分比 （屏幕旋转事件）</span><br><span class="line">--pct-nav 百分比 （导航事件 up/down/left/right）</span><br><span class="line">--pct-majornav 百分比 (主要导航事件 back key 、 menu key)</span><br><span class="line">--pct-syskeys 百分比 (系统按键事件 Home 、Back 、startCall 、 endCall 、 volumeControl)</span><br><span class="line">--pct-appswitch 百分比 （activity之间的切换）</span><br><span class="line">--pct-appswitch 百分比（启动activity事件）</span><br><span class="line">--pct-flip 百分比（键盘时间）</span><br><span class="line">--pct-anyevent 百分比（任意事件）</span><br><span class="line"></span><br><span class="line">例如：指定触摸事件20%，轨迹球事件10%</span><br><span class="line">abd shell monkey -p com.tencent.qqlive -v -v -v --pct-touch 20 --pct-trackball 10 200</span><br></pre></td></tr></tbody></table></figure></li><li><p>调试选项：</p><ul><li><p>—dbg-no-events：初始化启动的activity，但是不产生任何事件。</p></li><li><p>—hprof：指定该项后在事件序列发送前后会立即生成分析报告  —— 一般建议指定该项。</p></li><li><font color="red">--**ignore-crashes**：当应用程序崩溃或发生任何失控异常时，monkey将停止运行。如果设置此选项，monkey将继续向系统发送事件，直到计数完成</font><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p com.tencent.qqlive -v -v -v -s 1715886061484 --ignore-crashes --ignore-native-crashes --ignore-timouts --ignore-security-exceptions 10000</span><br></pre></td></tr></tbody></table></figure></li><li><font color="red">--**ignore-native-crashes**：忽略本地代码导致的崩溃。设置忽略后，Monkey将执行完所有的事件，不会因此停止</font></li><li><font color="red">--**ignore-timeouts**：通常，当应用程序发生任何超时错误（如‘Application Not Responding’对话框）时，monkey将停止运行。如果设置了此选项，monkey将继续向系统发送事件，直到计数完成</font></li><li><font color="red">--**ignore-security-exceptions**：忽略安全异常</font></li><li><p>—kill-process-after-error：发生错误后直接杀掉进程</p></li><li><p>—<strong>monitor-native-crashes</strong>：跟踪本地方法的崩溃问题</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">      </span><br></pre></td></tr></tbody></table></figure></li><li><p>—wait-dbg：知道连接了调试器才执行monkey测试。</p></li><li><p>一个比较完整的monkey命令</p><ul><li><p>一个简单的monkey命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p com.xy.android.junit  -s 1635966164169 -v -v -v 10000</span><br></pre></td></tr></tbody></table></figure></li><li><p>但是，工作中为了保证测试数量的完整进行，我们一般不会在发生错误时立刻退出压力测试。monkey测试命令如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p com.xy.android.junit -s 1635966164169 --ignore-crashes --ignore-native-crashes --ignore-timeouts --monitor-native-crashes -v -v -v 10000 &gt;E:\monkey_log\java_monkey_log.txt 2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure><p>其中，2&gt;&amp;1表示将输出和错误都重定向到文件中</p></li></ul></li><li><p>—pkg-blacklist-file：黑名单，排除某些包不执行，如—pkg-blacklist-file /data/blacklist.txt</p></li><li><p>—pkg-whitelist-file：白名单，指定执行哪些包，如—pkg-whitelist-file /data/whitelist.txt</p><ul><li><p>如图</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152209385.png" alt="image-20240516152209385"></p></li></ul></li></ul></li></ul></li><li><p>使用举例：</p><ul><li><p>命令一：用monkey去跑指定的app跑1万次，忽略异常和超时，把输出和错误都重定向到文件中</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p tv.danmaku.bili -v -v -v --ignore-crashes --ignore-native-crashes --ignore-timeouts --ignore-security-exceptions 10000&gt;C:\Users\lenovo\Desktop\37期\monkey7.txt 2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure></li><li><p>命令二：==指定seed值==用monkey去跑指定的app跑1万次，忽略异常和超时，把输出和错误都重定向到文件中，这个用来复现或回归问题</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p tv.danmaku.bili -v -v -v --ignore-crashes --ignore-native-crashes --ignore-timeouts --ignore-security-exceptions -s 1637762067514 10000 &gt; C:\Users\lenovo\Desktop\37期\monkey7.txt 2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果你想跑到出问题就停止，那就不需要忽略异常，把跑的次数设置足够大</p></li><li><font color="red">在重定向的日志中搜索**crash、anr、error、exception**等关键字看有没有出现过类似错误</font><ul><li>常见报错：部分小米手机在执行adb shell monkey命令时报java.lang.SecurityException: Injecting to another application requires INJECT_EVENTS permission，解决方法是在开发者选项页面，打开USB调试（安全设置），允许通过USB调试修改权限或模拟点击。</li></ul></li></ul></li></ul><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152225828.png" alt="image-20240516152225828" style="zoom:50%;"></p><h2 id="5、-助手工具的使用"><a href="#5、-助手工具的使用" class="headerlink" title="5、 助手工具的使用"></a>5、 助手工具的使用</h2><ul><li><p>91助手、豌豆荚、爱思助手（iOS）、PP助手、360手机助手等等；</p></li><li><p>在测试中，可以借助这些助手工具完成测试App的安装、卸载，升级测试等，包括iOSApp和Android App；</p></li><li><p>以91助手为例，要通过助手管理手机，需要：</p><ul><li><p>1）开启手机的开发者模式，再打开USB调试；</p><ul><li>android手机需要做这个操作，步骤：打开设置—&gt;打开关于手机—&gt;找到版本号连续点击3次以上，直到看到进入开发者模式—&gt;找到开发者模式并进入—-&gt;打卡usb调试—&gt;然后用数据线连接电脑，在配对信息中点允许配对</li></ul></li><li><p>2）用数据线连接PC与手机，按提示点击确定，91助手会在手机上安装一个91助手App，允许其安装即可；</p></li><li><p>3）正常情况下就可以连接PC与手机了，把测试App拖到应用一栏里，就可以安装App；</p></li><li><p>注意：</p></li><li><p>1）测试的iOS App安装，需要提前获取到测试设备UDID，把UDID写到测试App中一起打包，这样才能在测试设备上安装这个App；并且信任</p></li><li><p>2）测试App中使用的是测试证书，在安装完成测试iOSApp后，还需要在设置下面信任测试证书，才能使用这个测试App；</p></li><li><p>3）91助手可以通过iOS设备日志查看苹果设备的日志信息。</p></li><li><p>安装卸载升级操作：</p><ul><li><p>如图</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152241066.png" alt="image-20240516152241066" style="zoom:50%;"></p></li></ul></li><li><p>截图，日志，崩溃分析</p><ul><li><p>如图</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152258122.png" alt="image-20240516152258122" style="zoom:50%;"></p></li></ul></li></ul></li></ul><p>使用助手工具的主要场景：安装、卸载app，打印iOS的日志等。</p><h2 id="6、-弱网测试工具"><a href="#6、-弱网测试工具" class="headerlink" title="6、 弱网测试工具"></a>6、 弱网测试工具</h2><h3 id="（1）弱网测试基本概念"><a href="#（1）弱网测试基本概念" class="headerlink" title="（1）弱网测试基本概念"></a>（1）弱网测试基本概念</h3><p>什么是弱网：延迟、丢包、抖动（接收顺序与发送顺序不一样）、带宽小</p><p>生活中的典型弱网场景：电梯、地下室、地铁（高峰、错峰）、公交（高峰、错峰）、高铁、山里</p><p>为什么只有app要做弱网测试：app安装在移动终端，它的网络场景是变化的</p><p>弱网测试的基本标准：app在弱网情况下不出现<strong>闪退、崩溃、ANR</strong>等问题（一直处在加载中，不算bug）</p><h3 id="（2）弱网测试工具（模拟弱网）"><a href="#（2）弱网测试工具（模拟弱网）" class="headerlink" title="（2）弱网测试工具（模拟弱网）"></a>（2）弱网测试工具（模拟弱网）</h3><h4 id="1）QNET-1"><a href="#1）QNET-1" class="headerlink" title="1）QNET"></a>1）QNET</h4><ul><li><p>QNET是当前最好用的弱网测试工具，能够模拟延迟、丢包、抖动等弱网场景，它以独立的app方式运行，操作简单，它里面内置了国内所有省份和海外部分国家的网络数据以及常见的弱网场景（公交高晚高峰、地铁早晚高峰、停车场、电梯等），在使用的时候直接选择内置的场景就可以了。</p></li><li><p>安装后默认有连续丢包、正常网络、100%丢包、极差网络四个模板。</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152319218.png" alt="image-20240516152319218" style="zoom:50%;"></p></li><li><p>除此之外，还可以新增模板，新增模板时可以选择类型为场景模板，就可以直接选择QNET中预置的场景。</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152331991.png" alt="image-20240516152331991" style="zoom:50%;"></p></li></ul><h4 id="2）fiddler-1"><a href="#2）fiddler-1" class="headerlink" title="2）fiddler"></a>2）fiddler</h4><p>通过fiddler限速</p><p>fiddler的原理：在主机和网络之间增加了一个代理，主机所有的报文都要经过该代理，fiddler因此可以抓取主机的所有包，修改fidder配置文件后就可以进行限速</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152345245.png" alt="image-20240516152345245" style="zoom:50%;"></p><p>通过fiddler来实现限速步骤：</p><p>（1）在Rules-》CustomizeRules下面，首先要保证m_SimulateModem值为true，表示开启限速</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152358900.png" alt="image-20240516152358900"></p><p>（2）如下两行代码分别表示对上传和下载的限速，第一行表示上传1KB的延时是300ms，相当于上传速度是1KB/300ms=3.33333KB/s，第二行表示下载1KB延时150ms，通过设置这两个延时来控制网速，延时越大网速越慢</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152409115.png" alt="image-20240516152409115" style="zoom:80%;"></p><h4 id="3）360-WiFi限速"><a href="#3）360-WiFi限速" class="headerlink" title="3）360 WiFi限速"></a>3）360 WiFi限速</h4><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152420174.png" alt="image-20240516152420174" style="zoom:50%;"></p><h4 id="4）修改网络制式"><a href="#4）修改网络制式" class="headerlink" title="4）修改网络制式"></a>4）修改网络制式</h4><p>如果使用移动网络，通过在手机上选择不同的网络制式：选择更低的网络制式</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152440671.png" alt="image-20240516152440671" style="zoom:33%;"></p><h2 id="7、-App的性能测试性能狗"><a href="#7、-App的性能测试性能狗" class="headerlink" title="7、 App的性能测试性能狗"></a>7、 App的性能测试性能狗</h2><h3 id="（1）什么是性能狗PerfDog"><a href="#（1）什么是性能狗PerfDog" class="headerlink" title="（1）什么是性能狗PerfDog"></a>（1）什么是性能狗PerfDog</h3><p>performance</p><p>charles_shenxxxx@foxmail.com/perdog2020</p><p>PerfDog是腾讯WeTest团队研发的一款性能测试工具，是移动全平台iOS/Android性能测试、分析工具平台。快速定位分析性能问题，提升APP应用及游戏性能和品质。手机无需ROOT/越狱，手机硬件、游戏及应用APP也无需做任何修改，极简化即插即用。</p><p>PerfDog支持移动平台所有应用程序（游戏、APP应用、浏览器、小程序、小游戏、H5、后台系统进程等）、Android模拟器、云真机等性能测试。支持APP多进程测试(如Android多子进程及iOS扩展进程APP Extension)。</p><h3 id="（2）性能狗的使用演示"><a href="#（2）性能狗的使用演示" class="headerlink" title="（2）性能狗的使用演示"></a>（2）性能狗的使用演示</h3><p>参考：<a href="https://perfdog.qq.com/article_detail?id=10089&amp;issue_id=0&amp;plat_id=1">https://perfdog.qq.com/article_detail?id=10089&amp;issue_id=0&amp;plat_id=1</a></p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152500994.png" alt="image-20240516152500994"></p><h3 id="（3）关注的指标"><a href="#（3）关注的指标" class="headerlink" title="（3）关注的指标"></a>（3）关注的指标</h3><ul><li>CPU占用率，行业平均指标：9.71%（仅供参考）</li><li>内存占用（MB）：行业优秀0.03MB，行业平均值：124.88MB（仅供参考）</li><li>流量（Mb），行业平均指标7.22Mb（仅供参考），这个值一般用流量总和来衡量的，流量总量=上行流量+下行流量</li><li>CPU温度(°C)：行业最优指标0.38（仅供参考）， 行业平均指标41.7（仅供参考），关注在运行程序期间温度的平均值即可</li><li>帧速率（流畅度）（fps）：帧速率也称为FPS，Frames PerSecond的缩写，也就是俗称的刷新率(帧率)是指每秒钟刷新的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。每秒钟帧数(FPS)越多，所显示的动作就会越流畅。捕捉动态视频内容时，此数字愈高愈好</li><li>GPU占用率(%)：行业最优指标0.12，行业平均指标11.25</li><li>耗电量(mAh)：行业最优指标1.01（仅供参考），行业平均指标：270.19（仅供参考），耗电量关注的是耗电量的平均值</li></ul><h2 id="8、-App抓包"><a href="#8、-App抓包" class="headerlink" title="8、 App抓包"></a>8、 App抓包</h2><p>主流的抓包工具：开发者工具F12、Charles、Fiddler、Wireshark等</p><p>Charles抓包工具的使用</p><p>Charles/Fiddler抓包的原理：启动后会监听在8888端口，同时它会修改电脑的代理为http=127.0.0.1:8888;https=127.0.0.1:8888，表示Charles/Fiddler是作为电脑的代理工作。</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152758822.png" alt="image-20240516152758822" style="zoom:50%;"></p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152813949.png" alt="image-20240516152813949" style="zoom:50%;"></p><p>https是加密的，http是不加密的，https=http+ssl</p><p>抓https的包，需要安装证书：Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate，安装之后通过抓一个https的包来验证是否安装成功。</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152830079.png" alt="image-20240516152830079" style="zoom:50%;"></p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20210826144949060.png" alt="image-20210826144949060" style="zoom:50%;"></p><p>抓App的包的步骤：</p><p>1、把手机和PC连接到同一个Wi-Fi；</p><p>2、修改手机的代理，配置成PC的IP（Wi-Fi分配的IP）和端口（Charles的端口），保存；</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516152956985.png" alt="image-20240516152956985" style="zoom:50%;"></p><p>3、在Charles上会弹出如下窗口，点击Allow运行手机连接Charles，到这一步，在Charles上就可以抓到手机的http包了，如果要抓https的包，继续第4步操作；</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20210730142504027.png" alt="image-20210730142504027" style="zoom:50%;"></p><p>4、在Charles上开启SSL代理</p><p>Proxy -&gt; SSL Proxying Settings—&gt;勾选Enable SSL Proxying</p><p>点击Add,点击Add，Host设置要抓取的https接口地址和端口</p><p>Host : <em> (使用通配符表示检测所有网络请求；建议还是设置单个需要抓取的https host，尽量避免使用 </em> 通配符)</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516153010295.png" alt="image-20240516153010295" style="zoom:50%;"></p><p>5、在手机端安装Charles证书</p><p>在Charles上点击Help-&gt;SSL Proxying —&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser,会提示你如何在手机端配置代理以及安装证书：</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516153021804.png" alt="image-20240516153021804" style="zoom:67%;"></p><p>点击后提示如下：</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516153031116.png" alt="image-20240516153031116" style="zoom:50%;"></p><p>然后在手机浏览器上打开<a href="http://chls.pro/ssl下载证书，下载到一个你能找到的目录，别下载完就找不到了。">http://chls.pro/ssl下载证书，下载到一个你能找到的目录，别下载完就找不到了。</a></p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20240516153058833.png" alt="image-20240516153058833" style="zoom:50%;"></p><p>下载后在手机的系统设置-》更多设置-》系统安全-》加密与凭据-》从存储设备安装，安装刚刚下载的证书。</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20210802085220421.png" alt="image-20210802085220421"></p><p>安装证书后，就可以抓到https的包了。</p><p><a href="https://blog.csdn.net/bsmmaoshenbo/article/details/85252716">https://blog.csdn.net/bsmmaoshenbo/article/details/85252716</a></p><p>HTTP请求的常用方法：</p><ul><li>GET：表示从服务器获取资源</li><li>POST：表示向服务器提交资源</li><li>PUT：表示修改资源</li><li>DELETE：表示删除资源</li></ul><p>用Fiddler抓取手机App的包的步骤：</p><p>1、安装Fiddler，配置Fiddler，勾选允许远程电脑连接</p><p><img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20210914114038393.png" alt="image-20210914114038393"></p><p>2、把手机和电脑连接到同一个Wi-Fi里；</p><p>3、查到电脑的Wi-Fi的IP地址<img src="/2024/05/16/APP%E6%B5%8B%E8%AF%95/APP%E6%B5%8B%E8%AF%95/image-20210914114436140.png" alt="image-20210914114436140"></p><p>4、连接Fiddler下载证书并安装</p><p>​    在手机浏览器中打开 <a href="http://电脑IP:8888">http://电脑IP:8888</a></p><p>5、修改手机的代理，IP为电脑的Wi-Fi IP，端口为8888</p><p>6、在手机上打开浏览器，输入<a href="https://m.baidu.com，正常在Fiddler就可以抓到手机浏览器的包">https://m.baidu.com，正常在Fiddler就可以抓到手机浏览器的包</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、App测试概念&quot;&gt;&lt;a href=&quot;#一、App测试概念&quot; class=&quot;headerlink&quot; title=&quot;一、App测试概念&quot;&gt;&lt;/a&gt;一、App测试概念&lt;/h1&gt;&lt;h2 id=&quot;1、App的分类&quot;&gt;&lt;a href=&quot;#1、App的分类&quot; class=&quot;headerlink&quot; title=&quot;1、App的分类&quot;&gt;&lt;/a&gt;1、App的分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;iOS是基于Unix内核深度定制的一个移动设备操作系统；Android是一个Linux发行版，用于移动设备；Linux是类Unix系统；iOS是闭源的，Android是开源的；iOS是苹果公司主导，Android是谷歌主导的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从操作系统平台来分，主要分为如下两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iOS App&lt;ul&gt;
&lt;li&gt;安装在苹果的iOS操作系统上，主要是iPhone、iPad、iWatch等&lt;/li&gt;
&lt;li&gt;同一款应用，通常对iPhone和iPad要出两个不同的版本，因为要针对iPhone和iPad两种终端的不同分辨率、屏幕尺寸分别适配&lt;/li&gt;
&lt;li&gt;iOS App的安装包后缀为.ipa&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Android App&lt;ul&gt;
&lt;li&gt;安装在Android操作系统上，主要是Android手机和Android平板&lt;/li&gt;
&lt;li&gt;同一款应用，通常对Android手机和Android平板要出两个不同的版本，因为要针对Android手机和Android平板两种终端的不同分辨率、屏幕尺寸分别适配&lt;/li&gt;
&lt;li&gt;Android App的安装包后缀为.apk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从技术实现上，目前主流的App可以分为原生App、混合App和Web App两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原生App&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原生App又称Native App，就是利用Android、iOS平台官方的开发语言、开发类库、工具进行开发。比如安卓的Java语言，iOS的Object-c语言。在应用性能上和交互体验上应该是好的。原生App需要针对Android和iOS平台开发两套不同代码，成本高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Web App&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指的是移动端的Web浏览器，主要借助H5网页技术进行开发，相当于开发一个网页，然后分别生成Android和iOS的壳。这种App只需要一套编程开发语言，技术简单，人力少，周期短。缺点是用户体验相对差。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;混合App&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;混合App又称Hybrid App，是介于原生App和Web App之间的一种App形式。&lt;/li&gt;
&lt;li&gt;uni-app是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等14个平台。&lt;/li&gt;
&lt;li&gt;了解uni-app：&lt;a href=&quot;https://uniapp.dcloud.io/README&quot;&gt;https://uniapp.dcloud.io/README&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;目前国内基本只有大厂还在玩原生App，中小企业以混合App为主。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="APP测试" scheme="https://laylaycjl.github.io/tags/APP%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>测试环境的部署与维护</title>
    <link href="https://laylaycjl.github.io/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/"/>
    <id>https://laylaycjl.github.io/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/</id>
    <published>2024-05-11T06:02:57.000Z</published>
    <updated>2024-05-13T08:33:43.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><h2 id="1、环境搭建概念"><a href="#1、环境搭建概念" class="headerlink" title="1、环境搭建概念"></a>1、环境搭建概念</h2><ul><li>环境 = 硬件服务器（或者云服务器）+ 操作系统（Linux）+ 数据库（MySQL、Oracle、Redis）+ 软件服务器（Apache HTTP Server、Nginx、Tomcat）+ 要测试的项目包；</li><li>环境搭建，意思就是把要测试的系统运行起来，属于执行测试之前的准备工作</li></ul><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240511140839274.png" alt="image-20240511140839274" style="zoom: 67%;"></p><h2 id="2、开发环境、测试环境、UAT环境、生产环境"><a href="#2、开发环境、测试环境、UAT环境、生产环境" class="headerlink" title="2、开发环境、测试环境、UAT环境、生产环境"></a>2、开发环境、测试环境、UAT环境、生产环境</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><p>在大多数公司，一般会存在以下几套环境：</p><ul><li><p>开发环境（development）：</p><ul><li>开发人员专门用于开发、调试的环境，一般配置可以比较随意，为了开发调试方便，一般会把<u>日志级别调到最低</u></li><li>开发人员的<strong>调试</strong>、Bug修改后的<strong>自测</strong>等工作都是在开发环境上完成</li><li>开发环境由开发人员负责部署与维护。</li></ul></li><li><p>测试环境（testing）：</p><ul><li>测试人员用于测试系统的环境，一般是尽量按照生产环境的配置来部署测试环境，系统只有在测试环境上经过充分验证后才会被部署到生产环境上</li><li>测试环境一般由测试人员负责部署与维护，也有的公司由运维来负责维护。</li></ul></li><li><p>UAT环境（User Acceptance Test）：主要是用来作为客户体验和验收的环境</p></li><li><p>生产环境（production）：</p><ul><li><p>也叫商用环境或客户现网环境，是指正式提供对外服务的，一般会把<u>日志级别调到最高</u>，一般生产环境都在客户现场</p></li><li><p>日志级别过低时，日志文件内容过多，不仅占用磁盘空间，且频繁打印日志会占用服务器的I/O</p></li></ul></li></ul><p>注意：</p><p>1、开发环境、测试环境、UAT环境、生产环境一般是分开的，避免相互干扰</p><p>2、对测试而言，若同时有多个项目进行测试，可能会同时维护多套测试环境，避免不同系统之间的干扰</p><span id="more"></span><h3 id="（2）环境之间的关系"><a href="#（2）环境之间的关系" class="headerlink" title="（2）环境之间的关系"></a>（2）环境之间的关系</h3><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240511141810466.png" alt="image-20240511141810466" style="zoom:67%;"></p><p>软件产品的开发、测试、上线过程：</p><p>1、开发人员先在开发环境上调试好了就会发版（程序+数据+文档）</p><p>2、测试人员拿到版本后在测试环境上验证</p><p>3、只有在测试环境上经过充分验证的版本才会上线到生成环境上</p><h2 id="3、工作中使用Linux的场景"><a href="#3、工作中使用Linux的场景" class="headerlink" title="3、工作中使用Linux的场景"></a>3、工作中使用Linux的场景</h2><h3 id="（1）学习中的场景："><a href="#（1）学习中的场景：" class="headerlink" title="（1）学习中的场景："></a>（1）学习中的场景：</h3><p>在个人电脑上划虚拟机安装Linux系统。</p><h3 id="（2）工作中的场景："><a href="#（2）工作中的场景：" class="headerlink" title="（2）工作中的场景："></a>（2）工作中的场景：</h3><ul><li><p>使用云服务器</p><ul><li><p>公有云</p><ul><li><p>阿里云、腾讯云、华为云、百度云、亚马逊云</p><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240511142656466.png" alt="image-20240511142656466" style="zoom:50%;"></p></li><li><p>优势是灵活、可扩展、低成本等</p></li></ul></li><li><p>私有云：</p><ul><li>私有云是一个公司使用的特定云环境</li><li>不同于公有云模式中共享的设施使用，私有云模式中每个公司使用的服务器或存储应用都是单独的</li><li>优势是安全、灵活、可扩展等</li></ul></li></ul></li><li><p>传统方式：</p><ul><li>公司购买物理服务器，在服务器上划虚拟机安装Linux，然后再安装业务软件</li><li>常用的Linux操作系统发行版：CentOS、Redhat、Ubuntu等</li></ul></li></ul><h1 id="二、服务器软件的概念"><a href="#二、服务器软件的概念" class="headerlink" title="二、服务器软件的概念"></a>二、服务器软件的概念</h1><h3 id="1、服务器硬件和服务器软件"><a href="#1、服务器硬件和服务器软件" class="headerlink" title="1、服务器硬件和服务器软件"></a>1、服务器硬件和服务器软件</h3><ul><li><p>服务器硬件</p><ul><li><p>一台性能、稳定性、扩展性比我们个人普通PC更强的一台计算机</p></li><li><p>服务器也需要安装操作系统才能使用它，现在很多企业也都在使用云服务器</p></li></ul><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240511143008637.png" alt="image-20240511143008637" style="zoom:50%;"></p></li><li><p>服务器软件</p><ul><li>广义上讲，运行在服务器操作系统之上，绑定了服务器特定的IP地址，并且在某一个<strong>端口</strong>监听用户的请求</li><li>提供服务的软件都可以叫做服务器软件</li></ul><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240511143020817.png" alt="image-20240511143020817" style="zoom:50%;"></p></li></ul><h3 id="2、服务器软件的几个概念"><a href="#2、服务器软件的几个概念" class="headerlink" title="2、服务器软件的几个概念"></a>2、服务器软件的几个概念</h3><ul><li><p>服务器软件提供的服务又可以分为<u>静态服务</u>和<u>动态服务</u>两类：</p><ul><li><strong>静态</strong>服务：主要提供静态资源，不同用户访问到的资源相同；</li><li><strong>动态</strong>服务：提供动态服务，不同用户访问到的资源不同；</li></ul></li><li><p>服务器软件分为<u>Web服务器</u>和<u>应用服务器</u>两类：</p><ul><li>Web服务器：提供Web服务的服务器，因为Web服务器主要支持的协议就是HTTP协议，所以通常Web服务器和HTTP服务器是同一个概念，<strong>Web服务器提供静态服务</strong>；</li><li>应用服务器：应用服务器是指通过各种协议把商业逻辑曝露给客户端的程序。它提供了访问商业逻辑的途径以供客户端应用程序使用，<strong>应用服务器提供动态服务</strong>。</li></ul></li></ul><h3 id="3、主流服务器软件"><a href="#3、主流服务器软件" class="headerlink" title="3、主流服务器软件"></a>3、主流服务器软件</h3><ul><li>主流的Web服务器：Apache HTTP Server、==Nginx==、lighttpd、IIS</li><li>主流的应用服务器：==Tomcat==、Weblogic、Jetty、JBoss</li></ul><blockquote><p>1、Tomcat、Apache HTTP Server、Nginx、Jetty、JBoss是开源免费的</p><p>2、Apache Tomcat（简称Tomcat）、Apache HTTP Server（简称Apache）都是属于Apache软件基金会的产品</p></blockquote><h4 id="（1）Nginx服务器（web-静态）"><a href="#（1）Nginx服务器（web-静态）" class="headerlink" title="（1）Nginx服务器（web/静态）"></a>（1）Nginx服务器（web/静态）</h4><ul><li>典型的<strong>静态服务器</strong>，除了作为Web服务器作用外，也可做反向代理、负载均衡<ul><li>反向代理：Nginx就像是服务器端的代理人，对用户来说，只能感知到Nginx，不知道内部请求是如何处理的，是交给具体哪个Tomcat服务器处理的</li><li>负载均衡：当负载过重时，Nginx可以调用多个服务器来分担负载</li></ul></li><li>一般<strong>放在最前面直面用户</strong>，和后端Tomcat打配合</li><li>纯C写的，<strong>性能很好、内存消耗极少、稳定性也相当好</strong>，<strong>能够支持高达50,000个并发</strong>连接数的响应，互联网公司重度使用</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看Nginx日志：</span><br><span class="line">cd /usr/local/nginx/logs</span><br><span class="line">tail -f erro.log</span><br><span class="line"></span><br><span class="line">编辑Nginx配置：</span><br><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vim nginx.conf</span><br><span class="line"></span><br><span class="line">重启Nginx：</span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></tbody></table></figure><h4 id="（2）Tomcat服务器（应用-动态）"><a href="#（2）Tomcat服务器（应用-动态）" class="headerlink" title="（2）Tomcat服务器（应用/动态）"></a>（2）Tomcat服务器（应用/动态）</h4><ul><li>由Apache基金会出品，典型的<strong>应用服务器</strong>软件，是符合Servlet标准的应用容器</li><li>也可以提供http服务，但一般不会作为http服务器</li><li>是Spring Boot框架默认的内置服务器</li></ul><h4 id="（3）Nginx-Tomcat之间的配合"><a href="#（3）Nginx-Tomcat之间的配合" class="headerlink" title="（3）Nginx+Tomcat之间的配合"></a>（3）Nginx+Tomcat之间的配合</h4><h5 id="1）实现动静分离"><a href="#1）实现动静分离" class="headerlink" title="1）实现动静分离"></a>1）实现动静分离</h5><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240511144645270.png" alt="image-20240511144645270" style="zoom: 33%;"></p><p>Nginx：绑定服务器ip，并监听一个端口（默认80）</p><p>当客户端用户请求静态资源时，Nginx可以转发请求静态资源</p><p>当客户端用户请求动态资源时，Nginx可以转发请求给Tomcat调取动态资源</p><h5 id="2）实现负载均衡"><a href="#2）实现负载均衡" class="headerlink" title="2）实现负载均衡"></a>2）实现负载均衡</h5><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240511145152797.png" alt="image-20240511145152797" style="zoom: 33%;"></p><p>Nginx负载均衡的策略</p><ul><li><p>轮询、权重</p><p>轮询：一个请求一个请求轮流分配，各个服务器分配到的请求数量差不多</p><p>权重：某个服务器配置更好，权重更高，给它分配的请求就更多</p></li><li><p>可在Nginx.conf的配置文件里配置负载均衡的策略</p></li></ul><h4 id="（4）Tengine服务器（基于Nginx）"><a href="#（4）Tengine服务器（基于Nginx）" class="headerlink" title="（4）Tengine服务器（基于Nginx）"></a>（4）Tengine服务器（基于Nginx）</h4><p>阿里出品，基于Nginx服务器做的改造(加强和封装)，对大流量场景做了很多高级功能，性能、稳定性优秀；</p><h4 id="（5）Apache服务器（不如Nginx）"><a href="#（5）Apache服务器（不如Nginx）" class="headerlink" title="（5）Apache服务器（不如Nginx）"></a>（5）Apache服务器（不如Nginx）</h4><p>指Apache HTTP Server，也是静态服务器，但是不如Nginx</p><h4 id="（6）IIS服务器"><a href="#（6）IIS服务器" class="headerlink" title="（6）IIS服务器"></a>（6）IIS服务器</h4><p>只能用在Windows下运行，是具有应用服务器能力的http服务器</p><h4 id="（7）Jetty服务器"><a href="#（7）Jetty服务器" class="headerlink" title="（7）Jetty服务器"></a>（7）Jetty服务器</h4><p>跟Tomcat是一个性质的东西，符合Servlet标准的应用容器，也是Spring Boot框架支持的服务器，但不是默认的</p><h4 id="（8）几种商用的服务器软件"><a href="#（8）几种商用的服务器软件" class="headerlink" title="（8）几种商用的服务器软件"></a>（8）几种商用的服务器软件</h4><ul><li>JBoss(从8版开始更名为WildFly)：不仅是Servlet应用容器，更是EJB的应用容器，整套JavaEE框架部署的解决方案；</li><li>WebLogic：Oracle公司出品，用于部署企业级JavaEE应用，全能型，几乎支持JavaEE所有的应用规范；</li><li>WebSphere：IBM公司出品，支持更多JavaEE的应用规范的综合应用服务器；</li></ul><h3 id="4、LAMP与LNMP网站架构"><a href="#4、LAMP与LNMP网站架构" class="headerlink" title="4、LAMP与LNMP网站架构"></a>4、LAMP与LNMP网站架构</h3><p>LAMP：Linux+Apache HTTP Server+MySQL+PHP</p><p>LNMP：Linux+Nginx+MySQL+PHP</p><h3 id="5、Jar包和War包"><a href="#5、Jar包和War包" class="headerlink" title="5、Jar包和War包"></a>5、Jar包和War包</h3><h4 id="（1）JAR（Java-Archive-File）"><a href="#（1）JAR（Java-Archive-File）" class="headerlink" title="（1）JAR（Java Archive File）"></a>（1）JAR（Java Archive File）</h4><ul><li>Java Archive File（ Java归档文件），是<strong>与平台无关的文件格式</strong>，它允许将许多文件组合成一个压缩文件</li><li>Maven（项目包的管理工具）项目的默认打包格式就是Jar包</li><li>Jar包可以通过<code>java -jar xx.jar</code>命令来运行。</li></ul><h4 id="（2）WAR（Web-Application-Archive）"><a href="#（2）WAR（Web-Application-Archive）" class="headerlink" title="（2）WAR（Web Application Archive）"></a>（2）WAR（Web Application Archive）</h4><ul><li><p>Web Application Archive（Web应用归档），表示这是一个Java的Web应用程序的包</p></li><li><p>WAR包是一个可以直接运行的web模块，通常用于网站，打成包部署到容器（Tomcat可以理解为一个容器）中</p><p>以Tomcat来说，将war包放置在其webapps目录下，然后启动Tomcat，这个包就会自动解压，就相当于发布了</p></li></ul><h1 id="三、Tomcat的安装与项目部署"><a href="#三、Tomcat的安装与项目部署" class="headerlink" title="三、Tomcat的安装与项目部署"></a>三、Tomcat的安装与项目部署</h1><h3 id="1、Tomcat的目录介绍"><a href="#1、Tomcat的目录介绍" class="headerlink" title="1、Tomcat的目录介绍"></a>1、Tomcat的目录介绍</h3><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240511160255214.png" alt="image-20240511160255214" style="zoom: 50%;"></p><h3 id="2、Tomcat的启停脚本"><a href="#2、Tomcat的启停脚本" class="headerlink" title="2、Tomcat的启停脚本"></a>2、Tomcat的启停脚本</h3><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240511160316812.png" alt="image-20240511160316812" style="zoom:50%;"></p><h3 id="3、Tomcat的日志"><a href="#3、Tomcat的日志" class="headerlink" title="3、Tomcat的日志"></a>3、Tomcat的日志</h3><ul><li><p>日志目录</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/tomcat/logs</span><br></pre></td></tr></tbody></table></figure></li><li><p>==catalina.out==：Linux下所有的错误日志和打印语句，都放在此文件中，如果Tomcat启动有问题，要看这个日志来分析</p></li><li><p>==localhost_access_log.日期.txt==：存放tomcat请求的所有路径、时间、请求方式、返回码等；</p></li><li><p>日志级别</p><p>DEBUG（调试）&lt;INFO（信息）&lt;WARN（警告）&lt;ERROR（错误）&lt;FATAL（致命）</p><p>日志级别开关：比如设置开关的级别是ERROR，那么只会输出ERROR及以上级别的日志到日志文件</p></li></ul><h3 id="4、修改Tomcat的监听端口"><a href="#4、修改Tomcat的监听端口" class="headerlink" title="4、修改Tomcat的监听端口"></a>4、修改Tomcat的监听端口</h3><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240511160504736.png" alt="image-20240511160504736" style="zoom:50%;"></p><ul><li>配置文件：server.xml</li><li>修改如上的port，改成任意一个没有没占用的端口，改了之后要重启tomcat才生效</li><li>在生产环境上，通常会修改软件的默认监听端口</li></ul><h1 id="四、升级与维护"><a href="#四、升级与维护" class="headerlink" title="四、升级与维护"></a>四、升级与维护</h1><h2 id="1、测试环境的升级"><a href="#1、测试环境的升级" class="headerlink" title="1、测试环境的升级"></a>1、测试环境的升级</h2><ul><li><p>当测试人员提交Bug后，开发就需要修复，修复完之后开发会提供更新后的包或者补丁，测试人员在测试环境上安装新提供的包进行回归测试</p><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240511160703987.png" alt="image-20240511160703987" style="zoom:50%;"></p><p>项目测试三轮迭代，每一轮迭代测试环境怎么维护?<br>1）第一轮迭代怎么搭建环境?<br>从0开始搭建:<br>1、准备服务器，2、安装操作系统，3、安装基础软件（服务器软件、JDKmysql、 redis、mysql、redis)4、部署项目包，运行<br>2）第二轮、第三轮迭代有什么不同?<br>主要是在前面迭代的测试环境上，更新要测试的项目包</p></li><li><p>补丁：开发为修复发现的Bug而发布的包/程序就是补丁</p><p>在大型系统开发中，开发人员为解决每一轮测试中发现的Bug，往往通过发布补丁而不是全量的版本包来实现，用补丁的方式更灵活而且更方便安装</p></li></ul><h1 id="四、测试环境问题排查"><a href="#四、测试环境问题排查" class="headerlink" title="四、测试环境问题排查"></a>四、测试环境问题排查</h1><p>各部分之间的关系：</p><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240513155026409.png" alt="image-20240513155026409" style="zoom:50%;"></p><h2 id="（1）前台启动失败，报500错误"><a href="#（1）前台启动失败，报500错误" class="headerlink" title="（1）前台启动失败，报500错误"></a>（1）前台启动失败，报500错误</h2><p>1、检查IP地址是否正确、可达</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping ip地址</span><br></pre></td></tr></tbody></table></figure><p>2、检查端口通不通（dos）</p><p>前提是开通 tell net</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet ip端口</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240513154706899.png" alt="image-20240513154706899" style="zoom:50%;"></p><p>3、端口不通，怎么排查</p><p>1）lsof-i:8099，有没有对应的进程，服务是否运行正常</p><p>2）虚拟机:检查防火墙是否关闭</p><p>3）云服务器:检查安全规则，是否允许了对应的端口</p><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240513154844073.png" alt="image-20240513154844073" style="zoom:50%;"></p><h2 id="2、前台运行成功，后台报502错误"><a href="#2、前台运行成功，后台报502错误" class="headerlink" title="2、前台运行成功，后台报502错误"></a>2、前台运行成功，后台报502错误</h2><p>后端配置文件：</p><p>application-druid.yml、application.yml</p><p>（配置完之后需要删掉原包，并重新打包运行）</p><p>（1）检查后台端口是否正在被Java程序使用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:18080</span><br></pre></td></tr></tbody></table></figure><p>*如何设置后端程序后台运行？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar ruoyi-admin.jar &amp;</span><br><span class="line">nohup:表示记录日志</span><br><span class="line">最后&amp;符号：表示后台运行</span><br></pre></td></tr></tbody></table></figure><p>（2）看日志</p><p>tomcat日志</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/tomcat/logs/catalina.out</span><br></pre></td></tr></tbody></table></figure><p>nginx日志</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/logs/error.log</span><br></pre></td></tr></tbody></table></figure><p>后端日志</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行jar包指令：</span><br><span class="line">nohup java -jar xxx.jar &amp;</span><br><span class="line">产生的日志文件</span><br><span class="line">nohup.out</span><br></pre></td></tr></tbody></table></figure><p>*修改后台日志级别</p><p>application.yml中</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line"> level：</span><br><span class="line">xxx: debug(最低级，记录所有信息)</span><br><span class="line">     error(只记录错误信息)</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240513162644358.png" alt="image-20240513162644358" style="zoom: 80%;"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、环境搭建&quot;&gt;&lt;a href=&quot;#一、环境搭建&quot; class=&quot;headerlink&quot; title=&quot;一、环境搭建&quot;&gt;&lt;/a&gt;一、环境搭建&lt;/h1&gt;&lt;h2 id=&quot;1、环境搭建概念&quot;&gt;&lt;a href=&quot;#1、环境搭建概念&quot; class=&quot;headerlink&quot; title=&quot;1、环境搭建概念&quot;&gt;&lt;/a&gt;1、环境搭建概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;环境 = 硬件服务器（或者云服务器）+ 操作系统（Linux）+ 数据库（MySQL、Oracle、Redis）+ 软件服务器（Apache HTTP Server、Nginx、Tomcat）+ 要测试的项目包；&lt;/li&gt;
&lt;li&gt;环境搭建，意思就是把要测试的系统运行起来，属于执行测试之前的准备工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/2024/05/11/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%BB%B4%E6%8A%A4/image-20240511140839274.png&quot; alt=&quot;image-20240511140839274&quot; style=&quot;zoom: 67%;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、开发环境、测试环境、UAT环境、生产环境&quot;&gt;&lt;a href=&quot;#2、开发环境、测试环境、UAT环境、生产环境&quot; class=&quot;headerlink&quot; title=&quot;2、开发环境、测试环境、UAT环境、生产环境&quot;&gt;&lt;/a&gt;2、开发环境、测试环境、UAT环境、生产环境&lt;/h2&gt;&lt;h3 id=&quot;（1）概念&quot;&gt;&lt;a href=&quot;#（1）概念&quot; class=&quot;headerlink&quot; title=&quot;（1）概念&quot;&gt;&lt;/a&gt;（1）概念&lt;/h3&gt;&lt;p&gt;在大多数公司，一般会存在以下几套环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开发环境（development）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发人员专门用于开发、调试的环境，一般配置可以比较随意，为了开发调试方便，一般会把&lt;u&gt;日志级别调到最低&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;开发人员的&lt;strong&gt;调试&lt;/strong&gt;、Bug修改后的&lt;strong&gt;自测&lt;/strong&gt;等工作都是在开发环境上完成&lt;/li&gt;
&lt;li&gt;开发环境由开发人员负责部署与维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试环境（testing）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试人员用于测试系统的环境，一般是尽量按照生产环境的配置来部署测试环境，系统只有在测试环境上经过充分验证后才会被部署到生产环境上&lt;/li&gt;
&lt;li&gt;测试环境一般由测试人员负责部署与维护，也有的公司由运维来负责维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UAT环境（User Acceptance Test）：主要是用来作为客户体验和验收的环境&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生产环境（production）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;也叫商用环境或客户现网环境，是指正式提供对外服务的，一般会把&lt;u&gt;日志级别调到最高&lt;/u&gt;，一般生产环境都在客户现场&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志级别过低时，日志文件内容过多，不仅占用磁盘空间，且频繁打印日志会占用服务器的I/O&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1、开发环境、测试环境、UAT环境、生产环境一般是分开的，避免相互干扰&lt;/p&gt;
&lt;p&gt;2、对测试而言，若同时有多个项目进行测试，可能会同时维护多套测试环境，避免不同系统之间的干扰&lt;/p&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试环境" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询及其他</title>
    <link href="https://laylaycjl.github.io/2024/05/09/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/"/>
    <id>https://laylaycjl.github.io/2024/05/09/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/</id>
    <published>2024-05-09T07:15:32.000Z</published>
    <updated>2024-05-11T04:01:08.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-演示的数据库的表结构说明"><a href="#0-演示的数据库的表结构说明" class="headerlink" title="0. 演示的数据库的表结构说明"></a>0. 演示的数据库的表结构说明</h1><p><img src="/2024/05/09/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/image-20240509151831003.png" alt="image-20240509151831003" style="zoom: 67%;"></p><h1 id="1-表的查询"><a href="#1-表的查询" class="headerlink" title="1. 表的查询"></a>1. 表的查询</h1><h2 id="1-1-查询表的一个或多个字段的值"><a href="#1-1-查询表的一个或多个字段的值" class="headerlink" title="1.1 查询表的一个或多个字段的值"></a>1.1 查询表的一个或多个字段的值</h2><ul><li><p>语法：select 字段1,字段2,… from 表名;</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询客户ID和Name</span><br><span class="line">select cust_id,cust_name from customers;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="1-2-查询表中所有字段的值"><a href="#1-2-查询表中所有字段的值" class="headerlink" title="1.2 查询表中所有字段的值"></a>1.2 查询表中所有字段的值</h2><ul><li><p>语法：select <em> from 表名;  这是的</em>表示所有字段。</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询所有订单信息</span><br><span class="line">select * from orders;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="1-3-对查询的结果去重select-distinct"><a href="#1-3-对查询的结果去重select-distinct" class="headerlink" title="1.3 对查询的结果去重select distinct"></a>1.3 对查询的结果去重select distinct</h2><ul><li><p>语法：</p><ul><li>select distinct 字段1 from 表名;</li><li>select distinct 字段1,字段2 from 表名;    #表示对两个字段的组合去重</li></ul></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询所有下过订单的客户ID</span><br><span class="line">select distinct cust_id from orders;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="1-4-设定查询结果返回的行数limit"><a href="#1-4-设定查询结果返回的行数limit" class="headerlink" title="1.4 设定查询结果返回的行数limit"></a>1.4 设定查询结果返回的行数limit</h2><ul><li><p>语法：</p><ul><li><p>格式一：select * from 表名 limit n,m; </p><p>说明：当limit后面跟两个参数时，第一个参数为偏移量，第二个参数为返回的行数，意思是从行号为n的行开始的后面m行；MySQL中的行号是从0开始计算的，limit 2,3是第3行开始往后数3行，也就是第3，4，5行。</p></li><li><p>格式二：select * from 表名 limit m; </p><p>说明：当limit后面跟一个参数时，表示返回的行数，从第1行开始计算，可以理解成此时的偏移量是0，比如limit 3是指前三行</p></li></ul></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#例如查询第3行到第10行的商户</span><br><span class="line">select vend_id from vendors limit 2,8; </span><br><span class="line">#2代表行号，行号从0开始，所以第3行的行号为2</span><br><span class="line">#8代表展示多少行，从第3行到第10行一共有8行</span><br><span class="line"></span><br><span class="line">#查询订单中的前4行</span><br><span class="line">select * from orders limit 4;</span><br></pre></td></tr></tbody></table></figure></li></ul><span id="more"></span><h2 id="1-5-查询结果排序order-by"><a href="#1-5-查询结果排序order-by" class="headerlink" title="1.5 查询结果排序order by"></a>1.5 查询结果排序order by</h2><ul><li><p>语法：asc：ascending；desc：descending</p><ul><li>select <em>  from 表名 order by 字段 asc|desc;     注：asc表示升序，desc表示降序，如果不写关键字<em>*默认是升序</em></em></li><li>select *  from 表名 order by 字段1 asc|desc, 字段2 asc|desc;    表示先按字段1排序，在字段1相同的情况下再按字段2排序</li></ul></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询所有订单信息，按订单编号升序排列</span><br><span class="line">select * from orders order by order_num asc;</span><br><span class="line"></span><br><span class="line">#查询所有订单信息，按订单编号降序排列</span><br><span class="line">select * from orders order by order_num desc;</span><br><span class="line"></span><br><span class="line">#查询所有订单信息，按客户ID升序排列，客户ID相同的情况下按订单编号降序排列</span><br><span class="line">select * from orders order by cust_id asc, order_num desc;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="1-6-使用order-by和limit的组合，能够找出一个列中最高或者最低的值"><a href="#1-6-使用order-by和limit的组合，能够找出一个列中最高或者最低的值" class="headerlink" title="1.6 使用order by和limit的组合，能够找出一个列中最高或者最低的值"></a>1.6 使用order by和limit的组合，能够找出一个列中最高或者最低的值</h2><ul><li><p>语法：select 字段 from 表名 order by 字段 asc|desc limit 1;</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询价格最高的产品(降序排序列取第一行)</span><br><span class="line">select * from products order by prod_price desc limit 1;</span><br><span class="line"></span><br><span class="line">缺陷：当价格最高的产品有多个时，无法查询到所有最高价产品（需借助函数）</span><br></pre></td></tr></tbody></table></figure></li><li><p>注意：这种方式只能查出最高或最低的价格，不能查询最高或最低值的产品，因为可能有多个相同价格的产品。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  需借助函数和子查询</span><br><span class="line">  #查询产品中最低价的产品有哪些</span><br><span class="line">  select * from products </span><br><span class="line">where prod_price=(select min(prod_price) from products);</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="1-7-随机查询一条数据order-by-rand-limit-m"><a href="#1-7-随机查询一条数据order-by-rand-limit-m" class="headerlink" title="1.7 随机查询一条数据order by rand() limit m"></a>1.7 随机查询一条数据order by rand() limit m</h2><ul><li><p>语法：select *  from 表名 order by rand() limit 1;</p></li><li><p>举例</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#随机查询一个产品的信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="1-8-查询条件过滤"><a href="#1-8-查询条件过滤" class="headerlink" title="1.8 查询条件过滤"></a>1.8 查询条件过滤</h2><ul><li><p>语法：select *  from 表名 where 条件;</p></li><li><p>where子句中支持的操作符：</p><p>| 操作符             | 说明                                                         |<br>| ————————— | —————————————————————————————— |<br>| =                  | 等于                                                         |<br>| &lt;&gt;                 | 不等于                                                       |<br>| !=                 | 不等于                                                       |<br>| &lt;                  | 小于                                                         |<br>| &lt;=                 | 小于等于                                                     |<br>| &gt;                  | 大于                                                         |<br>| &gt;=                 | 大于等于                                                     |<br>| between…  and… | 在指定的两个值之间，包含边界                                 |<br>| and                | 表示两个条件同时满足                                         |<br>| or                 | 表示两个条件满足其中一个                                     |<br>| in                 | 指定条件范围，范围内的每个条件都可以进行匹配。in取值包含在圆括号中，以逗号分隔 |<br>| not                | 表示否定它之后所跟的任何条件，not一般跟in、is、between…and…组合起来用，not in, is not, not between…and… |<br>| is                 | 举例：is null表示为空，is not null表示不为空                 |<br>| like               | like后面跟通配符，表示查找模式利用通配符匹配而不是直接相等的匹配，MySQL中的通配符：%（任意多个任意字符）    _（一个任意字符） |</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#查询1001供应商供应的产品名称及价格?</span><br><span class="line">select prod_name,prod_price from products where vend_id=1001;</span><br><span class="line"></span><br><span class="line">#查询1001供应商之外的其它供应商供应的产品名称及价格?</span><br><span class="line">select prod_name,prod_price,vend_id from products where vend_id!=1001;</span><br><span class="line"></span><br><span class="line">#查询产品价格高于5的产品ID和价格</span><br><span class="line">select prod_id,prod_price from products where prod_price&gt;5;</span><br><span class="line"></span><br><span class="line">#查询产品价格介于5到10之间的产品ID和价格</span><br><span class="line">select prod_id,prod_price from products where prod_price between 5 and 10;</span><br><span class="line"></span><br><span class="line">#查询产品价格不在5到10之间的产品ID和价格</span><br><span class="line">select prod_id,prod_price from products where prod_price not between 5 and 10;</span><br><span class="line"></span><br><span class="line">#查询1003供应商供应的价格不在5到10之间的产品ID和价格</span><br><span class="line">select prod_id,prod_price,vend_id from products where vend_id=1003 and prod_price not between 5 and 10;</span><br><span class="line"></span><br><span class="line">#查询1001供应商的产品，以及价格介于10到20之间的产品（不分供应商）的名称及价格？</span><br><span class="line">select prod_name,prod_price,vend_id from products p where p.vend_id=1001 or p.prod_price between 10 and 20;</span><br><span class="line"></span><br><span class="line">#查询1001，1002,1003供应商的产品的名称及价格？</span><br><span class="line">select prod_name,prod_price,vend_id from products p where p.vend_id=1001 or p.vend_id=1002 or p.vend_id=1003;</span><br><span class="line"></span><br><span class="line">#也可以使用IN来表示多个OR并列</span><br><span class="line">select prod_name,prod_price,vend_id from products p where p.vend_id in (1001,1002,1003);</span><br><span class="line"></span><br><span class="line">#查询1001,1002,1003供应商之外的其它供应商的产品的名称及价格？</span><br><span class="line">select prod_name,prod_price,vend_id from products p where p.vend_id!=1001 and p.vend_id!=1002 and p.vend_id!=1003;</span><br><span class="line"></span><br><span class="line">#也可以使用not in来实现</span><br><span class="line">select prod_name,prod_price,vend_id from products p where p.vend_id not in (1001,1002,1003);</span><br><span class="line"></span><br><span class="line">#查询邮箱地址为空的客户信息</span><br><span class="line">select * from customers c where c.cust_email is null;</span><br><span class="line"></span><br><span class="line">#查询邮箱地址不为空的客户信息</span><br><span class="line">select * from customers c where c.cust_email is not null;</span><br></pre></td></tr></tbody></table></figure></li><li><p>通配符举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#查询产品名称以JetPack开头的产品信息</span><br><span class="line">SELECT * FROM PRODUCTS WHERE PROD_NAME LIKE "JetPack%";</span><br><span class="line"></span><br><span class="line">#查询客户联系人是以Y开头的客户的信息</span><br><span class="line">select * from customers c where c.cust_contact like "Y%";</span><br><span class="line"></span><br><span class="line">#查询客户联系人是以e结尾的客户的信息</span><br><span class="line">select * from customers c where c.cust_contact like "%e";</span><br><span class="line"></span><br><span class="line">#查询客户联系人包含e的客户的信息</span><br><span class="line">select * from customers c where c.cust_contact like "%e%";</span><br><span class="line"></span><br><span class="line">#查询产品id以ANV开头，后面还有2个字符的产品信息</span><br><span class="line">select * from products where prod_id like "ANV__";</span><br><span class="line"></span><br><span class="line">#查询名称以anvil结尾,前面还有6个字符的产品信息</span><br><span class="line">select * from products where prod_name like "______anvil";</span><br></pre></td></tr></tbody></table></figure></li><li><p>通配符使用注意事项：</p><ul><li>%与_的区别：%表示任意多个任意字符，_表示匹配一个字符，不能多也不能少；</li><li>使用通配符会比没有通配符更消耗数据库执行查询的时间，应该在需要使用通配符的地方才使用。</li></ul></li></ul><h1 id="2-MySQL的函数"><a href="#2-MySQL的函数" class="headerlink" title="2. MySQL的函数"></a>2. MySQL的函数</h1><h2 id="2-1-聚集函数（avg，count，max，min，sum）"><a href="#2-1-聚集函数（avg，count，max，min，sum）" class="headerlink" title="2.1 聚集函数（avg，count，max，min，sum）"></a>2.1 聚集函数（avg，count，max，min，sum）</h2><p>聚集函数：聚集函数是在列上的运算，比如找这一列的最大、最小、平均、求和、统计行数等。</p><h3 id="avg"><a href="#avg" class="headerlink" title="avg()"></a>avg()</h3><ul><li><p>作用：返回某列的平均值 </p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#计算产品的平均价格</span><br><span class="line">select avg(prod_price) from products;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h3><ul><li><p>作用：返回某列的行数，注意：<strong>count统计的是某个列上非空的行的数量，如果某一行是null，就不会被统计在内</strong>，在实际使用中如果要统计表的行数，直接用count(*)，只要行上有一个字段非null，就会被统计在内。</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#统计产品的数量</span><br><span class="line">select count(*) from products;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="max"><a href="#max" class="headerlink" title="max()"></a>max()</h3><ul><li><p>作用：返回某列的最大值</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#统计产品的最高价</span><br><span class="line">select max(prod_price) from products;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="min"><a href="#min" class="headerlink" title="min()"></a>min()</h3><ul><li><p>作用：返回某列的最小值</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#统计产品的最低价</span><br><span class="line">select min(prod_price) from products;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h3><ul><li><p>作用：返回某列值之和</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#统计产品单价的总和</span><br><span class="line">select sum(prod_price) from products;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="2-2-日期与时间函数（curdate，curtime，now，adddate，date-del，addtime，date，year，month，day）"><a href="#2-2-日期与时间函数（curdate，curtime，now，adddate，date-del，addtime，date，year，month，day）" class="headerlink" title="2.2 日期与时间函数（curdate，curtime，now，adddate，date_del，addtime，date，year，month，day）"></a>2.2 日期与时间函数（curdate，curtime，now，adddate，date_del，addtime，date，year，month，day）</h2><h3 id="（1）返回当前时间curdate，curtime，now"><a href="#（1）返回当前时间curdate，curtime，now" class="headerlink" title="（1）返回当前时间curdate，curtime，now"></a>（1）返回当前时间curdate，curtime，now</h3><h4 id="curdate"><a href="#curdate" class="headerlink" title="curdate()"></a>curdate()</h4><ul><li><p>作用：返回系统当前日期</p></li><li><p>举例：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> curdate();</span><br><span class="line"><span class="number">2024</span><span class="number">-05</span><span class="number">-09</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="curtime"><a href="#curtime" class="headerlink" title="curtime()"></a>curtime()</h4><ul><li><p>作用：返回当前时间</p></li><li><p>举例：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> curtime();</span><br><span class="line"><span class="number">03</span>:<span class="number">27</span>:<span class="number">39</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="now"><a href="#now" class="headerlink" title="now()"></a>now()</h4><ul><li><p>作用：返回当前日期和时间</p></li><li><p>举例：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> now();</span><br><span class="line"><span class="number">2024</span><span class="number">-05</span><span class="number">-09</span> <span class="number">03</span>:<span class="number">28</span>:<span class="number">30</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="（2）增加或减少时间adddate，date-del，addtime"><a href="#（2）增加或减少时间adddate，date-del，addtime" class="headerlink" title="（2）增加或减少时间adddate，date_del，addtime"></a>（2）增加或减少时间adddate，date_del，addtime</h3><h4 id="adddate"><a href="#adddate" class="headerlink" title="==adddate()=="></a>==adddate()==</h4><ul><li><p>作用：增加一个日期（天、周、月、年等）</p></li><li><p>语法：ADDDATE(date, INTERVAL expr unit)</p><ul><li>date:可以手动设置具体时间，也可以使用now(),date()等函数表达</li><li>INTERVAL：固定写法，表示间隔;</li><li>expr:表达式，一般用数字来表示,例如3表示三天后，-3表示三天前;</li><li>unit:表示时间的单位，例如: year、month、day、week、hour、minute、second等</li></ul></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#查询当前时间三天后的时间</span><br><span class="line">select adddate(curdate(),INTERVAL 3 day);</span><br><span class="line">2024-05-12</span><br><span class="line"></span><br><span class="line">#查询一周前的时间</span><br><span class="line">select adddate(curdate(),INTERVAL -1 week);</span><br><span class="line">2024-05-02</span><br><span class="line"></span><br><span class="line">#查询20005订单下单前2周的时间</span><br><span class="line">select adddate(order_date,INTERVAL -2 WEEK) from orders where order_num=20005;</span><br><span class="line">2005-08-18 00:00:00</span><br><span class="line"></span><br><span class="line">#面试题:(当前5月9日)</span><br><span class="line">#查询最近1小时的订单</span><br><span class="line">select * from orders where order_date &gt;= adddate(curdate(),interval 30 minute);</span><br><span class="line">#查询最近2周的订单</span><br><span class="line">select * from orders where order_date &gt;= adddate(curdate(),interval -2 week);</span><br><span class="line">#查询最近19年的订单</span><br><span class="line">select * from orders where order_date &gt;= adddate(curdate(),interval -19 year);</span><br><span class="line"></span><br><span class="line">#难点：</span><br><span class="line">#统计20005和20006订单间隔多少天?</span><br><span class="line">#先查出来20005和20006两个订单的日期</span><br><span class="line">select date(order_date) as date1 from orders where order_num=20005;</span><br><span class="line">select date(order_date) as date2 from orders where order_num=20006;</span><br><span class="line">#再把查出来的结果放在a，b两张临时表里，计算日期差</span><br><span class="line">#框架</span><br><span class="line">select b.date2-a.date1 from () as a, () as b;</span><br><span class="line">#指令</span><br><span class="line">select b.date2-a.date1 from </span><br><span class="line">(select date(order_date) as date1 from orders where order_num=20005) as a, </span><br><span class="line">(select date(order_date) as date2 from orders where order_num=20006) as b;</span><br></pre></td></tr></tbody></table></figure></li></ul>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#原笔记例子：</span><br><span class="line">#计算订单下单日期之后30天的日期</span><br><span class="line">select cust_id,order_num,order_date,adddate(order_date, interval 30 day) from orders;</span><br><span class="line"></span><br><span class="line">#计算订单下单日期之后1周的日期</span><br><span class="line">select cust_id,order_num,order_date,adddate(order_date, interval 1 week) from orders;</span><br><span class="line"></span><br><span class="line">#计算订单下单日期之后1个月的日期</span><br><span class="line">select cust_id,order_num,order_date,adddate(order_date, interval 1 month) from orders;</span><br><span class="line"></span><br><span class="line">#计算订单下单日期之后1年的日期</span><br><span class="line">select cust_id,order_num,order_date,adddate(order_date, interval 1 year) from orders;</span><br></pre></td></tr></tbody></table></figure><h4 id="date-sub"><a href="#date-sub" class="headerlink" title="==date_sub()=="></a>==date_sub()==</h4><ul><li><p>作用：减少一个日期（天、周、月、年等）</p></li><li><p>语法：<strong>和adddate一致</strong></p><p>date_sub(date, INTERVAL expr unit)</p><ul><li>date:可以手动设置具体时间，也可以使用now(),date()等函数表达</li><li>INTERVAL：固定写法，表示间隔;</li><li>expr:表达式，一般用数字来表示,例如3表示三天后，-3表示三天前;</li><li>unit:表示时间的单位，例如: year、month、day、week、hour、minute、second等</li></ul></li><li><p>举例：</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#DATE_SUB(date,INTERVAL expr unit)</span><br><span class="line">#和dateadd语法一致,唯一区别是date_sub是减日期，dateadd是加日期</span><br><span class="line">#查询当前时间三天后的时间</span><br><span class="line">select date_sub(curdate(),INTERVAL -3 day);</span><br><span class="line">2024-05-12</span><br><span class="line"></span><br><span class="line">#查询一周前的时间</span><br><span class="line">select date_sub(curdate(),INTERVAL 1 week);</span><br><span class="line">2024-05-02</span><br><span class="line"></span><br><span class="line">#用date sub函数，统计最近10天的订单(两条语句都可以)</span><br><span class="line">select * from orders where order_date &gt;= date_sub(curdate(),interval 10 day);</span><br><span class="line">select * from orders where date(order_date) &gt;= date_sub(curdate(),interval 10 day);</span><br></pre></td></tr></tbody></table></figure><h4 id="addtime"><a href="#addtime" class="headerlink" title="==addtime()=="></a>==addtime()==</h4><ul><li><p>作用：增加一个时间（时、分、秒等）</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#计算订单时间之后的30分钟的时间</span><br><span class="line">select *,addtime(order_date,"00:30:00") from orders;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="（3）取日期某个部分date，year，month，day"><a href="#（3）取日期某个部分date，year，month，day" class="headerlink" title="（3）取日期某个部分date，year，month，day"></a>（3）取日期某个部分date，year，month，day</h3><h4 id="date"><a href="#date" class="headerlink" title="date()"></a>date()</h4><ul><li><p>作用：返回日期时间的日期部分</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询2005-11-08号的订单信息</span><br><span class="line">select * from orders where date(order_date)="2005-11-08";</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="year"><a href="#year" class="headerlink" title="year()"></a>year()</h4><ul><li><p>作用：返回日期时间的年的部分</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#例1：查询所有订单的下单年份</span><br><span class="line">select distinct year(order_date) from orders;</span><br><span class="line">#例2:查询2005年的订单</span><br><span class="line">select * from orders where year(order_date)=2005;</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="month"><a href="#month" class="headerlink" title="month()"></a>month()</h4><ul><li><p>作用：返回日期时间的月的部分</p></li><li><p>举例：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#例<span class="number">1</span>：显示所有<span class="number">2009</span>年<span class="number">9</span>月的订单信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> orders <span class="keyword">where</span> <span class="keyword">year</span>(order_date)<span class="operator">=</span><span class="number">2005</span> <span class="keyword">and</span> <span class="keyword">month</span>(order_date)<span class="operator">=</span><span class="number">9</span>;</span><br><span class="line">#例<span class="number">2</span>：查询<span class="number">2005</span>年<span class="number">9</span>月的订单数目</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> orders <span class="keyword">where</span> <span class="keyword">year</span>(order_date)<span class="operator">=</span><span class="number">2005</span> <span class="keyword">and</span> <span class="keyword">month</span>(order_date)<span class="operator">=</span><span class="number">9</span>;</span><br><span class="line">#用<span class="keyword">like</span>模糊查询（查询效率低）</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> orders <span class="keyword">where</span> order_date <span class="keyword">like</span> "2005_09%";</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="day"><a href="#day" class="headerlink" title="day()"></a>day()</h4><ul><li><p>作用：返回日期时间的天的部分</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#例1:查询2005年9月哪几天有订单</span><br><span class="line">select day(order_date) from orders where year(order_date)=2005 and month(order_date)=9;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="2-3-数值处理函数（round，truncate，abs，rand）"><a href="#2-3-数值处理函数（round，truncate，abs，rand）" class="headerlink" title="2.3 数值处理函数（round，truncate，abs，rand）"></a>2.3 数值处理函数（round，truncate，abs，rand）</h2><h3 id="round-x-y"><a href="#round-x-y" class="headerlink" title="round(x,y)"></a>round(x,y)</h3><ul><li><p>作用：对x四舍五入保留y位小数</p></li><li><p>举例：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#例<span class="number">1</span>：统计供应商<span class="number">1003</span>产品的均价，四舍五入保留<span class="number">2</span>位小数</span><br><span class="line"><span class="keyword">select</span> round(<span class="built_in">avg</span>(prod_price),<span class="number">2</span>) <span class="keyword">from</span> products <span class="keyword">where</span> vend_id<span class="operator">=</span><span class="number">1003</span>;</span><br><span class="line">#例<span class="number">2</span>：统计订单<span class="number">20009</span>年总价，保留<span class="number">1</span>位小数:</span><br><span class="line"><span class="keyword">select</span> round(<span class="built_in">sum</span>(item_price<span class="operator">*</span>quantity),<span class="number">1</span>) <span class="keyword">from</span> orderitems <span class="keyword">where</span> order_num<span class="operator">=</span><span class="number">20009</span>; </span><br><span class="line">#例<span class="number">3</span>：统计订单<span class="number">20005</span>购买的产品均价，不保留小数</span><br><span class="line"><span class="keyword">select</span> round(<span class="built_in">avg</span>(item_price),<span class="number">0</span>) <span class="keyword">from</span> orderitems <span class="keyword">where</span> order_num<span class="operator">=</span><span class="number">20005</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="truncate-x-y"><a href="#truncate-x-y" class="headerlink" title="truncate(x,y)"></a>truncate(x,y)</h3><ul><li><p>作用：对x截断保留y位小数（与round的唯一区别就是不会四舍五入）</p></li><li><p>举例：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#例<span class="number">1</span>：统计订单<span class="number">20005</span>购买的产品单价均价，不保留小数</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">truncate</span>(<span class="built_in">sum</span>(quantity<span class="operator">*</span>item_price)<span class="operator">/</span><span class="built_in">sum</span>(quantity),<span class="number">2</span>) <span class="keyword">from</span> orderitems <span class="keyword">where</span> order_num<span class="operator">=</span><span class="number">20005</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="abs-x"><a href="#abs-x" class="headerlink" title="abs(x)"></a>abs(x)</h3><ul><li><p>作用：返回x的绝对值，比如算差值时，只需要间隔，不需要正负</p></li><li><p>举例：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">abs</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">#统计<span class="number">20005</span>和<span class="number">20006</span>订单间隔多少天?#临时表</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">abs</span>(a.date1<span class="operator">-</span>b.date2) <span class="keyword">from</span></span><br><span class="line">( <span class="keyword">select</span> <span class="type">date</span>(order_date) date1 <span class="keyword">from</span> orderswhere order_num<span class="operator">=</span><span class="number">20005</span>) <span class="keyword">as</span> a,</span><br><span class="line"> ( <span class="keyword">select</span> <span class="type">date</span>(order_date) date2 <span class="keyword">from</span> orderswhere order_num<span class="operator">=</span><span class="number">20006</span>) <span class="keyword">as</span> b;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h3><ul><li><p>作用：返回0~1内的随机值</p></li><li><p>举例：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> rand();</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="2-4-系统函数（version，database，user）"><a href="#2-4-系统函数（version，database，user）" class="headerlink" title="2.4 系统函数（version，database，user）"></a>2.4 系统函数（version，database，user）</h2><h3 id="version"><a href="#version" class="headerlink" title="version()"></a>version()</h3><ul><li><p>作用：返回数据库版本号</p></li><li><p>举例：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> version();</span><br><span class="line"><span class="number">5.7</span><span class="number">.32</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="database"><a href="#database" class="headerlink" title="database()"></a>database()</h3><ul><li><p>作用：返回当前连接的数据库</p></li><li><p>举例：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> database();</span><br><span class="line">crashcourse</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="user"><a href="#user" class="headerlink" title="user()"></a>user()</h3><ul><li><p>作用：返回当前登录的用户</p></li><li><p>举例：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select user();</span><br><span class="line">root@<span class="number">192.168</span><span class="number">.118</span><span class="number">.1</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="3-分组查询"><a href="#3-分组查询" class="headerlink" title="3. 分组查询"></a>3. 分组查询</h1><h2 id="3-1-分组查询group-by"><a href="#3-1-分组查询group-by" class="headerlink" title="3.1 分组查询group by"></a>3.1 分组查询group by</h2><p><strong>什么时候使用group by</strong></p><p>==当需要根据某个维度来对数据进行统计或聚集运算时，使用group by==</p><ul><li><p>语法：在select语句中通过group by子句实现分组，通常在group by后面跟一个字段，字段值相同的行作为一组，通常分组的目的是为了对每个分组做聚集运算，在分组查询中，select后面只能跟group by后面的字段和聚集运算的结果。</p></li><li><p>select 字段, 聚集函数 from 表 group by 字段;</p></li><li><p>select 字段1, 字段2,聚集函数 from 表 group by 字段1, 字段2;</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#统计每个供应商供应的产品数量</span><br><span class="line">select vend_id,count(*) as 产品数量 from products group by vend_id;</span><br><span class="line">#统计每个学生的总分、最高分、最低分、参考科目?</span><br><span class="line">select sid,sum(score),max( score),min(score) ,count(*) from scoregroup by sid;</span><br></pre></td></tr></tbody></table></figure></li><li><p>注意：</p><p>1）分组查询select只能查看<strong>group by分组依据字段</strong>以及<strong>根据该字段聚集运算的结果</strong>；</p><p>2）group by可以根据多个列进行分组，多个列分组即对多个列的组合值相同的进行分组；</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#语法: select字段1，字段2,聚集函数from 表 group by字段1，字段2;</span><br><span class="line">#例1:统计来自不同国家、不同州的供应商有多少个，返回国家、州、供应商数量</span><br><span class="line">select vend_country , vend_state,count(*) from vendors group by vend_country , vend_state;</span><br><span class="line">#例3:查询2005年每个月每天的订单数量，返回月份、天、订单数量(可用于分析顾客一个月何时下单最多)</span><br><span class="line">select month(order_date),day(order_date),count(*) from orders where year(order_date)=2005 group by month(order_date),day(order_date);</span><br></pre></td></tr></tbody></table></figure></li><li><p>课堂练习：</p><ul><li><p>1、统计2005年每月的订单数量？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select month(order_date),count(*) from orders where year(order_date)=2005 group by month(order_date); </span><br></pre></td></tr></tbody></table></figure></li><li><p>2、统计2005年每个客户的订单数量？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select day(order_date),count(*) from orders where year(order_date)=2005 and month(order_date)=10 group by day(order_date);</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="3-2-过滤分组having"><a href="#3-2-过滤分组having" class="headerlink" title="3.2 过滤分组having"></a>3.2 过滤分组having</h2><p><strong>什么情况用where过滤，什么情况用having过滤</strong></p><p>==having一般和group by组合使用，只有在需要对聚合数据进行筛选时，才需要用到having==</p><ul><li><p>语法：通过having子句实现分组的过滤</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#统计供应了2种以上产品的供应商id及产品数量</span><br><span class="line">select vend_id,count(*) as 产品数量 from products group by vend_id having count(*)&gt;2;</span><br><span class="line">#列出供应商的平均价格大于20的供应商编号(不使用having分组过滤)</span><br><span class="line">select vend_id,avg(prod_price) from products group by vend_id;</span><br><span class="line">select a.vend_id from (select vend_id,avg(prod_price) as average from products group by vend_id) as a where a.average&gt;20;</span><br><span class="line">#使用分组过滤</span><br><span class="line">select vend_id,avg(prod_price) as average from products group by vend_id having average&gt;20;</span><br><span class="line"></span><br><span class="line">#统计2005年下单数量超过3个的客户id、订单数量</span><br><span class="line">select cust_id,count(*) from orders where year(order_date)=2005 group by cust_id having count(*)&gt;3;</span><br><span class="line">#查询供应了2种以上产品的供应商，返回供应商id、产品数量?</span><br><span class="line">select vend_id,count(*) from products group by vend_id having count(*)&gt;2;</span><br><span class="line">#查询订单价格大于100元的订单有哪些，返回订单id和价格</span><br><span class="line">select order_num,sum(item_price*quantity) from orderitems group by order_num having sum(item_price*quantity)&gt;100;</span><br><span class="line"></span><br><span class="line">#查询各科成绩都大于80分的学生学号?（难想）</span><br><span class="line">select stu_id min(score) from score group by stu_id having min(score)&gt;80</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="3-3-过滤行与过滤分组的区别"><a href="#3-3-过滤行与过滤分组的区别" class="headerlink" title="3.3 过滤行与过滤分组的区别"></a>3.3 过滤行与过滤分组的区别</h2><ul><li><p>语法：过滤行是在分组前用where来实现，得到的是满足条件的所有行；过滤分组是在分组后通过having来实现，得到的是满足条件的所有分组。</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#统计供应了2种以上价格大于5的产品的供应商id及产品数量（价格大于5通过WHERE过滤，数量大于2通过HAVING过滤）</span><br><span class="line">select vend_id,count(*) as 产品数量 from products where prod_price&gt;5 group by vend_id having count(*)&gt;2;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="3-4-分组查询的使用场景"><a href="#3-4-分组查询的使用场景" class="headerlink" title="3.4 分组查询的使用场景"></a>3.4 分组查询的使用场景</h2><p>当需要按某个维度去做聚集运算时，通常会用到分组查询。比如统计每个客户的订单数量，每个供应商的产品数量，每个供应商产品的最高、最低、平均价，每个学生的总分，每门课程的平均分等，都需要用到分组查询。</p><p>分组查询通常和聚集运算结合在一起使用。</p><h1 id="4-select查询中子句的出现顺序"><a href="#4-select查询中子句的出现顺序" class="headerlink" title="4. select查询中子句的出现顺序"></a>4. select查询中子句的出现顺序</h1><p>select语句中使用的子句必须按照一定的次序，下图列出来各个子句在select语句中出现的次序</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select distinct 字段1,字段2,...</span><br><span class="line"> from 表 </span><br><span class="line"> join 表 </span><br><span class="line"> on join的条件 </span><br><span class="line"> where 筛选行的条件</span><br><span class="line"> group by 分组条件</span><br><span class="line"> having 筛选列的条件</span><br><span class="line"> order by 排序方式</span><br><span class="line"> limit 限制输出</span><br></pre></td></tr></tbody></table></figure><div class="table-container"><table><thead><tr><th><strong>子句</strong></th><th><strong>说明</strong></th><th><strong>是否必须使用</strong></th></tr></thead><tbody><tr><td>select</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>from</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td><strong>join</strong></td><td><strong>连表查询关键字</strong></td><td><strong>否，仅在连表查询时用</strong></td></tr><tr><td><strong>on</strong></td><td><strong>连表查询关键字</strong></td><td><strong>否，仅在连表查询时用</strong></td></tr><tr><td>where</td><td>行级过滤</td><td>否</td></tr><tr><td>group by</td><td>分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>having</td><td>组级过滤</td><td>否</td></tr><tr><td>order by</td><td>输出排序顺序</td><td>否</td></tr><tr><td>limit</td><td>要检索的行数</td><td>否</td></tr></tbody></table></div><p>出现和执行顺序：</p><p><img src="/2024/05/09/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/image-20240510110245451.png" alt="image-20240510110245451" style="zoom:80%;"></p><h1 id="5-子查询"><a href="#5-子查询" class="headerlink" title="5. 子查询"></a>5. 子查询</h1><ul><li><p>在查询中嵌套查询，用IN实现嵌套，里面的查询的返回值作为外面查询的条件。</p></li><li><p>语法：select * from 表 where 字段 ==in== (select 字段 from 表);</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#查询产品中最低价的产品有哪些</span><br><span class="line">select * from products </span><br><span class="line">where prod_price=(select min(prod_price) from products);</span><br><span class="line">#例1，查询Coyote Inc.顾客的所有订单编号</span><br><span class="line">select order_num from orders </span><br><span class="line">where cust_id=(select cust_id from customers where cust_name='Coyote Inc.'); </span><br><span class="line">#例2，查询Coyote Inc.顾客购买了哪些产品，返回产品名称</span><br><span class="line">#思路：</span><br><span class="line">#1、根据Coyote Inc.这个顾客姓名，可在顾客表中查出顾客cust_id</span><br><span class="line">#2、根据顾客cust_id，可在订单表中查出该顾客的订单编号order_num,</span><br><span class="line">#3、根据订单编号order_num，可在订单详情表中查出该顾客所购买的产品编号prod_num，</span><br><span class="line">#4、根据产品编号prod_num，可在产品表中查出该顾客所购买的产品名称prod_name，</span><br><span class="line">#5、最后结果有重复，加distinct去重</span><br><span class="line">select distinct prod_name from products </span><br><span class="line">where prod_id in(</span><br><span class="line">select prod_id from orderitems</span><br><span class="line">where order_num in (</span><br><span class="line">select order_num from orders </span><br><span class="line">where cust_id = (</span><br><span class="line">select cust_id from customers </span><br><span class="line">where cust_name='Coyote Inc.'</span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">##例2，查询Coyote Inc.顾客购买了哪些供应商的产品，返回供应商vend_id</span><br><span class="line">select distinct vend_id from products </span><br><span class="line">where prod_id in(</span><br><span class="line">select prod_id from orderitems</span><br><span class="line">where order_num in (</span><br><span class="line">select order_num from orders </span><br><span class="line">where cust_id = (</span><br><span class="line">select cust_id from customers </span><br><span class="line">where cust_name='Coyote Inc.'</span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#例1：查询名称为ACME供应商供应的产品名称？</span><br><span class="line">#方法1：</span><br><span class="line">#先在供应商表中查出ACME供应商的编号</span><br><span class="line">select v.vend_id from vendors v where v.vend_name="ACME";</span><br><span class="line"></span><br><span class="line">#再根据供应商编号在产品表中查出产品名称</span><br><span class="line">select p.prod_name from products p where p.vend_id in (1003);</span><br><span class="line"></span><br><span class="line">#方法2：用子查询实现，把第一个查询嵌套到第二个查询语句中，第一个查询的返回作为第二个查询的条件</span><br><span class="line">select p.prod_name from products p where p.vend_id in (select v.vend_id from vendors v where v.vend_name="ACME");</span><br><span class="line"></span><br><span class="line">#例2：查询购买了编号为TNT2的产品的所有客户姓名</span><br><span class="line">#方法1：</span><br><span class="line">#先查找包含物品TNT2的所有订单的编号</span><br><span class="line">select order_num from orderitems where prod_id='TNT2';</span><br><span class="line"></span><br><span class="line">#再查找前一步骤列出的订单编号的所有客户的ID</span><br><span class="line">select cust_id from orders where order_num in (20005,20007);</span><br><span class="line"></span><br><span class="line">#最后再查找前一步列出的客户ID的客户姓名及其他信息</span><br><span class="line">select cust_id,cust_name from customers where cust_id in (10001,10004);</span><br><span class="line"></span><br><span class="line">#方法2：用子查询实现</span><br><span class="line">select cust_id,cust_name from customers where cust_id in (select cust_id from orders where order_num in (select order_num from orderitems where prod_id = 'TNT2'));</span><br></pre></td></tr></tbody></table></figure><h1 id="6-连表查询join、left-join"><a href="#6-连表查询join、left-join" class="headerlink" title="6. 连表查询join、left join"></a>6. 连表查询join、left join</h1><p><strong>思路：讲清楚三种连表的计算规则、区别，怎么指定正确的连表条件。</strong></p><h2 id="6-1-内连接inner-join"><a href="#6-1-内连接inner-join" class="headerlink" title="6.1 内连接inner join"></a>6.1 内连接inner join</h2><ul><li><p>为什么要连表？</p><ul><li>关系型数据库的特点就是分表存放数据，把一类的数据放在一张表中，但实际使用时，很多时候需要把不同表中的数据查到一个结果中，这就需要用到连表查询，这也是SQL最强大的功能之一。</li></ul></li><li><p>语法：</p><ul><li><p>select * from 表1 inner join 表2 on 条件;</p></li><li><p>select * from 表1, 表2 where 条件；</p></li><li><p>说明：</p><ul><li><p>内连接时，表的位置可以互换，且不影响查询结果</p></li><li><p>如果在内连接（Inner Join）中不加入连接条件（Join Condition），将会发生以下情况：</p><ol><li><p>返回的结果将是两个表的笛卡尔积，导致结果集非常大，并且可能会消耗大量的计算资源和时间</p></li><li><p>结果可能会失去意义</p></li><li><p>有关ambiguous错误</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#为什么返回vend_id时,会报ambiguous错误:</span><br><span class="line">select vend_id,prod_id,prod_name from vendors </span><br><span class="line">inner join products on vendors.vend_id = products.vend_id;</span><br><span class="line">-- 1052 - Column 'vend_id' in field list is ambiguous</span><br><span class="line">-- 这个错误是因为在你的查询中，vend_id 列在两个表中都存在，MySQL 不知道应该使用哪个表的 vend_id 列。为了解决这个问题，你需要明确指定使用哪个表的列。</span><br><span class="line">-- 下面是修改后的查询语句：</span><br><span class="line">SELECT vendors.vend_id, products.prod_id, products.prod_name FROM vendors</span><br><span class="line">INNER JOIN products ON vendors.vend_id = products.vend_id</span><br></pre></td></tr></tbody></table></figure></li></ol></li></ul></li></ul></li><li><p>计算规则：==两张表连连接，用左边表的每一行去匹配右边表的每一行，如果满足连接的条件，就组成一行返回，返回的行里面包括两张表的所有字段，如果不满足连接的条件，就不返回==</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#例1，查询每个客户的所有订单，返回客户姓名、订单编号?</span><br><span class="line">select * from customers </span><br><span class="line">inner join orders on customers.cust_id = orders.cust_id;</span><br><span class="line"></span><br><span class="line">select cust_name,order_num from customers </span><br><span class="line">inner join orders on customers.cust_id = orders.cust_id;</span><br><span class="line"></span><br><span class="line">#例2，查询每个供应商供应的所有产品,返回供应商名称、产品id和产品名称?</span><br><span class="line"></span><br><span class="line">select vend_name,prod_id,prod_name from vendors </span><br><span class="line">inner join products on vendors.vend_id = products.vend_id;</span><br><span class="line"></span><br><span class="line">##例3:查询每个订单购买了的产品，返回订单编号、产品名称</span><br><span class="line">select order_num,prod_name from orderitems </span><br><span class="line">inner join products on orderitems.prod_id=products.prod_id;</span><br><span class="line"></span><br><span class="line">#例4:查询每个客户购买了哪些产品，返回客户姓名、购买的产品id?</span><br><span class="line">select cust_name,prod_id from customers</span><br><span class="line">inner join orders on customers.cust_id = orders.cust_id</span><br><span class="line">inner join orderitems on orderitems.order_num = orders.order_num; </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>多表连接的数量：SQL中对一条select语句中可以连接的表的数目没有限制，如果有3张表连接，只需要A和B连接，再和C连接就可以了，依次类推……</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 3张表连接举例：</span><br><span class="line">#查询订单编号为20005的订单中的物品信息（产品名称、供应商名称、产品价格、数量）</span><br><span class="line">select prod_name,vend_name,prod_price,quantity from orderitems,products,vendors where products.vend_id=vendors.vend_id and orderitems.prod_id=products.prod_id and orderitems.order_num=20005;</span><br><span class="line"></span><br><span class="line"># 4张表连接举例：</span><br><span class="line">#查询每个客户的姓名及购买的产品名称？</span><br><span class="line">select c.cust_name,p.prod_name from customers c inner join orders o on c.cust_id=o.cust_id inner join orderitems oi on o.order_num=oi.order_num inner join products p on oi.prod_id=p.prod_id;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="6-2-外连接left-join、right-join"><a href="#6-2-外连接left-join、right-join" class="headerlink" title="6.2 外连接left join、right join"></a>6.2 外连接left join、right join</h2><ul><li><p>外连接又分为左外连接和右外连接两种。</p></li><li><p>左外连接</p><ul><li><p>语法：select * from 表1 left join 表2 on 条件；</p></li><li><p>计算规则：==以左边表为基准，用左边表的每一行去匹配右边表的每一行，如果满足连接的条件，就组成一行返回，如果连接的字段只在左边表存在，在右边表不存在，那么在结果中就只显示左边表的字段，右边表中不存在的字段用空值NULL来表示==</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#1）统计每个客户下了哪些订单，包括那些至今尚未下订单的客户</span><br><span class="line">select customers.cust_id,cust_name,order_num from customers left join orders on customers.cust_id=orders.cust_id;</span><br><span class="line"></span><br><span class="line">#2）查询没有被购买过的产品名称</span><br><span class="line">select p.prod_name from products p left join orderitems o on p.prod_id=o.prod_id where o.order_num is null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3）查询在2005年9月份没有被购买过的产品信息</span><br><span class="line">#1、子查询方式</span><br><span class="line">select p.prod_name</span><br><span class="line">from products p</span><br><span class="line">where p.prod_id not in (</span><br><span class="line">select distinct oi.prod_id</span><br><span class="line">from orders o</span><br><span class="line">inner join orderitems oi</span><br><span class="line">on o.order_num = oi.order_num</span><br><span class="line">where (year(o.order_date) = '2005' and month(o.order_date) = '09'));</span><br><span class="line"></span><br><span class="line">#2、左连接方式</span><br><span class="line">select p.prod_name</span><br><span class="line">from products p</span><br><span class="line">left outer join</span><br><span class="line">(select distinct oi.prod_id</span><br><span class="line">from orders o</span><br><span class="line">inner join orderitems oi</span><br><span class="line">on o.order_num = oi.order_num</span><br><span class="line">where (year(o.order_date) = '2005' and month(o.order_date) = '09')) as a</span><br><span class="line">on p.prod_id = a.prod_id</span><br><span class="line">where a.prod_id is null;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><ul><li><p>右外连接</p><ul><li>语法：select * from 表1 right join 表2 on 条件；</li><li>计算规则：与左连接相反，以右边表为基准，用右边表的每一行去匹配左边表的每一行，如果满足连接的条件，就组成一行返回，如果连接的字段只在右边表存在，在左边表不存在，那么在结果中就只显示右边表的字段，左边表中不存在的字段用空值NULL来表示。</li><li>举例：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#统计每个客户下了哪些订单，包括那些至今尚未下订单的客户。（用右连接实现）</span><br><span class="line">select customers.cust_id,cust_name,order_num from orders right join customers on customers.cust_id=orders.cust_id;</span><br></pre></td></tr></tbody></table></figure></li><li><p>课堂练习：</p><ul><li>1、查询老师的姓名及教授的课程名称，包括没有上课的老师？</li><li>2、查询没有上课的老师姓名？</li><li>3、查询没有被购买过的产品名称？</li><li>4、查询每个学生的姓名、学习的课程名称、分数？</li></ul></li></ul><h2 id="6-3-inner-join、left-join、right-join三者的区别"><a href="#6-3-inner-join、left-join、right-join三者的区别" class="headerlink" title="6.3 inner join、left join、right join三者的区别"></a>6.3 inner join、left join、right join三者的区别</h2><p>借助集合的概念来理解三种连接的区别：</p><p><img src="/2024/05/09/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/image-20240509200717064.png" alt="image-20240509200717064" style="zoom:50%;"></p><p>三者的计算规则是不一样的，其中：</p><ul><li><p>inner join的计算规则是，用左边表的每一行去匹配右边表的每一行，如果满足连接的条件，就组成一行返回，返回的行里面包括两张表的所有字段，如果不满足连接的条件，就不返回。</p></li><li><p>left join的计算规则是：以左边表为基准，用左边表的每一行去匹配右边表的每一行，如果满足连接的条件，就组成一行返回，如果连接的字段值只在左边表存在，在右边表不存在，那么在结果中就只显示左边表的字段值，右边表中的字段用空值（null）来表示。</p></li><li><p>right join的计算规则是：以右边表为基准，用右边表的每一行去匹配左边表的每一行，如果满足连接的条件，就组成一行返回，如果连接的字段值只在右边表存在，在左边表不存在，那么在结果中就只显示右边表的字段值，左边表中的字段用空值null来表示。</p></li></ul><h1 id="7-组合查询union"><a href="#7-组合查询union" class="headerlink" title="7. 组合查询union"></a>7. 组合查询union</h1><ul><li><p>可用union操作符来组合数条SQL查询，利用union可以将多条select语句组合起来，将它们的结果组合成单个结果集</p></li><li><p>语法：</p><ul><li>select <em> from 表 where 条件 union select </em> from 表 where 条件</li><li>select <em> from 表 where 条件 union all select </em> from 表 where 条件</li><li><strong>union和union all的区别：union会对结果自动去重，union all不会去重</strong></li></ul></li><li><p>注意：两个select语句应该有相同数量的列，数据类型要相同或者可以兼容</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#例如：查询客户姓名、客户地址、以及供应商1001供应的产品信息</span><br><span class="line">select cust_name, cust_address from customers</span><br><span class="line">UNION</span><br><span class="line">select * from products where vend_id=1001;</span><br><span class="line">#报错：The used SELECT statements have a different number of columns</span><br></pre></td></tr></tbody></table></figure></li><li><p>举例：</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#查询价格小于等于5的产品以及供应商1001和1002生产的所有产品（不考虑价格）。</span><br><span class="line">select vend_id,prod_id,prod_price from products where prod_price&lt;=5</span><br><span class="line">    -&gt; union</span><br><span class="line">    -&gt; select vend_id, prod_id,prod_price from products where vend_id in (1001,1002);</span><br><span class="line"></span><br><span class="line">#查询价格小于等于5的产品以及供应商1001和1002生产的所有物品（不考虑价格）。</span><br><span class="line">select vend_id,prod_id,prod_price from products where prod_price&lt;=5</span><br><span class="line">    -&gt; union all</span><br><span class="line">    -&gt; select vend_id, prod_id,prod_price from products where vend_id in (1001,1002);</span><br></pre></td></tr></tbody></table></figure><h1 id="8-索引Index"><a href="#8-索引Index" class="headerlink" title="8. 索引Index"></a>8. 索引Index</h1><ul><li>索引是一种<strong>数据结构</strong>，作用是<strong>可以提高查询的效率</strong></li><li>在数据库表中可以对某个字段创建索引，有索引的字段在查询效率上会明显比没有索引的要快</li><li>索引是针对每个字段创建的<ul><li>但是在实际使用中，我们不会对每个字段都创建索引，一般我们会对经常被查询的字段或者是经常被用来作为连表条件的字段创建索引</li></ul></li><li>主键和外键会自动创建索引</li></ul><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询表有哪些索引</span><br><span class="line">show index from customers;</span><br><span class="line">#创建索引</span><br><span class="line">create index index_cust_address on customers(cust_address);</span><br><span class="line">#删除索引</span><br><span class="line">drop index index_cust_address on customers;</span><br></pre></td></tr></tbody></table></figure><h1 id="9-视图View"><a href="#9-视图View" class="headerlink" title="9. 视图View"></a>9. 视图View</h1><ul><li>视图是<strong>一张虚拟的表</strong>，视图的数据是由SQL语句从真正的表中查询得到的</li><li>视图支持查询，但不支持增删改操作</li><li>创建视图的场景：需要经常查询某个较复杂的连表时，可以创建视图，使查询简便</li></ul><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#创建一个视图(显示用户名字及其购买的产品id)</span><br><span class="line">create view cust_name_prod_id </span><br><span class="line">as </span><br><span class="line">select c.cust_name,oi.prod_id from customers c</span><br><span class="line">inner join orders o</span><br><span class="line">on c.cust_id=o.cust_id </span><br><span class="line">inner join orderitems oi</span><br><span class="line">on o.order_num=oi.order_num;</span><br><span class="line">#基于视图的查询</span><br><span class="line">#列出订购物品编号TNT2的所有客户姓名</span><br><span class="line">select cust_name from cust_name_prod_id where prod_id="TNT2";</span><br></pre></td></tr></tbody></table></figure><h1 id="10-SQL语句的分类"><a href="#10-SQL语句的分类" class="headerlink" title="10. SQL语句的分类"></a>10. SQL语句的分类</h1><ul><li>DQL（<strong>Data Query Language</strong>数据查询语言）：select  (query)</li><li>DML（<strong>Data Manage Language</strong>数据库操纵语言）：insert into/delete from/update等</li><li>DDL（<strong>Data Describe Language</strong>数据库描述语言）：create/alter/drop等</li><li>DCL（<strong>Data Control Language</strong>数据库控制语言）：grant/commit/rollback等</li></ul><p>SQL语言，所有关系型数据库的操作都是基于SQL语句来实现。</p><h1 id="11-数据库的导入和导出"><a href="#11-数据库的导入和导出" class="headerlink" title="11. 数据库的导入和导出"></a>11. 数据库的导入和导出</h1><p>导出（备份）：把数据库的结构和数据转储为SQL脚本，也叫备份数据库</p><p>导入（恢复）：执行SQL脚本创建数据库、表、插入数据，也叫恢复数据库</p><h2 id="方法一：在Linux主机上通过命令导出和导入"><a href="#方法一：在Linux主机上通过命令导出和导入" class="headerlink" title="方法一：在Linux主机上通过命令导出和导入"></a>方法一：在Linux主机上通过命令导出和导入</h2><ul><li><p>导出命令</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u用户名 -p密码  数据库名称&gt;SQL脚本文件的路径</span><br><span class="line">#举例：</span><br><span class="line">mysqldump -uroot -p123456 crashcourse&gt;/usr/local/src/crashcourse_33.sql</span><br></pre></td></tr></tbody></table></figure></li><li><p>导入命令：先用mysql命令登录数据库，再用source命令执行SQL脚本，如果SQL脚本中没有创建数据库的语句，就需要先手动创建。</p><ul><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#输入用户密码，登录mysql</span><br><span class="line">mysql -uroot -p123456</span><br><span class="line">#执行sql脚本导入数据库</span><br><span class="line">source /usr/local/src/crashcourse_33.sql</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/05/09/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/452c3aa4-9591-415f-95b5-4bef373bbed4-3400539.jpg" alt="img" style="zoom:50%;"></p></li></ul></li></ul><h2 id="方法二：通过数据库客户端导出和导入，以SQLyog为例"><a href="#方法二：通过数据库客户端导出和导入，以SQLyog为例" class="headerlink" title="方法二：通过数据库客户端导出和导入，以SQLyog为例"></a>方法二：通过数据库客户端导出和导入，以SQLyog为例</h2><ul><li><p>导出：<img src="/2024/05/09/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/731bc683-f046-45a7-9264-8e5bc0a113a4-3400539.jpg" alt="img" style="zoom:50%;"></p></li><li><p>导入：<img src="/2024/05/09/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/b181e2e9-b93f-4f1e-a5cf-c3ad79307de8-3400539.jpg" alt="img" style="zoom:50%;"></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0-演示的数据库的表结构说明&quot;&gt;&lt;a href=&quot;#0-演示的数据库的表结构说明&quot; class=&quot;headerlink&quot; title=&quot;0. 演示的数据库的表结构说明&quot;&gt;&lt;/a&gt;0. 演示的数据库的表结构说明&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2024/05/09/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/MySQL%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B6%E4%BB%96/image-20240509151831003.png&quot; alt=&quot;image-20240509151831003&quot; style=&quot;zoom: 67%;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-表的查询&quot;&gt;&lt;a href=&quot;#1-表的查询&quot; class=&quot;headerlink&quot; title=&quot;1. 表的查询&quot;&gt;&lt;/a&gt;1. 表的查询&lt;/h1&gt;&lt;h2 id=&quot;1-1-查询表的一个或多个字段的值&quot;&gt;&lt;a href=&quot;#1-1-查询表的一个或多个字段的值&quot; class=&quot;headerlink&quot; title=&quot;1.1 查询表的一个或多个字段的值&quot;&gt;&lt;/a&gt;1.1 查询表的一个或多个字段的值&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;语法：select 字段1,字段2,… from 表名;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#查询客户ID和Name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select cust_id,cust_name from customers;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-查询表中所有字段的值&quot;&gt;&lt;a href=&quot;#1-2-查询表中所有字段的值&quot; class=&quot;headerlink&quot; title=&quot;1.2 查询表中所有字段的值&quot;&gt;&lt;/a&gt;1.2 查询表中所有字段的值&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;语法：select &lt;em&gt; from 表名;  这是的&lt;/em&gt;表示所有字段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#查询所有订单信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from orders;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-对查询的结果去重select-distinct&quot;&gt;&lt;a href=&quot;#1-3-对查询的结果去重select-distinct&quot; class=&quot;headerlink&quot; title=&quot;1.3 对查询的结果去重select distinct&quot;&gt;&lt;/a&gt;1.3 对查询的结果去重select distinct&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select distinct 字段1 from 表名;&lt;/li&gt;
&lt;li&gt;select distinct 字段1,字段2 from 表名;    #表示对两个字段的组合去重&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#查询所有下过订单的客户ID&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select distinct cust_id from orders;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-4-设定查询结果返回的行数limit&quot;&gt;&lt;a href=&quot;#1-4-设定查询结果返回的行数limit&quot; class=&quot;headerlink&quot; title=&quot;1.4 设定查询结果返回的行数limit&quot;&gt;&lt;/a&gt;1.4 设定查询结果返回的行数limit&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;格式一：select * from 表名 limit n,m; &lt;/p&gt;
&lt;p&gt;说明：当limit后面跟两个参数时，第一个参数为偏移量，第二个参数为返回的行数，意思是从行号为n的行开始的后面m行；MySQL中的行号是从0开始计算的，limit 2,3是第3行开始往后数3行，也就是第3，4，5行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;格式二：select * from 表名 limit m; &lt;/p&gt;
&lt;p&gt;说明：当limit后面跟一个参数时，表示返回的行数，从第1行开始计算，可以理解成此时的偏移量是0，比如limit 3是指前三行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;举例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#例如查询第3行到第10行的商户&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select vend_id from vendors limit 2,8; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#2代表行号，行号从0开始，所以第3行的行号为2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#8代表展示多少行，从第3行到第10行一共有8行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#查询订单中的前4行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from orders limit 4;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://laylaycjl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="https://laylaycjl.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="https://laylaycjl.github.io/2024/05/06/mysql/"/>
    <id>https://laylaycjl.github.io/2024/05/06/mysql/</id>
    <published>2024-05-06T07:24:43.000Z</published>
    <updated>2024-05-09T07:17:18.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、数据库基础"><a href="#1、数据库基础" class="headerlink" title="1、数据库基础"></a>1、数据库基础</h1><h2 id="1-1-什么是数据库（DB）"><a href="#1-1-什么是数据库（DB）" class="headerlink" title="1.1 什么是数据库（DB）"></a>1.1 什么是数据库（DB）</h2><p>数据库：Database，简称DB，是按照数据结构来<strong>组织</strong>、<strong>存储</strong>和<strong>管理数据</strong>的仓库。</p><h2 id="1-2-什么是数据库管理系统（DBMS）"><a href="#1-2-什么是数据库管理系统（DBMS）" class="headerlink" title="1.2 什么是数据库管理系统（DBMS）"></a>1.2 什么是数据库管理系统（DBMS）</h2><p>用于管理数据库的软件称为数据库管理软件（DBMS：Database Management System）。</p><p>对数据库的操作与管理是通过该数据库管理软件来完成的。</p><p>行业中主流的数据库管理软件有：MySQL、MariaDB、Oracle、DB2、SQL Server、Redis、MongoDB等，本课程讲解MySQL的使用。中国的数据库管理软件：达梦</p><p><img src="/2024/05/06/mysql/mysql/image-20240509150944734.png" alt="image-20240509150944734" style="zoom:50%;"></p><h2 id="1-3-数据库管理系统的类型"><a href="#1-3-数据库管理系统的类型" class="headerlink" title="1.3 数据库管理系统的类型"></a>1.3 数据库管理系统的类型</h2><h3 id="1、关系型数据库"><a href="#1、关系型数据库" class="headerlink" title="1、关系型数据库"></a>1、关系型数据库</h3><p>常用的关系型数据库：MySQL、MariaDB、Oracle、DB2、SQL Server、SQLite、Access等</p><p>特点：</p><ul><li>数据以<strong>二维表格</strong>的形式存储，一类数据一般放在一张表中（类似Excel的表格），比如学生的信息放在学生表中；</li><li>一张表由许多行和列组成，<strong>每列为各种记录名称，也叫字段</strong>，每行为记录名称所对应的数据，也叫一条记录；</li><li>一个数据库由很<strong>多张表</strong>组成；</li><li>在数据库管理系统上可以创建很<strong>多个数据库</strong></li></ul><blockquote><p>常用的关系型数据库介绍：</p><ul><li>MySQL：由瑞典的MySQL AB公司开发，后来被甲骨文（Oracle）公司收购，是最流行的关系型数据库管理系统之一，在Web应用当面MySQL是最好的RDBMS之一。MySQL 软件采用了双授权政策，分为社区版和商业版</li><li>MariaDB：MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。CentOS从7版本开始自带的数据库就是MariaDB</li><li>Oracle：商业的软件，甲骨文公司开发，功能强、性能好，在中大型系统中广泛使用，多用于通信、银行等领域</li></ul></blockquote><p><strong>所有关系型数据库的语法都是基于SQL（结构化查询语言）语言实现，MySQL用的是标准的SQL语言</strong></p><h3 id="2、非关系型数据库"><a href="#2、非关系型数据库" class="headerlink" title="2、非关系型数据库"></a>2、非关系型数据库</h3><p>常用的非关系型数据库管理系统：Redis、MongoDB、Memcached、Neo4j等。与关系型数据库中数据是基于表存储的不同，非关系型数据库中的数据有的是<strong>基于键值对</strong>存储的（Redis、Memcached），有的是<strong>基于文档</strong>存储的（MongoDB），有的是<strong>基于图片</strong>存储的（Neo4j）</p><p>特点：</p><ul><li>数据的读写相对更快，性能更好；</li><li>每种非关系数据库的语法不一样，学习成本较高。</li></ul><p>有的项目中，可能是<strong>MySQL+Redis</strong>组合使用，也有可能只用关系型数据库。我们上课主要讲解关系型数据库MySQL。</p><span id="more"></span><h2 id="1-4-工作中哪些时候需要用到数据库"><a href="#1-4-工作中哪些时候需要用到数据库" class="headerlink" title="1.4 工作中哪些时候需要用到数据库"></a>1.4 工作中哪些时候需要用到数据库</h2><ul><li><p><strong>搭建环境</strong>的时候需要安装数据库，并在数据库中<strong>构造初始化数据</strong></p><p>比如系统的管理员账号就是预设在数据库中的；</p></li><li><p>在测试过程中，有时<strong>需要查询数据库来验证用例通过与否</strong></p><p>这个过程叫<strong>断言</strong>，也就是对比预期结果跟实际结果，有的系统没有页面，只能查数据库校验用例通过与否；</p></li><li><p>有些时候<strong>验证功能</strong>，需要修改数据库中的数据来构造对应的场景</p><p>比如某些功能只有特定用户可以使用，此时需要在数据库修改相关标识，从而对该功能进行验证）</p></li><li><p>在测试中，有的数据只能通过查数据库获取到，在页面上查不到</p></li><li><p>有的时候，需要统计一些数据，直接查询数据库<strong>更方便</strong></p></li></ul><h1 id="2-MySQL数据库的基本概念"><a href="#2-MySQL数据库的基本概念" class="headerlink" title="2. MySQL数据库的基本概念"></a>2. MySQL数据库的基本概念</h1><h2 id="2-1-表（Table）"><a href="#2-1-表（Table）" class="headerlink" title="2.1 表（Table）"></a>2.1 表（Table）</h2><ul><li><p>关系数据库中的数据是保存在表里面的，存储在表中的数据是一种特定类型的数据</p></li><li><p>在数据库中，表有一个唯一的名字来标识该表，称为表名</p></li><li><p>表定义了数据在表中如何存储</p><p>如：可以存在什么样的数据、数据如何分解、各部分信息如何命名等；</p><p>比如：将京东的客户信息保存在一个顾客表中可以取名为customers</p></li><li><p>一个数据库可以有很多张表</p></li></ul><h2 id="2-2-列（Column-Field）"><a href="#2-2-列（Column-Field）" class="headerlink" title="2.2 列（Column/Field）"></a>2.2 列（Column/Field）</h2><ul><li><p>表由列组成，列中存储着表中某部分的信息</p></li><li><p>所有表都是由一个或多个列组成的，一列也叫<strong>一个字段</strong>，所以一张表可以有很多个字段</p></li><li><p>比如：在学生表中，一个学生信息如下：学号、姓名、性别、班级、年龄、手机号等，相同的属性的值都存放在一列，比如学号存放在一列，姓名存放在一列</p><p><img src="/2024/05/06/mysql/mysql/image-20240509150931774.png" alt="image-20240509150931774" style="zoom:50%;"></p></li></ul><h2 id="2-3-行（Row）"><a href="#2-3-行（Row）" class="headerlink" title="2.3 行（Row）"></a>2.3 行（Row）</h2><ul><li>表中的数据是按行存储的，一行就是<strong>一条记录</strong></li><li>一张表中可以有多行（多条数据）</li></ul><p>如果将表想象成网格，网格中垂直的行为表列，水平的行为表行。</p><p><img src="/2024/05/06/mysql/mysql/image-20240509150913083.png" alt="image-20240509150913083" style="zoom:50%;"></p><h2 id="2-4-MySQL软件、数据库、表、列、行的关系"><a href="#2-4-MySQL软件、数据库、表、列、行的关系" class="headerlink" title="2.4 MySQL软件、数据库、表、列、行的关系"></a>2.4 MySQL软件、数据库、表、列、行的关系</h2><p>在MySQL软件系统可以创建很多个数据库，每个数据库可以有多个表，每个表可以有多个列（字段），每个表可以有多行数据。</p><p><img src="/2024/05/06/mysql/mysql/image-20240509150857204.png" alt="image-20240509150857204" style="zoom: 50%;"></p><h1 id="3-数据库的创建、连接、删除等操作"><a href="#3-数据库的创建、连接、删除等操作" class="headerlink" title="3. 数据库的创建、连接、删除等操作"></a>3. 数据库的创建、连接、删除等操作</h1><h2 id="3-1-创建数据库create-database"><a href="#3-1-创建数据库create-database" class="headerlink" title="3.1 创建数据库create database"></a>3.1 创建数据库create database</h2><ul><li><p>语法：</p><ul><li>create database 数据库名称;</li><li>create database if not exists 数据库名称;    #如果数据库不存在就创建，存在就不创建</li></ul></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#创建一个不存在的数据库test，会创建成功</span><br><span class="line">create database test;</span><br><span class="line"></span><br><span class="line">#加上IF NOT EXISTS判断，如果存在就不创建，这样就不会报错</span><br><span class="line">create database if not exists test;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="3-2-查询数据库的建库语句show-create-database"><a href="#3-2-查询数据库的建库语句show-create-database" class="headerlink" title="3.2 查询数据库的建库语句show create database"></a>3.2 查询数据库的建库语句show create database</h2><ul><li><p>语法：show create database 数据库名称;</p></li><li><p>作用：可以反向地把创建数据库的语句查出来。</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create database student;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="3-3-查询有哪些数据库show-databases"><a href="#3-3-查询有哪些数据库show-databases" class="headerlink" title="3.3 查询有哪些数据库show databases;"></a>3.3 查询有哪些数据库show databases;</h2><ul><li><p>语法：show databases;</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="3-4-选择数据库use"><a href="#3-4-选择数据库use" class="headerlink" title="3.4 选择数据库use"></a>3.4 选择数据库use</h2><ul><li><p>语法：use 数据库名称; </p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#连接数据库test_db</span><br><span class="line">use test_db;</span><br></pre></td></tr></tbody></table></figure><p>选择数据库后，后续的操作就是在这个数据库里进行的</p></li></ul><h2 id="3-5-删除数据库drop-database"><a href="#3-5-删除数据库drop-database" class="headerlink" title="3.5 删除数据库drop database"></a>3.5 删除数据库drop database</h2><ul><li><p>语法：</p><ul><li>drop database 数据库名称;</li><li>drop database if exists 数据库名称;     #如果数据库存在就删除，如果不存在也不报错</li></ul></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#删除数据库test_db</span><br><span class="line">drop database test_db;</span><br><span class="line"></span><br><span class="line">#删除一个不存在的数据库，加上IF EXISTS就不会报错</span><br><span class="line">drop database if exists test_db;</span><br></pre></td></tr></tbody></table></figure><p>删除数据库，会连同删除数据库里的所有数据。</p></li></ul><h2 id="3-6-查看MySQL的系统变量show-variables"><a href="#3-6-查看MySQL的系统变量show-variables" class="headerlink" title="3.6 查看MySQL的系统变量show variables"></a>3.6 查看MySQL的系统变量show variables</h2><ul><li><p>MySQL中有很多系统变量，在工作中可能需要涉及到修改或查询某个变量。</p></li><li><p>语法：</p><ul><li>查询所有的系统变量：show variables;</li><li>查询指定的某个系统变量，可以用一下两种方式：<ul><li>show variables like “变量名”；       #查询某个变量的值</li><li>show variables like “%关键字%”;   #根据关键字模糊查询变量的值</li><li>select @@变量名;                                 #查询某个变量的值</li></ul></li></ul></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#查询所有系统变量</span><br><span class="line">show variables;</span><br><span class="line"></span><br><span class="line">#查询变量autocommit的值</span><br><span class="line">show variables like "autocommit";</span><br><span class="line"></span><br><span class="line">#查询指定的某个系统变量</span><br><span class="line">show variables like "%commit%";</span><br><span class="line"></span><br><span class="line">#查询指定的某个系统变量，如下autocommit变量为1表示数据库会对增删改操作执行自动提交</span><br><span class="line">select @@autocommit;</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4. 数据类型"></a>4. 数据类型</h1><h2 id="4-1-数值型"><a href="#4-1-数值型" class="headerlink" title="4.1 数值型"></a>4.1 数值型</h2><ul><li><p>整型</p><ul><li>tinyint：1字节，非常小的整数，带符号：-128~127，不带符合：0~255；</li><li><font color="red"> int：4字节，标准整型，带符号：-2147483648\~2147483647，不带符号：0~4294967295；</font></li><li>其他类型：smallint（2字节）、mediumint（3字节）、bigint（8字节）；</li></ul></li><li><p>浮点型</p><ul><li>float：4字节，单精度浮点数；7.989999</li><li>double：8字节，双精度浮点数；7.98999999999</li><li><font color="red"> decimal(m,d)：m表示整数加小数的总位数，d表示小数位数，比如decimal(4,2)；</font>7.99</li><li>区别：float与double存储的是近似值，decimal存储的是精确值。<strong>在数据库中涉及到钱的金额，一定要用decimal类型。</strong></li></ul></li></ul><h2 id="4-2-字符串型"><a href="#4-2-字符串型" class="headerlink" title="4.2 字符串型"></a>4.2 字符串型</h2><ul><li><p>字符串</p><ul><li><font color="red"> char(m)：最多可以容纳m个字符</font></li><li><font color="red"> varchar(m)：最多可以容纳m个字符，如果存储的字符数n少于m时，实际占用的存储空间是L+1个字节，其中L是n个字符占用的字节数，多出的1个字节是用来记录实际存储长度的</font></li><li>其他类型：blob（longblob），text（longtext）</li><li><p>char和varchar的区别</p><ul><li>char是<strong>固定长度</strong>的，每个值占用相同的字符数，<strong>不够的位数MySQL会在它的右边用空格字符补足</strong>，char不论字符长短都需要占用相同的空间，即使是空值也不例外</li><li>varchar是一种<strong>可变长度</strong>的类型，每个值占用其刚好的字符数再加上一个用来记录其长度的字节即L+1个字节</li></ul></li><li><p>char和varchar怎么选择：</p><ul><li>如果数据都有相同的长度选char，选用varchar会多占用空间，因为有一位用来存储其长度<ul><li>手机号，身份证号等固定长度可以使用char</li></ul></li><li>如果数据长度不一选varchar，<strong>选用varchar能节省存储空间</strong>，例如，varchar(10)则不一定使用了10个空间<ul><li>账号、地址、姓名等不固定长度可以使用varchar</li></ul></li></ul></li></ul></li></ul><h2 id="4-3-日期时间型"><a href="#4-3-日期时间型" class="headerlink" title="4.3 日期时间型"></a>4.3 日期时间型</h2><ul><li><font color="red"> year：表示年，比如2000</font></li><li><font color="red">date：日期型，表示一个日期格式，如2020-01-01</font></li><li><font color="red"> time：时间型，表示一个时间格式，如22:10:15</font></li><li><font color="red"> datetime：日期时间型，表示一个日期+时间的组合格式，如2020-01-01 22:10:15</font></li><li>timestamp：时间戳型，如果某列的数据类型为timestamp且该列为not null，当插入数据时不指定该列的值，那么这个列就会自动取值为当前的日期和时间；在创建和修改数据行时，如果没有明确对timestamp数据列进行赋值，则它就会自动取值为当前的日期和时间。如果表中有多个timestamp列，只有第一个会自动取值。</li></ul><h2 id="4-4-枚举类型"><a href="#4-4-枚举类型" class="headerlink" title="4.4 枚举类型"></a>4.4 枚举类型</h2><ul><li>enum：枚举类型，当一个字段的值只能在某个范围内取值，比如性别只能取男或女，可以用enum(“男”,”女”)来表示，这个字段在插入数据时只能取男或者女或者不传值。每个枚举值都有一个索引，第一个值的索引为1。枚举类型的好处是MySQL在存储此类数据时，直接转化成数字存储而不是字符串，可以节省空间，并且在表的.frm文件中存储“数字-字符串”之间的对应关系。</li></ul><h1 id="5-表的创建、修改、删除等操作"><a href="#5-表的创建、修改、删除等操作" class="headerlink" title="5. 表的创建、修改、删除等操作"></a>5. 表的创建、修改、删除等操作</h1><h2 id="5-1-表的主键（Primary-Key）"><a href="#5-1-表的主键（Primary-Key）" class="headerlink" title="5.1 表的主键（Primary Key）"></a>5.1 表的主键（Primary Key）</h2><ul><li>通过primary key(主键字段)来指定主键。</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#给表添加主键</span><br><span class="line">alter table student43 add primary key(s_id);</span><br><span class="line">#设置主键自增</span><br><span class="line">alter table student43 modify s_id int auto_increment;</span><br><span class="line">#删除主键</span><br><span class="line">alter table student43 drop primary key;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>主键：==唯一标识表中每行的一列==（或几列）称为主键，主键也称主关键字</p></li><li><p>主键要满足的条件：</p><ul><li>任意两行都不具有相同的主键值，即<strong>主键值不重复</strong></li><li>每个行都必须具有一个主键值，即<strong>主键值不能为空</strong>（NULL）</li></ul></li></ul><p><strong>一张表只能有一个主键，但这个主键可以是一列，也可以是多列的组合；如果是多列的组合，那么多列的组合必须满足上面的两个条件</strong></p><h2 id="5-2-表的外键（Foreign-Key）"><a href="#5-2-表的外键（Foreign-Key）" class="headerlink" title="5.2 表的外键（Foreign Key）"></a>5.2 表的外键（Foreign Key）</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><ul><li>外键：外键用于关联两张表，==外键为表中的一列，同时又是另一个表的主键==，定义了两个表之间的关系，外键又称作外关键字</li><li>主表与从表：以另一个表的外键作为主键的表被称为主表，具有此外键的表被称为主表的从表</li><li>一张表可以有多个外键，每个外键分别关联不同主表的主键</li></ul><h3 id="（2）外键的作用："><a href="#（2）外键的作用：" class="headerlink" title="（2）外键的作用："></a>（2）外键的作用：</h3><ul><li><p>外键用于<strong>关联</strong>两张表；</p></li><li><p><strong>保持数据一致性，完整性</strong>，主要目的是控制存储在外键表中的数据；</p></li></ul><p>最直观的作用是==防止非法数据录入==，就是说录入外键数据时必须在它所属的主表中存在的相应数据，如果录入其他数据会报错</p><h3 id="（3）外键的功能由两种方法实现"><a href="#（3）外键的功能由两种方法实现" class="headerlink" title="（3）外键的功能由两种方法实现"></a>（3）外键的功能由两种方法实现</h3><p>CASCADE为级联执行、RESTRICT为阻止执行，默认为RESTRICT</p><h4 id="1）阻止执行（restrict）"><a href="#1）阻止执行（restrict）" class="headerlink" title="1）阻止执行（restrict）"></a>1）阻止执行（restrict）</h4><ul><li><p>从表插入新行，其外键值不是主表的主键值便阻止插入</p><ul><li>在成绩表中插入学生表中没有的学生成绩（会失败）</li></ul><p>从表修改外键值，新值不是主表的主键值便阻止修改</p></li><li><p>主表删除行，其主键值在从表里存在便阻止删除(要想删除，必须先删除从表的相关行)</p><ul><li>要删某学生，必须先删除成绩表中该学生的成绩</li></ul><p>主表修改主键值，旧值在从表里存在便阻止修改(要想修改，必须先删除从表的相关行)</p></li></ul><h4 id="2）级联执行（cascade）"><a href="#2）级联执行（cascade）" class="headerlink" title="2）级联执行（cascade）"></a>2）级联执行（cascade）</h4><ul><li><p>主表删除行，连带从表的相关行一起删除</p></li><li><p>主表修改主键值，连带从表相关行的外键值一起修改</p></li></ul><h2 id="5-3-创建表create"><a href="#5-3-创建表create" class="headerlink" title="5.3 创建表create"></a>5.3 创建表create</h2><p>语法：create table 表名 (字段1 数据类型 属性,字段2 数据类型 属性, …, primary key(主键字段));</p><ul><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#创建学生表，包含学号、姓名、性别、出生日期四个字段，指定引擎为INNODB</span><br><span class="line">create table students (</span><br><span class="line">    sid int not null COMMENT"学号",</span><br><span class="line">    sname varchar(20) not null COMMENT"姓名",</span><br><span class="line">    sgender enum("男","女") COMMENT"性别",</span><br><span class="line">    sbirth date COMMENT"出生日期"，</span><br><span class="line">    primary key(sid)</span><br><span class="line">) </span><br><span class="line">engine=innodb   #数据库安装后默认使用的是InnoDB引擎</span><br><span class="line">DEFAULT CHARSET=utf8;   #指定字符集为utf8</span><br><span class="line"></span><br><span class="line">#创建一个老师表，包括老师编号、姓名、性别、家庭住址，默认家庭住址是蜀都中心</span><br><span class="line">create table teachers (</span><br><span class="line">    id int not null,</span><br><span class="line">    tname varchar(20) not null,</span><br><span class="line">    sex enum("男","女"),</span><br><span class="line">    address varchar(20) default "蜀都中心"，  #设置默认值</span><br><span class="line">    primary key(id)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="5-4-查看表的结构desc"><a href="#5-4-查看表的结构desc" class="headerlink" title="5.4 查看表的结构desc"></a>5.4 查看表的结构desc</h2><ul><li><p>语法：desc 表名;</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">desc test;</span><br><span class="line">+----------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field          | Type         | Null | Key | Default | Extra |</span><br><span class="line">+----------------+--------------+------+-----+---------+-------+</span><br><span class="line">| ID_            | varchar(64)  | NO   | PRI | NULL    |       |</span><br><span class="line">| DEM_NAME_      | varchar(64)  | YES  |     | NULL    |       |</span><br><span class="line">| CODE_          | varchar(64)  | YES  | MUL | NULL    |       |</span><br><span class="line">+----------------+--------------+------+-----+---------+-------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="5-5-修改表添加外键alter-table-add-constaint"><a href="#5-5-修改表添加外键alter-table-add-constaint" class="headerlink" title="5.5 修改表添加外键alter table add constaint"></a>5.5 修改表添加外键alter table add constaint</h2><ul><li><p>语法：alter table 从表名称 add constraint 外键名称 foreign key(外键) references 主表名称(主键);</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#修改course表，指定teacher_id作为外键，关联教师表的teacher_id，并设置级联执行删除</span><br><span class="line">alter table course add constraint fk_course_teacher foreign key(teacher_id) references teacher(teacher_id) on delete cascade;</span><br><span class="line"></span><br><span class="line">#删除外键</span><br><span class="line">alter table course drop foreign key fk_course_teacher;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="5-6-在表中增加一个字段alter-table-add"><a href="#5-6-在表中增加一个字段alter-table-add" class="headerlink" title="5.6 在表中增加一个字段alter table add"></a>5.6 在表中增加一个字段alter table add</h2><ul><li><p>语法：alter table 表名 add 字段名 数据类型 属性;</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在students表中增加字段age_</span><br><span class="line">alter table students add age_ int;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="5-7-修改表的字段alter-table-change-modify"><a href="#5-7-修改表的字段alter-table-change-modify" class="headerlink" title="5.7 修改表的字段alter table change/modify"></a>5.7 修改表的字段alter table change/modify</h2><ul><li><p>语法：</p><ul><li>alter table 表名 modify 列名 新类型 新属性;</li><li>alter table 表名  change 旧列名 新列名 新类型 新属性;</li></ul><p>其中，modify只能改变列的属性，change可以改变列名及属性。</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#把字段name_的数据类型改成varchar(30)，非空</span><br><span class="line">alter table students modify name_ varchar(30) not null;</span><br><span class="line"></span><br><span class="line">#把字段birthday_的名称改为birthdate_，数据类型为datetime，非空</span><br><span class="line">alter table students change birthday_ birthdate_  datetime not null;</span><br><span class="line"></span><br><span class="line">#修改后查看表的结构，可以看到字段已经被修改成功</span><br><span class="line">desc students;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="5-8-在表中删除一个字段alter-table-drop"><a href="#5-8-在表中删除一个字段alter-table-drop" class="headerlink" title="5.8 在表中删除一个字段alter table drop"></a>5.8 在表中删除一个字段alter table drop</h2><ul><li><p>语法：alter table 表名 drop 字段名;</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#删除students表中的age_字段</span><br><span class="line">alter table students drop age_;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="5-9-重命名表alter-table-rename-to"><a href="#5-9-重命名表alter-table-rename-to" class="headerlink" title="5.9 重命名表alter table rename to"></a>5.9 重命名表alter table rename to</h2><ul><li><p>语法：alter table 当前表名 rename to 修改后的表名;</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table students rename to students_info;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="5-10-删除一张表drop-table-truncate-table"><a href="#5-10-删除一张表drop-table-truncate-table" class="headerlink" title="5.10 删除一张表drop table/truncate table"></a>5.10 删除一张表drop table/truncate table</h2><ul><li><p>语法：</p><ul><li>drop table 表名;</li><li>drop table  if  exists 表名;    #如果表存在就删除，如果不存在也不报错</li></ul></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#删除表students</span><br><span class="line">drop table students;</span><br><span class="line"></span><br><span class="line">#删除students表数据</span><br><span class="line">truncate table students;</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>drop table和truncate table的区别</p><p>drop是删除表及其中的所有数据</p><p>truncate是先drop表，然后会新建一张空表，相当于只删除表数据</p></li></ul><h1 id="6-表数据的增删改操作"><a href="#6-表数据的增删改操作" class="headerlink" title="6. 表数据的增删改操作"></a>6. 表数据的增删改操作</h1><h2 id="6-1-插入数据insert-into…values"><a href="#6-1-插入数据insert-into…values" class="headerlink" title="6.1 插入数据insert into…values"></a>6.1 插入数据insert into…values</h2><ul><li><p>语法：</p><ul><li>insert into 表名 ( 字段1, 字段2,…字段n ) values ( 值1, 值2,…值n );</li><li>insert into 表名 values ( 值1, 值2,…值n );</li></ul></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#场景一：插入一条数据，指定字段名称，插入所有字段的值，</span><br><span class="line">insert into students (id_,name_,sex_,birthday_) values (1,"张三","男","2001-1-1");</span><br><span class="line"></span><br><span class="line">#场景二：插入一条数据，指定字段名称，只插入必填值</span><br><span class="line">insert into students (id_,name_) values (2,"李四");</span><br><span class="line"></span><br><span class="line">#场景三：插入一条数据，不写字段名称，直接写数据，但这种情况下需要对所有字段插入值，并且值的顺序必须与表中的字段顺序保持一致</span><br><span class="line">insert into students values (3,"李四","男","2001-1-1");</span><br><span class="line"></span><br><span class="line">#场景四：插入多条数据：每条数据用小括号括起来，小括号之间用逗号隔开</span><br><span class="line">insert into students values (4,"王五","男","2001-1-1"),(5,"赵六","男","2001-1-1"),(6,"刘七","男","2001-1-1");</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="6-2-删除数据delete-from…-where、truncate-table"><a href="#6-2-删除数据delete-from…-where、truncate-table" class="headerlink" title="6.2 删除数据delete from… where、truncate table"></a>6.2 删除数据delete from… where、truncate table</h2><ul><li><p>语法：delete from 表名 [where子句];</p><p>在删除数据是一般要使用where子句来指定删除特定的行，否则会删除表的所有行。</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#删除张三的信息</span><br><span class="line">delete from students where name_="张三";</span><br><span class="line"></span><br><span class="line">#快速清空学生表的数据</span><br><span class="line">truncate students;</span><br><span class="line">delete from students;</span><br></pre></td></tr></tbody></table></figure></li><li><p>快速清空表的数据：truncate table 表名 或者 truncate 表名;</p></li><li><p>delete from与truncate的区别：如果要清空表的所有数据，可以使用truncate语句，而且速度比delete from语句快，truncate语句是先删除整张表，然后重新创建一个空表；另外truncate删除的数据不可恢复，而delete from删除的数据时可以恢复的。</p></li></ul><h2 id="6-3-修改数据update-…-set-…-where"><a href="#6-3-修改数据update-…-set-…-where" class="headerlink" title="6.3 修改数据update … set … where"></a>6.3 修改数据update … set … where</h2><ul><li><p>语法：</p><ul><li>update 表名 set 字段1=值1 [where子句];</li><li>update 表名 set 字段1=值1, 字段2=值2 [where子句];</li></ul><p>在修改数据是一般要使用WHERE子句来指定修改特定的行，否则会修改表的所有行。</p></li><li><p>举例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#把张三的性别改成女</span><br><span class="line">update students set sex_="女" where name="张三";</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、数据库基础&quot;&gt;&lt;a href=&quot;#1、数据库基础&quot; class=&quot;headerlink&quot; title=&quot;1、数据库基础&quot;&gt;&lt;/a&gt;1、数据库基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是数据库（DB）&quot;&gt;&lt;a href=&quot;#1-1-什么是数据库（DB）&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是数据库（DB）&quot;&gt;&lt;/a&gt;1.1 什么是数据库（DB）&lt;/h2&gt;&lt;p&gt;数据库：Database，简称DB，是按照数据结构来&lt;strong&gt;组织&lt;/strong&gt;、&lt;strong&gt;存储&lt;/strong&gt;和&lt;strong&gt;管理数据&lt;/strong&gt;的仓库。&lt;/p&gt;
&lt;h2 id=&quot;1-2-什么是数据库管理系统（DBMS）&quot;&gt;&lt;a href=&quot;#1-2-什么是数据库管理系统（DBMS）&quot; class=&quot;headerlink&quot; title=&quot;1.2 什么是数据库管理系统（DBMS）&quot;&gt;&lt;/a&gt;1.2 什么是数据库管理系统（DBMS）&lt;/h2&gt;&lt;p&gt;用于管理数据库的软件称为数据库管理软件（DBMS：Database Management System）。&lt;/p&gt;
&lt;p&gt;对数据库的操作与管理是通过该数据库管理软件来完成的。&lt;/p&gt;
&lt;p&gt;行业中主流的数据库管理软件有：MySQL、MariaDB、Oracle、DB2、SQL Server、Redis、MongoDB等，本课程讲解MySQL的使用。中国的数据库管理软件：达梦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/05/06/mysql/mysql/image-20240509150944734.png&quot; alt=&quot;image-20240509150944734&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-3-数据库管理系统的类型&quot;&gt;&lt;a href=&quot;#1-3-数据库管理系统的类型&quot; class=&quot;headerlink&quot; title=&quot;1.3 数据库管理系统的类型&quot;&gt;&lt;/a&gt;1.3 数据库管理系统的类型&lt;/h2&gt;&lt;h3 id=&quot;1、关系型数据库&quot;&gt;&lt;a href=&quot;#1、关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;1、关系型数据库&quot;&gt;&lt;/a&gt;1、关系型数据库&lt;/h3&gt;&lt;p&gt;常用的关系型数据库：MySQL、MariaDB、Oracle、DB2、SQL Server、SQLite、Access等&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据以&lt;strong&gt;二维表格&lt;/strong&gt;的形式存储，一类数据一般放在一张表中（类似Excel的表格），比如学生的信息放在学生表中；&lt;/li&gt;
&lt;li&gt;一张表由许多行和列组成，&lt;strong&gt;每列为各种记录名称，也叫字段&lt;/strong&gt;，每行为记录名称所对应的数据，也叫一条记录；&lt;/li&gt;
&lt;li&gt;一个数据库由很&lt;strong&gt;多张表&lt;/strong&gt;组成；&lt;/li&gt;
&lt;li&gt;在数据库管理系统上可以创建很&lt;strong&gt;多个数据库&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;常用的关系型数据库介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL：由瑞典的MySQL AB公司开发，后来被甲骨文（Oracle）公司收购，是最流行的关系型数据库管理系统之一，在Web应用当面MySQL是最好的RDBMS之一。MySQL 软件采用了双授权政策，分为社区版和商业版&lt;/li&gt;
&lt;li&gt;MariaDB：MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。CentOS从7版本开始自带的数据库就是MariaDB&lt;/li&gt;
&lt;li&gt;Oracle：商业的软件，甲骨文公司开发，功能强、性能好，在中大型系统中广泛使用，多用于通信、银行等领域&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;所有关系型数据库的语法都是基于SQL（结构化查询语言）语言实现，MySQL用的是标准的SQL语言&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、非关系型数据库&quot;&gt;&lt;a href=&quot;#2、非关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;2、非关系型数据库&quot;&gt;&lt;/a&gt;2、非关系型数据库&lt;/h3&gt;&lt;p&gt;常用的非关系型数据库管理系统：Redis、MongoDB、Memcached、Neo4j等。与关系型数据库中数据是基于表存储的不同，非关系型数据库中的数据有的是&lt;strong&gt;基于键值对&lt;/strong&gt;存储的（Redis、Memcached），有的是&lt;strong&gt;基于文档&lt;/strong&gt;存储的（MongoDB），有的是&lt;strong&gt;基于图片&lt;/strong&gt;存储的（Neo4j）&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据的读写相对更快，性能更好；&lt;/li&gt;
&lt;li&gt;每种非关系数据库的语法不一样，学习成本较高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有的项目中，可能是&lt;strong&gt;MySQL+Redis&lt;/strong&gt;组合使用，也有可能只用关系型数据库。我们上课主要讲解关系型数据库MySQL。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://laylaycjl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="https://laylaycjl.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络配置及工具</title>
    <link href="https://laylaycjl.github.io/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/"/>
    <id>https://laylaycjl.github.io/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/</id>
    <published>2024-04-29T08:43:44.000Z</published>
    <updated>2024-05-05T13:36:38.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、网络相关命令"><a href="#一、网络相关命令" class="headerlink" title="一、网络相关命令"></a>一、网络相关命令</h1><h2 id="1、查看ip配置信息和网络情况：-ip、ifconfig、ping"><a href="#1、查看ip配置信息和网络情况：-ip、ifconfig、ping" class="headerlink" title="1、查看ip配置信息和网络情况：==ip、ifconfig、ping=="></a>1、查看ip配置信息和网络情况：==ip、ifconfig、ping==</h2><h3 id="（1）ip"><a href="#（1）ip" class="headerlink" title="（1）ip"></a>（1）ip</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip -4 addr：显示主机的IP v4地址</span><br><span class="line">ip -6 addr：查看主机的IP v6地址</span><br><span class="line">ip addr：查看主机的所有IP地址</span><br></pre></td></tr></tbody></table></figure><p>查看ip配置信息</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip address</span><br><span class="line">也可简写为ip a</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240505203605412.png" alt="image-20240505203605412" style="zoom:50%;"></p><p>ens33是虚拟机默认的网络接口，所以后面跟的就是虚拟机的ip地址，24表示的是子网掩码，即255.255.255.0</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429164741792.png" alt="image-20240429164741792" style="zoom:50%;"></p><h3 id="（2）ifconfig（最常用）"><a href="#（2）ifconfig（最常用）" class="headerlink" title="（2）ifconfig（最常用）"></a>（2）ifconfig（最常用）</h3><p>ifconfig查看ip地址、子网掩码和收发包情况（比ip address看到的信息更多）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0：查看指定网卡的IP地址</span><br><span class="line">ifconfig eth0 down：禁用eth0接口</span><br><span class="line">ifconfig eth0 up：启用eth0接口</span><br><span class="line"></span><br><span class="line">ifconfig -a：查看所有网卡的IP地址</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240505204146234.png" alt="image-20240505204146234" style="zoom: 50%;"></p><h3 id="（3）ping"><a href="#（3）ping" class="headerlink" title="（3）ping"></a>（3）ping</h3><p>用于检查网络是否联通，ping得快说明网速好</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br><span class="line"></span><br><span class="line">ping -c 5 www.baidu.com</span><br><span class="line">设置发5个包</span><br></pre></td></tr></tbody></table></figure><p>ping成功后，默认一直ping直到ctrl C 结束</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br><span class="line">ctrl+C</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429165344925.png" alt="image-20240429165344925" style="zoom:50%;"></p><p>可以通过参数-c设置ping包的数目</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping -c 5 www.baidu.com</span><br><span class="line">设置发5个包</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429165559223.png" alt="image-20240429165559223" style="zoom:50%;"></p><p>Windows默认ping4个包就结束，不用CtrlC手动终止</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429165516006.png" alt="image-20240429165516006" style="zoom:50%;"></p><span id="more"></span><h2 id="2、禁用、启用网络接口"><a href="#2、禁用、启用网络接口" class="headerlink" title="2、禁用、启用网络接口"></a>2、禁用、启用网络接口</h2><h3 id="（1）-ifdown、ifup"><a href="#（1）-ifdown、ifup" class="headerlink" title="（1）==ifdown、ifup=="></a>（1）==ifdown、ifup==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifdown eth0：禁用eth0接口</span><br><span class="line">ifup eth0：启用eth0接口</span><br></pre></td></tr></tbody></table></figure><h3 id="（2）-ifconfig"><a href="#（2）-ifconfig" class="headerlink" title="（2）==ifconfig=="></a>（2）==ifconfig==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 down：禁用eth0接口</span><br><span class="line">ifconfig eth0 up：启用eth0接口</span><br></pre></td></tr></tbody></table></figure><h3 id="（3）-service-network"><a href="#（3）-service-network" class="headerlink" title="（3）==service network=="></a>（3）==service network==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service network stop：关闭网卡</span><br><span class="line">service network start：启动网卡</span><br><span class="line">service network status：查看网卡状态</span><br><span class="line">service network restart：重启网卡</span><br></pre></td></tr></tbody></table></figure><h2 id="3、查看服务器资源-free、top-命令"><a href="#3、查看服务器资源-free、top-命令" class="headerlink" title="3、查看服务器资源==free、top==命令"></a>3、查看服务器资源==free、top==命令</h2><h3 id="（1）查看服务器内存占用情况-free"><a href="#（1）查看服务器内存占用情况-free" class="headerlink" title="（1）查看服务器内存占用情况==free=="></a>（1）查看服务器内存占用情况==free==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">free </span><br><span class="line">free -m</span><br><span class="line">free -k</span><br><span class="line">free -g</span><br></pre></td></tr></tbody></table></figure><p>不带参数：</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429170151242.png" alt="image-20240429170151242" style="zoom:67%;"></p><p>以Mb，Kb，Gb大小显示内存占用情况</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429170327675.png" alt="image-20240429170327675" style="zoom:50%;"></p><h3 id="（2）同时查看内存和CPU占用情况-top"><a href="#（2）同时查看内存和CPU占用情况-top" class="headerlink" title="（2）同时查看内存和CPU占用情况==top=="></a>（2）同时查看内存和CPU占用情况==top==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></tbody></table></figure><p>会显示总的CPU使用情况，还会显示每个进程的CPU和内存占用情况</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429170853759.png" alt="image-20240429170853759" style="zoom:50%;"></p><h2 id="4、网络数据包统计（不常用）"><a href="#4、网络数据包统计（不常用）" class="headerlink" title="4、网络数据包统计（不常用）"></a>4、网络数据包统计（不常用）</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">显示网络数据包统计详细信息</span><br><span class="line">netstat -s</span><br><span class="line"></span><br><span class="line">显示网络数据包统计详细</span><br><span class="line">ifconfig -s</span><br></pre></td></tr></tbody></table></figure><h2 id="5、动态ip和静态ip的配置"><a href="#5、动态ip和静态ip的配置" class="headerlink" title="5、动态ip和静态ip的配置"></a>5、动态ip和静态ip的配置</h2><h3 id="（1）动态ip地址"><a href="#（1）动态ip地址" class="headerlink" title="（1）动态ip地址"></a>（1）动态ip地址</h3><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240505205226936.png" alt="image-20240505205226936" style="zoom:50%;"></p><p>DHCP client（PC/虚拟机）向服务器申请ip地址，DHCP server（路由器）动态给client分配ip地址</p><p>如图，虚拟机可以选择使用本地DHCP服务器分配ip地址</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429171428574.png" alt="image-20240429171428574" style="zoom: 67%;"></p><p>动态申请有租用时间，租期到了之后，DHCP client需要重新申请ip地址，所以分配到的ip是动态的，租期到了就会改变</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429171609999.png" alt="image-20240429171609999" style="zoom:67%;"></p><h3 id="（2）静态ip地址"><a href="#（2）静态ip地址" class="headerlink" title="（2）静态ip地址"></a>（2）静态ip地址</h3><p>需要手动配置，无法自动分配</p><h4 id="1）临时方案"><a href="#1）临时方案" class="headerlink" title="1）临时方案"></a>1）临时方案</h4><p>命令行方式配置IP</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.10 netmask 255.255.255.0 up</span><br><span class="line">eth0一般对应的是第一个网卡，</span><br><span class="line">192.168.1.10是给eth0配置的IP地址</span><br><span class="line">netmask 255.255.255.0配置的是子网掩码</span><br><span class="line">up表示立即生效</span><br></pre></td></tr></tbody></table></figure><p>一块网卡配置多个IP地址</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0:1 192.168.1.11 netmask 255.255.255.0 up</span><br><span class="line">ifconfig eth0:2 192.168.1.12 netmask 255.255.255.0 up</span><br></pre></td></tr></tbody></table></figure><p>临时方案配置的IP地址在重启后就会丢失</p><h4 id="2）永久方案——手动配置静态ip地址"><a href="#2）永久方案——手动配置静态ip地址" class="headerlink" title="2）永久方案——手动配置静态ip地址"></a>2）永久方案——手动配置静态ip地址</h4><p><strong>1))进入网络配置文件</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/sysconfig/network-scripts/</span><br></pre></td></tr></tbody></table></figure><p>每个网络接口都有对应的配置文件，虚拟机默认的网络接口是ens33，所以进入ifcfg-ens33编辑配置文件</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429171823614.png" alt="image-20240429171823614" style="zoom:67%;"></p><p><strong>2))进入ens33接口对应的配置文件</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ifcfg-ens33</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429171914778.png" alt="image-20240429171914778" style="zoom:50%;"></p><p><strong>3))修改配置文件</strong></p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429172048676.png" alt="image-20240429172048676" style="zoom:50%;"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO="static"    #static表示静态IP</span><br><span class="line">IPADDR=192.168.38.133 #配置IP地址</span><br><span class="line">NETMASK=255.255.255.e #配置掩码地址</span><br><span class="line">GATEWAY=192.168.38.2  #配置网关</span><br><span class="line">DNS1=8.8.8.8          #配置DNS服务器地址，8.8.8.8是谷歌免费的DNS服务器</span><br></pre></td></tr></tbody></table></figure><ul><li><p>配置ip地址：注意ip地址选择的时候，需要ping一下该地址，如果ping通了，说明有人正在使用，所以不能使用该ip地址</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429172550459.png" alt="image-20240429172550459" style="zoom:67%;"></p><p>子网ip显示192.168.249.0，那么可选的ip地址就是192.168.249.0到192.168.249.254</p></li><li><p>子网掩码：查询一下当前虚拟机的子网掩码，就使用这个子网掩码</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429172509305.png" alt="image-20240429172509305" style="zoom: 67%;"></p></li><li><p>网关：查看虚拟机的网络设置中的NAT设置的网关ip</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429172831789.png" alt="image-20240429172831789" style="zoom:80%;"></p></li><li><p>DNS文件就使用谷歌的免费服务器</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8</span><br><span class="line"></span><br><span class="line">国内可以使用14.14.14.14</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>4))最后重启网卡</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">立即生效需要重启网卡service network restart</span><br></pre></td></tr></tbody></table></figure><h2 id="6、查看端口是否空闲-lsof、ss、netstat"><a href="#6、查看端口是否空闲-lsof、ss、netstat" class="headerlink" title="6、查看端口是否空闲==lsof、ss、netstat=="></a>6、查看端口是否空闲==lsof、ss、netstat==</h2><h4 id="（1）端口的作用"><a href="#（1）端口的作用" class="headerlink" title="（1）端口的作用"></a>（1）端口的作用</h4><p>用于区分不同应用，每个应用都有自己的端口</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429173824101.png" alt="image-20240429173824101" style="zoom:50%;"></p><h4 id="（2）查看端口是否被占用-lsof、ss、netstat"><a href="#（2）查看端口是否被占用-lsof、ss、netstat" class="headerlink" title="（2）查看端口是否被占用==lsof、ss、netstat=="></a>（2）查看端口是否被占用==lsof、ss、netstat==</h4><h5 id="1-lsof命令"><a href="#1-lsof命令" class="headerlink" title="1))lsof命令"></a>1))lsof命令</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:端口号</span><br></pre></td></tr></tbody></table></figure><p>Nginx没有运行时，查看Nginx端口（默认是80），发现没有被占用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep ngix</span><br><span class="line">lsof -i:80</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429173538969.png" alt="image-20240429173538969" style="zoom:50%;"></p><p>提起Nginx：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/ local/nginx/sbin</span><br><span class="line">启动nginx</span><br><span class="line">./nginx</span><br></pre></td></tr></tbody></table></figure><p>Nginx运行时，查看Nginx端口，发现被占用(后来发现Nginx的端口被改了，是8099，所以此处查的是8099)</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429173711974.png" alt="image-20240429173711974" style="zoom:50%;"></p><p>释放端口，杀死相应的进程==kill==：</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429174027193.png" alt="image-20240429174027193" style="zoom:50%;"></p><h5 id="2-ss-tnl命令"><a href="#2-ss-tnl命令" class="headerlink" title="2))ss -tnl命令"></a>2))ss -tnl命令</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tnl | grep 8099</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240505211851066.png" alt="image-20240505211851066" style="zoom:50%;"></p><h5 id="3-netstat-tnl命令"><a href="#3-netstat-tnl命令" class="headerlink" title="3))netstat -tnl命令"></a>3))netstat -tnl命令</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnl | grep 8080</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240505211812945.png" alt="image-20240505211812945" style="zoom:50%;"></p><h1 id="二、工具"><a href="#二、工具" class="headerlink" title="二、工具"></a>二、工具</h1><h2 id="1、远程登录-ssh"><a href="#1、远程登录-ssh" class="headerlink" title="1、远程登录==ssh=="></a>1、远程登录==ssh==</h2><h3 id="（1）从win远程连接到Linux服务器"><a href="#（1）从win远程连接到Linux服务器" class="headerlink" title="（1）从win远程连接到Linux服务器"></a>（1）从win远程连接到Linux服务器</h3><p>Xshell、finalshell、Putty</p><h3 id="（2）从Linux主机远程连接到另一台Linux主机"><a href="#（2）从Linux主机远程连接到另一台Linux主机" class="headerlink" title="（2）从Linux主机远程连接到另一台Linux主机"></a>（2）从Linux主机远程连接到另一台Linux主机</h3><h4 id="1）远程登录的场景"><a href="#1）远程登录的场景" class="headerlink" title="1）远程登录的场景"></a>1）远程登录的场景</h4><ul><li><p>工作机器是Linux主机</p></li><li><p>远程Linux主机不能直接登录，比如在异地</p><p>例如：PC只能访问跳板机，要访问目标机器就需要通过远程连接</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240430095428497.png" alt="image-20240430095428497" style="zoom:50%;"></p></li></ul><h4 id="2）ssh-用户名-ip地址"><a href="#2）ssh-用户名-ip地址" class="headerlink" title="2）ssh 用户名@ip地址"></a>2）ssh 用户名@ip地址</h4><p>例如：从Linux主机(192.168.249.133)——》远程——》Linux主机(192.168.249.129)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.249.129</span><br><span class="line">输入root密码即可登录成功</span><br><span class="line"></span><br><span class="line">如果不想登录192.168.249.129的root用户，想登录mary用户</span><br><span class="line">ssh mary@192.168.249.129</span><br><span class="line">然后输入mary的密码即可</span><br></pre></td></tr></tbody></table></figure><p>输入129的root密码：</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240430094212154.png" alt="image-20240430094212154" style="zoom: 67%;"></p><p>查ip地址，远程登录成功：</p><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240430094330591.png" alt="image-20240430094330591"></p><p>断开远程连接：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240430094407995.png" alt="image-20240430094407995" style="zoom:67%;"></p><h2 id="2、远程文件传输-scp"><a href="#2、远程文件传输-scp" class="headerlink" title="2、远程文件传输==scp=="></a>2、远程文件传输==scp==</h2><h3 id="（1）windows主机-lt-———-gt-Linux主机"><a href="#（1）windows主机-lt-———-gt-Linux主机" class="headerlink" title="（1）windows主机<———>Linux主机"></a>（1）windows主机&lt;———&gt;Linux主机</h3><p>Xftp或者finalshell上传/下载文件</p><h3 id="（2）Linux主机-lt-———-gt-Linux主机"><a href="#（2）Linux主机-lt-———-gt-Linux主机" class="headerlink" title="（2）Linux主机<———>Linux主机"></a>（2）Linux主机&lt;———&gt;Linux主机</h3><p>例如：从Linux主机(192.168.249.133)&lt;———&gt;Linux主机(192.168.249.129)</p><h4 id="1）133（主机）将file-txt传给129（远程）（上传）"><a href="#1）133（主机）将file-txt传给129（远程）（上传）" class="headerlink" title="1）133（主机）将file.txt传给129（远程）（上传）"></a>1）133（主机）将file.txt传给129（远程）（上传）</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scp file.txt root@192.168.249.129:/home/test</span><br><span class="line">输入129root用户密码：</span><br><span class="line"></span><br><span class="line">1、root@192.168.249.129的意思是以root身份登录到129</span><br><span class="line">2、默认不指定文件名时，以原文件名传输</span><br><span class="line">如果要改文件名，就直接写在目录下即可</span><br><span class="line">例如：传输后改为file01.txt</span><br><span class="line">scp file.txt root@192.168.249.129:/home/test/file01.txt</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240430100141690.png" alt="image-20240430100141690" style="zoom:50%;"></p><h4 id="2）129（远程）将file-txt传给133（主机）（下载）"><a href="#2）129（远程）将file-txt传给133（主机）（下载）" class="headerlink" title="2）129（远程）将file.txt传给133（主机）（下载）"></a>2）129（远程）将file.txt传给133（主机）（下载）</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp root@192.168.249.129:/home/test ./file06_bck</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240430100604919.png" alt="image-20240430100604919" style="zoom:50%;"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、网络相关命令&quot;&gt;&lt;a href=&quot;#一、网络相关命令&quot; class=&quot;headerlink&quot; title=&quot;一、网络相关命令&quot;&gt;&lt;/a&gt;一、网络相关命令&lt;/h1&gt;&lt;h2 id=&quot;1、查看ip配置信息和网络情况：-ip、ifconfig、ping&quot;&gt;&lt;a href=&quot;#1、查看ip配置信息和网络情况：-ip、ifconfig、ping&quot; class=&quot;headerlink&quot; title=&quot;1、查看ip配置信息和网络情况：==ip、ifconfig、ping==&quot;&gt;&lt;/a&gt;1、查看ip配置信息和网络情况：==ip、ifconfig、ping==&lt;/h2&gt;&lt;h3 id=&quot;（1）ip&quot;&gt;&lt;a href=&quot;#（1）ip&quot; class=&quot;headerlink&quot; title=&quot;（1）ip&quot;&gt;&lt;/a&gt;（1）ip&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ip -4 addr：显示主机的IP v4地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip -6 addr：查看主机的IP v6地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ip addr：查看主机的所有IP地址&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;查看ip配置信息&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ip address&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;也可简写为ip a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240505203605412.png&quot; alt=&quot;image-20240505203605412&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;ens33是虚拟机默认的网络接口，所以后面跟的就是虚拟机的ip地址，24表示的是子网掩码，即255.255.255.0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429164741792.png&quot; alt=&quot;image-20240429164741792&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;（2）ifconfig（最常用）&quot;&gt;&lt;a href=&quot;#（2）ifconfig（最常用）&quot; class=&quot;headerlink&quot; title=&quot;（2）ifconfig（最常用）&quot;&gt;&lt;/a&gt;（2）ifconfig（最常用）&lt;/h3&gt;&lt;p&gt;ifconfig查看ip地址、子网掩码和收发包情况（比ip address看到的信息更多）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ifconfig eth0：查看指定网卡的IP地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ifconfig eth0 down：禁用eth0接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ifconfig eth0 up：启用eth0接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ifconfig -a：查看所有网卡的IP地址&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240505204146234.png&quot; alt=&quot;image-20240505204146234&quot; style=&quot;zoom: 50%;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;（3）ping&quot;&gt;&lt;a href=&quot;#（3）ping&quot; class=&quot;headerlink&quot; title=&quot;（3）ping&quot;&gt;&lt;/a&gt;（3）ping&lt;/h3&gt;&lt;p&gt;用于检查网络是否联通，ping得快说明网速好&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ping www.baidu.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ping -c 5 www.baidu.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设置发5个包&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ping成功后，默认一直ping直到ctrl C 结束&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ping www.baidu.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl+C&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429165344925.png&quot; alt=&quot;image-20240429165344925&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以通过参数-c设置ping包的数目&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ping -c 5 www.baidu.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设置发5个包&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429165559223.png&quot; alt=&quot;image-20240429165559223&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Windows默认ping4个包就结束，不用CtrlC手动终止&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/29/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B7%A5%E5%85%B7/image-20240429165516006.png&quot; alt=&quot;image-20240429165516006&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Linux" scheme="https://laylaycjl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>进程与定时任务</title>
    <link href="https://laylaycjl.github.io/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>https://laylaycjl.github.io/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</id>
    <published>2024-04-29T07:22:29.000Z</published>
    <updated>2024-05-05T08:42:36.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h1><h2 id="1、进程的基本概念"><a href="#1、进程的基本概念" class="headerlink" title="1、进程的基本概念"></a>1、进程的基本概念</h2><p><strong>程序</strong>：程序（软件）用代码决定程序的行为，存在存储介质里，比如硬盘</p><p><strong>进程</strong>：程序运行起来，就是操作系统把存储介质上的可执行文件加载到内存里面运行，这个运行的程序叫做进程</p><ul><li>程序是<strong>静态的文件</strong>，进程是程序的<strong>一次执行过程</strong>，进程是动态的。</li></ul><h2 id="2、查看进程的命令ps"><a href="#2、查看进程的命令ps" class="headerlink" title="2、查看进程的命令ps"></a>2、查看进程的命令ps</h2><h3 id="（1）查看当前终端的当前用户的所有进程"><a href="#（1）查看当前终端的当前用户的所有进程" class="headerlink" title="（1）查看当前终端的当前用户的所有进程"></a>（1）查看当前终端的当前用户的所有进程</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps</span><br><span class="line">不带参数</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429153931760.png" alt="image-20240429153931760" style="zoom:50%;"></p><h3 id="（2）查看所有进程-ef"><a href="#（2）查看所有进程-ef" class="headerlink" title="（2）查看所有进程==-ef=="></a>（2）查看所有进程==-ef==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">e表示所有，f表示full-format，尤其是PPID和command内容</span><br><span class="line"></span><br><span class="line">经常和管道符连用</span><br><span class="line">ps -ef | grep java</span><br></pre></td></tr></tbody></table></figure><p><code>-ef</code> 参数最常用的操作是查看某个服务的进程：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep 服务名</span><br><span class="line">服务名: tomcat、nginx、redis、java、mysal</span><br></pre></td></tr></tbody></table></figure><p><code>-ef</code> 查询结果含义：</p><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429153313142.png" alt="image-20240429153313142" style="zoom:50%;"></p><ul><li><p>子进程和父进程：</p><ul><li><p>在root下切换为jack用户，然后再jack进程下执行bash，那么root用户su切换为jack用户这个进程是jack的bash进程的父进程</p><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429153547534.png" alt="image-20240429153547534" style="zoom:50%;"></p><p><strong>当父进程结束时，子进程也会结束</strong></p></li></ul></li></ul><span id="more"></span><h3 id="（3）显示CPU和内存占用情况以及进程状态-axu"><a href="#（3）显示CPU和内存占用情况以及进程状态-axu" class="headerlink" title="（3）显示CPU和内存占用情况以及进程状态==-axu=="></a>（3）显示CPU和内存占用情况以及进程状态==-axu==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -axu</span><br><span class="line">-axu参数：ax表示所有，u表示user-oriented</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429154319786.png" alt="image-20240429154319786" style="zoom:50%;"></p><h2 id="3、前、后台运行进程"><a href="#3、前、后台运行进程" class="headerlink" title="3、前、后台运行进程"></a>3、前、后台运行进程</h2><h3 id="（1）前后台进程概念"><a href="#（1）前后台进程概念" class="headerlink" title="（1）前后台进程概念"></a>（1）前后台进程概念</h3><h4 id="1）前台进程"><a href="#1）前台进程" class="headerlink" title="1）前台进程"></a>1）前台进程</h4><ul><li>Shell里正在执行的和用户进行交互的进程叫前台进程</li><li>举例ps，ls都是前台进程，时间短</li></ul><p>写一个运行时间很长的程序：</p><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429155555790.png" alt="image-20240429155555790" style="zoom:50%;"></p><p>运行之后窗口会被占用，只能强制退出</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.sh（此命令无法执行的话，看看是不是没权限）</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429155827917.png" alt="image-20240429155827917" style="zoom:50%;"></p><h4 id="2）后台进程（-在命令后加-amp-在后台执行-）"><a href="#2）后台进程（-在命令后加-amp-在后台执行-）" class="headerlink" title="2）后台进程（==在命令后加&amp;在后台执行==）"></a>2）后台进程（==在命令后加&amp;在后台执行==）</h4><ul><li><p>有的命令执行时间长，比如备份程序</p></li><li><p>可以在命令后加&amp;在后台执行</p><p>实例bash test.sh&amp;</p></li><li><p>后台运行，意味着不从标准输入读入字符</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.sh&amp;</span><br></pre></td></tr></tbody></table></figure><p>同样是上面的程序，命令它在后台执行，这样窗口就不会被占用：</p><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429155734396.png" alt="image-20240429155734396" style="zoom:50%;"></p><h3 id="（2）进程前、后台切换-fg-bg-，查看在后台运行的进程-jobs"><a href="#（2）进程前、后台切换-fg-bg-，查看在后台运行的进程-jobs" class="headerlink" title="（2）进程前、后台切换==fg\bg==，查看在后台运行的进程==jobs=="></a>（2）进程前、后台切换==fg\bg==，查看在后台运行的进程==jobs==</h3><h4 id="1）后台进程——-gt-前台-fg"><a href="#1）后台进程——-gt-前台-fg" class="headerlink" title="1）后台进程——>前台==fg=="></a>1）后台进程——&gt;前台==fg==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fg &lt;num&gt;将后台进程调到前台，比如fg 1</span><br><span class="line"></span><br><span class="line">fg 1</span><br><span class="line">f：front前台</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429160015162.png" alt="image-20240429160015162" style="zoom:50%;"></p><h4 id="2）前台进程——-gt-后台-bg"><a href="#2）前台进程——-gt-后台-bg" class="headerlink" title="2）前台进程——>后台==bg=="></a>2）前台进程——&gt;后台==bg==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bg &lt;num&gt;可将进程在后台运行，比如在执行Ctrl+Z挂起进程后，再用命令bg 1让进程在后台继续执行</span><br><span class="line"></span><br><span class="line">ctrl Z将进程挂起,注意jobs显示的状态是stopped</span><br><span class="line">bg 1 切换到后台</span><br><span class="line">b：back后台</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429160236129.png" alt="image-20240429160236129" style="zoom:50%;"></p><h4 id="3）查看在后台运行的进程-jobs"><a href="#3）查看在后台运行的进程-jobs" class="headerlink" title="3）查看在后台运行的进程==jobs=="></a>3）查看在后台运行的进程==jobs==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列出后台进程命令jobs</span><br></pre></td></tr></tbody></table></figure><p>无后台进程：</p><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429160715405.png" alt="image-20240429160715405" style="zoom:50%;"></p><h2 id="4、如何终止进程-kill"><a href="#4、如何终止进程-kill" class="headerlink" title="4、如何终止进程==kill=="></a>4、如何终止进程==kill==</h2><h4 id="1）自行终止"><a href="#1）自行终止" class="headerlink" title="1）自行终止"></a>1）自行终止</h4><ul><li><p>任务执行完成，比如ps</p></li><li><p>用户让其退出，比如vi，exit</p></li><li><p>异常退出，比如程序里有以0的代码</p></li></ul><h4 id="2）用户手动杀死进程"><a href="#2）用户手动杀死进程" class="headerlink" title="2）用户手动杀死进程"></a>2）用户手动杀死进程</h4><p>==只能是owner和root才能杀死进程==</p><p>比如3496是root的进程，mary用户无法终止该进程</p><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429161023416.png" alt="image-20240429161023416" style="zoom:50%;"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill PID #杀死进程</span><br></pre></td></tr></tbody></table></figure><p>例如：</p><p>用户正在使用进程，无法删掉用户时</p><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429161140147.png" alt="image-20240429161140147" style="zoom:50%;"></p><p>可以kill进程，再删除用户</p><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429161239449.png" alt="image-20240429161239449" style="zoom:50%;"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 PID #强制杀死进程</span><br></pre></td></tr></tbody></table></figure><blockquote><p>kill和kill -9，两个命令在linux中都有杀死进程的效果，然而两命令的执行过程却大有不同，在程序中如果用错了，可能会造成莫名其妙的现象。</p><ul><li><p>执行kill命令，系统会发送一个SIGTERM信号给对应的程序。当程序接收到该signal信号后，将会发生以下事情：</p><ul><li><p>程序立刻停止</p></li><li><p>当程序释放相应资源后再停止</p></li><li><p>程序可能仍然继续运行</p></li></ul><p>大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后再停止。</p><p>但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应，我在使用wkhtmltopdf转pdf的项目中遇到这现象），也就是说，SIGTERM多半是会被阻塞的。</p></li><li><p>然而kill -9命令，系统给对应程序发送的信号是SIGKILL，即exit。exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程。</p></li></ul></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + C 终止执行</span><br></pre></td></tr></tbody></table></figure><h1 id="二、定时任务-crontab"><a href="#二、定时任务-crontab" class="headerlink" title="二、定时任务==crontab=="></a>二、定时任务==crontab==</h1><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><h4 id="（1）定时任务适用场景"><a href="#（1）定时任务适用场景" class="headerlink" title="（1）定时任务适用场景"></a>（1）定时任务适用场景</h4><ul><li>定期清除Linux日志文件</li><li>定期备份Linux重要文件</li></ul><h4 id="（2）工作原理"><a href="#（2）工作原理" class="headerlink" title="（2）工作原理"></a>（2）工作原理</h4><p>当用户使用crontab这个命令来新建工作调度之后，该项工作会被记录到/var/spool/cron里面，而且以账号来作为判断。</p><ul><li>举例来说，root使用crontab后，他的工作会被记录到/var/spool/cron/root里面去</li><li>注意不要用vi直接编辑该文件，因为可能由于输入语法错误，会导致无法执行cron</li></ul><h4 id="（3）日志"><a href="#（3）日志" class="headerlink" title="（3）日志"></a>（3）日志</h4><p>cron执行的每一项工作都会被记录到/var/log/cron这个日志中，所以如果你的Linux不知道是否被植入木马时，也可以查询一项/var/log/cron这个日志文件</p><p>例如：设置打印hello world到屏幕的指令，到指定时间后没有打印到屏幕，去查看日志文件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log cron</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240430104020588.png" alt="image-20240430104020588" style="zoom:50%;"></p><p>发现已经执行，但没有打印</p><p>是因为crontab只会在后台运行，所有不会打印到屏幕</p><h3 id="2、crontab格式"><a href="#2、crontab格式" class="headerlink" title="2、crontab格式"></a>2、crontab格式</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crontab ***** command</span><br><span class="line">*分钟</span><br><span class="line">*小时</span><br><span class="line">*几号</span><br><span class="line">*几月</span><br><span class="line">*周几</span><br></pre></td></tr></tbody></table></figure><p>crontab格式说明：总共6个字段，前5个表示时间，最后一个表示要执行的操作</p><p><img src="/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240430101423743.png" alt="image-20240430101423743" style="zoom:67%;"></p><p>（0和7都表示星期天）</p><div class="table-container"><table><thead><tr><th><strong>特殊字符</strong></th><th><strong>代表意义</strong></th></tr></thead><tbody><tr><td>星号(*)</td><td>代表任何时刻都接受的意思，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作</td></tr><tr><td>逗号(,)</td><td>可以用逗号隔开的值指定一个不连续的范围，例如，周二和周四“2,4”</td></tr><tr><td>减号(-)</td><td>可以用整数之间的减号表示一个连续的范围，例如“2-6”表示“2,3,4,5,6”</td></tr><tr><td>正斜线(/)</td><td>可以用正斜线指定时间的间隔频率，例如“6-22/2”表示从6点到22点期间，每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</td></tr></tbody></table></div><h3 id="3、crontab语法"><a href="#3、crontab语法" class="headerlink" title="3、crontab语法"></a>3、crontab语法</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">crontab [-u] [-l | -r | -e]</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-u：user只有root用户才能进行这个任务，也即帮助其他用户创建/删除crontab工作调度</span><br><span class="line">-l：list查看crontab工作内容</span><br><span class="line">-r：remove删除所有的crontab的工作内容，若仅要删除一项，请用-e编辑</span><br><span class="line">-e：edit编辑crontab的工作内容</span><br></pre></td></tr></tbody></table></figure><p>==只有root用户才能进行这个任务，不加-user默认root用户，加-user操作该用户的定时任务==</p><h4 id="（1）查看定时任务-l"><a href="#（1）查看定时任务-l" class="headerlink" title="（1）查看定时任务==-l=="></a>（1）查看定时任务==-l==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -zhangsan -l</span><br></pre></td></tr></tbody></table></figure><h4 id="（2）编辑定时任务-e"><a href="#（2）编辑定时任务-e" class="headerlink" title="（2）编辑定时任务==-e=="></a>（2）编辑定时任务==-e==</h4><h5 id="1）进入编辑模式"><a href="#1）进入编辑模式" class="headerlink" title="1）进入编辑模式"></a>1）进入编辑模式</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -zhangsan -e</span><br></pre></td></tr></tbody></table></figure><h5 id="2）例子"><a href="#2）例子" class="headerlink" title="2）例子"></a>2）例子</h5><ul><li>设置每周六晚上21:00-23:00，每隔半小时执行/home/test/test.sh</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*/30 21-23 * * 6 ./home/test.sh</span><br><span class="line">*/30每三十分钟执行一次</span><br><span class="line">21-23从21:00到23:00</span><br><span class="line">*每天</span><br><span class="line">*每个月</span><br><span class="line">6每个星期六</span><br></pre></td></tr></tbody></table></figure><ul><li>每个月15号，12:30发工资</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">30 12 15 * * echo "发工资" &gt;&gt; /home/test/wage.log</span><br><span class="line">30分</span><br><span class="line">12点</span><br><span class="line">15号</span><br><span class="line">每月</span><br><span class="line">每个星期</span><br></pre></td></tr></tbody></table></figure><h4 id="（3）删除定时任务-r"><a href="#（3）删除定时任务-r" class="headerlink" title="（3）删除定时任务==-r=="></a>（3）删除定时任务==-r==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -zhangsan -r</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、进程&quot;&gt;&lt;a href=&quot;#一、进程&quot; class=&quot;headerlink&quot; title=&quot;一、进程&quot;&gt;&lt;/a&gt;一、进程&lt;/h1&gt;&lt;h2 id=&quot;1、进程的基本概念&quot;&gt;&lt;a href=&quot;#1、进程的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1、进程的基本概念&quot;&gt;&lt;/a&gt;1、进程的基本概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;：程序（软件）用代码决定程序的行为，存在存储介质里，比如硬盘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;：程序运行起来，就是操作系统把存储介质上的可执行文件加载到内存里面运行，这个运行的程序叫做进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序是&lt;strong&gt;静态的文件&lt;/strong&gt;，进程是程序的&lt;strong&gt;一次执行过程&lt;/strong&gt;，进程是动态的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2、查看进程的命令ps&quot;&gt;&lt;a href=&quot;#2、查看进程的命令ps&quot; class=&quot;headerlink&quot; title=&quot;2、查看进程的命令ps&quot;&gt;&lt;/a&gt;2、查看进程的命令ps&lt;/h2&gt;&lt;h3 id=&quot;（1）查看当前终端的当前用户的所有进程&quot;&gt;&lt;a href=&quot;#（1）查看当前终端的当前用户的所有进程&quot; class=&quot;headerlink&quot; title=&quot;（1）查看当前终端的当前用户的所有进程&quot;&gt;&lt;/a&gt;（1）查看当前终端的当前用户的所有进程&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;不带参数&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429153931760.png&quot; alt=&quot;image-20240429153931760&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;（2）查看所有进程-ef&quot;&gt;&lt;a href=&quot;#（2）查看所有进程-ef&quot; class=&quot;headerlink&quot; title=&quot;（2）查看所有进程==-ef==&quot;&gt;&lt;/a&gt;（2）查看所有进程==-ef==&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ps -ef&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e表示所有，f表示full-format，尤其是PPID和command内容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;经常和管道符连用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ps -ef | grep java&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;-ef&lt;/code&gt; 参数最常用的操作是查看某个服务的进程：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ps -ef | grep 服务名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;服务名: tomcat、nginx、redis、java、mysal&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;-ef&lt;/code&gt; 查询结果含义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429153313142.png&quot; alt=&quot;image-20240429153313142&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;子进程和父进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在root下切换为jack用户，然后再jack进程下执行bash，那么root用户su切换为jack用户这个进程是jack的bash进程的父进程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/image-20240429153547534.png&quot; alt=&quot;image-20240429153547534&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当父进程结束时，子进程也会结束&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Linux" scheme="https://laylaycjl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>压缩、打包与软件安装</title>
    <link href="https://laylaycjl.github.io/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>https://laylaycjl.github.io/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</id>
    <published>2024-04-29T02:02:45.000Z</published>
    <updated>2024-05-05T08:29:59.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、压缩与打包"><a href="#一、压缩与打包" class="headerlink" title="一、压缩与打包"></a>一、压缩与打包</h1><h2 id="0、打包和压缩的区别："><a href="#0、打包和压缩的区别：" class="headerlink" title="0、打包和压缩的区别："></a>0、打包和压缩的区别：</h2><ul><li>打包是指把文件和目录的结构和内容==拷贝==到一个文件里</li><li>压缩是把文件经过一些算法变成体积上更小的文件</li></ul><p>以WinRAR为例，一般是既打包也压缩，也可以不压缩，只打包</p><h2 id="1、压缩命令-gzip-、查看压缩内容-zcat"><a href="#1、压缩命令-gzip-、查看压缩内容-zcat" class="headerlink" title="1、压缩命令==gzip==、查看压缩内容==zcat=="></a>1、压缩命令==gzip==、查看压缩内容==zcat==</h2><h3 id="（1）gzip压缩"><a href="#（1）gzip压缩" class="headerlink" title="（1）gzip压缩"></a>（1）gzip压缩</h3><p>1）gzip命令，压缩一个或多个文件，==压缩成分别的压缩文件，不能对整个目录压缩，但可以通过-r参数分别压缩目录下的文件==</p><p>2）压缩完原文件不在，变为.gz文件</p><p>3）格式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">压缩格式：</span><br><span class="line">gzip 文件名；(压缩完成后，原来的文件会被替换成&lt;name&gt;.gz，原文件消失)</span><br></pre></td></tr></tbody></table></figure><p>例如：</p><ul><li><p>压缩scp.log文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip scp.out</span><br></pre></td></tr></tbody></table></figure><p>原始文件大小为129</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429190259032.png" alt="image-20240429190259032" style="zoom:50%;"></p><p>对其进行压缩，压缩后变为 <code>.gz</code> 文件，大小变为112：</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429190414673.png" alt="image-20240429190414673" style="zoom:50%;"></p></li><li><p>压缩test目录</p><p><strong>无法压缩目录本身，但是可以-r压缩子文件</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip -r /home/test</span><br><span class="line">-r：递归压缩，压缩其子文件</span><br></pre></td></tr></tbody></table></figure><p>执行命令后，会将test目录下的每个文件进行分别压缩，如图压缩前是<code>catalina.out</code>和<code>locahost.2024-04-29.log</code>文件，压缩后分别变成压缩包</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429101324023.png" alt="image-20240429101324023" style="zoom:50%;"></p><span id="more"></span></li></ul><h3 id="（2）解压缩-d"><a href="#（2）解压缩-d" class="headerlink" title="（2）解压缩==-d=="></a>（2）解压缩==-d==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解压缩文件：</span><br><span class="line">gzip -d &lt;filename&gt;.gz；</span><br><span class="line"></span><br><span class="line">解压目录下所有文件：</span><br><span class="line">gzip -d -r dirname</span><br></pre></td></tr></tbody></table></figure><ul><li><p>解压某个文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d scp.log.gz</span><br></pre></td></tr></tbody></table></figure><p>解压缩scp.log.gz文件后，该压缩包会消失</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429191609292.png" alt="image-20240429191609292" style="zoom:50%;"></p></li><li><p>解压某个目录及其子目录</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip -d -r test</span><br><span class="line">-r：递归解压</span><br></pre></td></tr></tbody></table></figure><p>解压缩后该压缩包会消失</p></li></ul><h3 id="（3）查看压缩内容zcat"><a href="#（3）查看压缩内容zcat" class="headerlink" title="（3）查看压缩内容zcat"></a>（3）查看压缩内容zcat</h3><p>查看某个压缩包的内容：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat scp.log.gz</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429192212729.png" alt="image-20240429192212729" style="zoom:50%;"></p><h2 id="2、压缩命令-bzip2"><a href="#2、压缩命令-bzip2" class="headerlink" title="2、压缩命令==bzip2=="></a>2、压缩命令==bzip2==</h2><h3 id="（1）-bzip2-压缩"><a href="#（1）-bzip2-压缩" class="headerlink" title="（1）==bzip2==压缩"></a>（1）==bzip2==压缩</h3><p>1）bzip2的压缩比gzip更好，其用法几乎与gzip相同</p><p>同样一个文件压缩，bzip2可以压缩得更小</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429112816246.png" alt="image-20240429112816246" style="zoom:50%;"></p><p>2）==不能对整个目录压缩，但可以分别压缩目录下的文件==</p><p>3）压缩完原文件不在，变为.bz2文件</p><p>4）格式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">压缩文件：</span><br><span class="line">bzip2 文件名(压缩完成后，原来的文件会被替换成&lt;name&gt;.bz2)</span><br><span class="line"></span><br><span class="line">压缩目录下的每个文件：</span><br><span class="line">bzip2 dir01/*</span><br></pre></td></tr></tbody></table></figure><ul><li><p>压缩catalina.out文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 catalina.out</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429101913550.png" alt="image-20240429101913550" style="zoom:50%;"></p><p>压缩后变为<code>.bz2</code> 格式，原文件消失</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429101950878.png" alt="image-20240429101950878" style="zoom:50%;"></p></li><li><p>压缩test目录</p><p><strong>不能对目录本身进行压缩，但是可以压缩其子文件</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 /home/test/*</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="（2）解压缩-d-1"><a href="#（2）解压缩-d-1" class="headerlink" title="（2）解压缩==-d=="></a>（2）解压缩==-d==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解压缩文件：</span><br><span class="line">bzip2 -d &lt;name&gt;.bz2(解压缩后，压缩包会消失)</span><br></pre></td></tr></tbody></table></figure><ul><li><p>解压catalina.out.bz2文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -d catalina.bz2</span><br></pre></td></tr></tbody></table></figure></li><li><p>解压test目录</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -d /home/test/*</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="3、压缩命令-zip-，查看-zipinfo-，解压-unzip"><a href="#3、压缩命令-zip-，查看-zipinfo-，解压-unzip" class="headerlink" title="3、压缩命令==zip==，查看==zipinfo==，解压==unzip=="></a>3、压缩命令==zip==，查看==zipinfo==，解压==unzip==</h2><h3 id="（1）压缩命令-zip"><a href="#（1）压缩命令-zip" class="headerlink" title="（1）压缩命令==zip=="></a>（1）压缩命令==zip==</h3><p>1）Linux上zip==可以压缩一个或多个文件到一个压缩文件==里</p><p>2）格式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">把file01、dir01压缩到文件zipfile.zip里</span><br><span class="line">zip zipfile.zip file01 dir01</span><br><span class="line"></span><br><span class="line">1、zip zipfile.zip file01 dir01，表示把file01、dir01压缩到文zipfile.zip里</span><br><span class="line">2、zip -r root.zip /root，表示将root目录及其子目录子文件进行压缩</span><br><span class="line">3、zip root.zip /root，如果不加r，不会包含文件，只有目录，不对目录下的子文件和子目录进行压缩</span><br><span class="line">4、zip xxx.zip .*，表示将当前目录下的内容压缩到xxx.zip中,不包含这个目录本身</span><br><span class="line">5、zip -r xxx.zip ./* ,表示将当前目录下的内容，包括目录全部压缩</span><br></pre></td></tr></tbody></table></figure><p>3）例子</p><ul><li><p>对<code>ronghuadb.sql文件</code> <code>localhost.2024-03-04.log文件</code> <code>test目录</code>进行压缩，压缩为<code>rh.zip</code>包</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip rh.zip ronghuadb.sql localhost.2023-03-04.log test</span><br></pre></td></tr></tbody></table></figure><p>注意：此时压缩test目录时，==没有加<code>-r</code>参数，<strong>只压缩空目录</strong>==</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429104323099.png" alt="image-20240429104323099" style="zoom: 50%;"></p></li><li><p><strong>对目录进行压缩，要加参数<code>-r</code></strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r rh.zip ronghuadb.sql localhost.2023-03-04.log test</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429103153488.png" alt="image-20240429103153488" style="zoom:50%;"></p></li><li><p><strong>不压缩目录，只压缩test目录下的子文件和子目录进行压缩</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip test.zip test/*</span><br></pre></td></tr></tbody></table></figure><p>文件结构如下：</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429110644313.png" alt="image-20240429110644313" style="zoom:50%;"></p><p>压缩结果：</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429110815424.png" alt="image-20240429110815424" style="zoom:50%;"></p></li><li><p>压缩目录及目录下的子文件和子目录</p><p>需要加参数-r</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r test.zip test/*</span><br></pre></td></tr></tbody></table></figure></li></ul><p>  <img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429110950952.png" alt="image-20240429110950952" style="zoom:50%;"></p><h3 id="（2）查看压缩包-zipinfo"><a href="#（2）查看压缩包-zipinfo" class="headerlink" title="（2）查看压缩包==zipinfo=="></a>（2）查看压缩包==zipinfo==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zipinfo xxx.zip</span><br></pre></td></tr></tbody></table></figure><p>例如：查看test.zip压缩包</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429111157882.png" alt="image-20240429111157882" style="zoom:50%;"></p><h3 id="（3）解压缩-unzip"><a href="#（3）解压缩-unzip" class="headerlink" title="（3）解压缩==unzip=="></a>（3）解压缩==unzip==</h3><p>解压格式：解压缩后压缩包并不会消失</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip zipfile.zip</span><br></pre></td></tr></tbody></table></figure><h2 id="4、打包压缩命令tar（重点）"><a href="#4、打包压缩命令tar（重点）" class="headerlink" title="4、打包压缩命令tar（重点）"></a>4、打包压缩命令tar（重点）</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tar的常用参数：</span><br><span class="line">-c：create 新建打包文件，可搭配-v来查看过程中被打包的文件名；</span><br><span class="line">-t：list查看打包文件的内容包含哪些文件名重点,查看文件名；</span><br><span class="line">-x：extract解打包或解压缩的功能，可以搭配-C（大写）在特定目录解开；</span><br><span class="line"></span><br><span class="line">特别留意的是，-c，-t，-x不可同时出现在一串命令行中；</span><br><span class="line"></span><br><span class="line">-z：通过gzip的支持进行压缩/解压缩，此时文件名最好为*.tar.gz</span><br><span class="line">-j：通过bzip2的支持进行压缩/解压缩，此时文件名最好为*.tar.bz2</span><br><span class="line"></span><br><span class="line">-v：verbose可视化，在压缩/解压缩的过程中，将正在处理的文件名显示出来</span><br><span class="line"></span><br><span class="line">-f filename： -f后面要接被处理的文件名。建议 -f 单独写一个参数</span><br><span class="line"></span><br><span class="line">-C directory目录:这个参数用在解压缩是，若要在特定目录解压缩，可以使用这个参数</span><br></pre></td></tr></tbody></table></figure><h3 id="（1）打包、打包压缩-c"><a href="#（1）打包、打包压缩-c" class="headerlink" title="（1）打包、打包压缩==-c=="></a>（1）打包、打包压缩==-c==</h3><p>1）tar命令是先打包再压缩，tar可以将多个目录或文件打包成一个大文件，同时还可以通过gzip/bzip2对文件进行压缩；</p><p>2）由于tar的使用太广泛，目前Windows的WinRAR也支持.tar.gz文件的解压缩；</p><p>3）打包压缩格式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">tar -参数 打包成功后放在哪里以及包名 文件1 文件2 目录</span><br><span class="line">eg.压缩组合</span><br><span class="line"></span><br><span class="line">只打包，不压缩：</span><br><span class="line">tar -cvf test file1 file2 </span><br><span class="line">打包，并以gzip的方式压缩</span><br><span class="line">tar -zcvf test file01 dir01</span><br><span class="line">打包，并以bzip2的方式压缩：</span><br><span class="line">tar -jcvf test file</span><br></pre></td></tr></tbody></table></figure><p>举例：</p><ul><li><p>-c创建打包，用gzip压缩，-v表示可视化，-f打包后命名为test.tar.gz，把<code>localhost.2024-03-04.log文件</code>，<code>crashcourse.sql文件</code> ，<code>test目录</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf test.tar.gz localhost.2024-03-04.log crashcourse.sql test</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429112612507.png" alt="image-20240429112612507" style="zoom:50%;"></p><p>生成一个.gz压缩包</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429112946141.png" alt="image-20240429112946141" style="zoom:50%;"></p></li><li><p>-f必须在参数最后面，因为f参数后面必须跟文件名</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429113813934.png" alt="image-20240429113813934" style="zoom:50%;"></p></li></ul><h3 id="（2）解压缩-x"><a href="#（2）解压缩-x" class="headerlink" title="（2）解压缩==-x=="></a>（2）解压缩==-x==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar 参数 要解压的包 -C 解压到的目录</span><br><span class="line">默认解压到当前目录下：</span><br><span class="line">tar -zxvf xxx.tar.gz(以gzip方式解压缩)</span><br><span class="line">tar -jxvf xxx.tar.bz2(以bzip2方式解压缩)</span><br><span class="line"></span><br><span class="line">解压到指定目录下：</span><br><span class="line">tar -zxvf xxx.tar.gz -C /home/test(以gzip方式解压缩)</span><br><span class="line">tar -jxvf xxx.tar.bz2 -C /home/test(以bzip2方式解压缩)</span><br></pre></td></tr></tbody></table></figure><p>举例：</p><ul><li><p>解压时，默认解压到当前目录下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf test60.tar.gz</span><br></pre></td></tr></tbody></table></figure></li></ul><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429114010329.png" alt="image-20240429114010329" style="zoom:50%;"></p><ul><li><p>解压到指定目录</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf test60.tar.gz -C /home/test</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429114322102.png" alt="image-20240429114322102" style="zoom:50%;"></p></li></ul><h3 id="（3）查看打包内容-t"><a href="#（3）查看打包内容-t" class="headerlink" title="（3）查看打包内容==-t=="></a>（3）查看打包内容==-t==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查看打包内容</span><br><span class="line">tar -ztf test60.tar.gz(gzip格式)</span><br><span class="line">tar -jtf test60.tar.bz2(bzip格式)</span><br><span class="line"></span><br><span class="line">查看打包内容，并展示详细信息</span><br><span class="line">tar -ztvf test60.tar.gz(gzip格式)</span><br><span class="line">tar -jtvf test60.tar.bz2(bzip格式)</span><br></pre></td></tr></tbody></table></figure><ul><li><p>查看打包内容</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztf test60.tar.gz</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429114528812.png" alt="image-20240429114528812" style="zoom:50%;"></p></li><li><p>查看打包内容，并展示详细信息</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztvf test60.tar.gz</span><br></pre></td></tr></tbody></table></figure></li></ul><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429114619426.png" alt="image-20240429114619426" style="zoom:50%;"></p><h1 id="二、常用的安装软件的方式"><a href="#二、常用的安装软件的方式" class="headerlink" title="二、常用的安装软件的方式"></a>二、常用的安装软件的方式</h1><h2 id="1、源码包安装方式"><a href="#1、源码包安装方式" class="headerlink" title="1、源码包安装方式"></a>1、源码包安装方式</h2><h3 id="（1）源码包安装简介"><a href="#（1）源码包安装简介" class="headerlink" title="（1）源码包安装简介"></a>（1）源码包安装简介</h3><ul><li>Linux上的软件几乎都是经过GPL（GNU General Public License）授权，所以每个软件几乎都会提供源代码，并且你可以自行修改程序代码，以符合你个人的需求，这就是开放源码的优势；</li><li>源代码Linux无法识别，Linux系统上真正识别的可执行文件是二进制文件，比如/bin/cat二进制程序代码，所以是无法直接运行的，需要编译</li><li>通过源码包安装软件的过程就是把软件的源代码<strong>编译</strong>成可执行的二进制文件然后进行安装；</li></ul><h3 id="（2）通过源码包安装的步骤"><a href="#（2）通过源码包安装的步骤" class="headerlink" title="（2）通过源码包安装的步骤"></a>（2）通过源码包安装的步骤</h3><p>安装工具 —&gt; 配置 —&gt; 编译 —&gt; 安装</p><ul><li>1.安装需要的编译器，如<code>gcc</code>；</li><li>2.执行<code>configure命令</code>找到所需要的<strong>函数库</strong>、<strong>编译器</strong>及<strong>其他资料</strong>，生成<strong>Makefile文件</strong>；</li><li>3.执行<code>make命令</code>，根据Makefile文件进行编译；</li><li>4.执行<code>make install</code>命令完成安装。</li></ul><p>举例，以源码方式安装nginx：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、安装编译器gcc：</span><br><span class="line">yum -y install gcc-c++ pcre* openssl*</span><br><span class="line"></span><br><span class="line">2、下载源码包</span><br><span class="line">cd /usr/local/src/（进入该目录下，因为安装包都放在该目录下）</span><br><span class="line">wget http://nginx.org/download/nginx-1.14.0.tar.gz（通过wget工具下载源码包）</span><br><span class="line"></span><br><span class="line">3、解压源码包到指定目录</span><br><span class="line">tar -zxvf nginx-1.14.0.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line">4、配置源码</span><br><span class="line">cd /usr/local/nginx-1.14.0</span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line"></span><br><span class="line">5、编译并完成安装</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure><h3 id="（3）源码包安装的优缺点"><a href="#（3）源码包安装的优缺点" class="headerlink" title="（3）源码包安装的优缺点"></a>（3）源码包安装的优缺点</h3><p>优点：获取到的是源代码，可以根据需求修改源代码</p><p>缺点：安装过程复杂，需要安装工具gcc，还需要config配置，make编译，最后 才能安装，四个步骤中出现问题还需要自己解决</p><h2 id="2、RPM"><a href="#2、RPM" class="headerlink" title="2、RPM"></a>2、RPM</h2><h3 id="（1）RPM安装简介"><a href="#（1）RPM安装简介" class="headerlink" title="（1）RPM安装简介"></a>（1）RPM安装简介</h3><ul><li>RPM的全称是RedHat Package Manager，是RedHat发明的一种软件包安装工具和安装包格式；</li><li>RPM的最大特点是将你要安装的软件先编译好，并且打包成RPM机制的安装包，用户只需要下载相应的RPM包安装即可；</li></ul><h3 id="（2）RPM安装步骤"><a href="#（2）RPM安装步骤" class="headerlink" title="（2）RPM安装步骤"></a>（2）RPM安装步骤</h3><h4 id="1）下载所需软件的RPM包-wget"><a href="#1）下载所需软件的RPM包-wget" class="headerlink" title="1）下载所需软件的RPM包==wget=="></a>1）下载所需软件的RPM包==wget==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.rpmfind.net/linux/centos/6.9/os/x86_64/Packages/unix2dos-2.2-35.el6.x86_64.rpm</span><br></pre></td></tr></tbody></table></figure><h4 id="2）安装-rpm-ivh"><a href="#2）安装-rpm-ivh" class="headerlink" title="2）安装==rpm -ivh=="></a>2）安装==rpm -ivh==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh unix2dos-2.2-35.el6.x86_64.rpm</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">-i install安装</span><br><span class="line">-v verbose打印安装过程中的信息</span><br><span class="line">-h hash哈希，套件安装时列出标记</span><br></pre></td></tr></tbody></table></figure><h4 id="3）查看已安装的软件-rpm-qa"><a href="#3）查看已安装的软件-rpm-qa" class="headerlink" title="3）查看已安装的软件==rpm -qa=="></a>3）查看已安装的软件==rpm -qa==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查询所有已安装的软件</span><br><span class="line">rmp -qa</span><br><span class="line">查询是否安装某个软件：</span><br><span class="line">rpm -qa | grep xxx</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">-q 询问</span><br><span class="line">-a 查询</span><br></pre></td></tr></tbody></table></figure><h4 id="4）删除已安装的软件-rpm-e"><a href="#4）删除已安装的软件-rpm-e" class="headerlink" title="4）删除已安装的软件==rpm -e=="></a>4）删除已安装的软件==rpm -e==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -e unix2dos-2.2-35.el6.x86_64</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">-e eraser擦除，也就是删除</span><br></pre></td></tr></tbody></table></figure><h3 id="（3）RPM安装的优缺点"><a href="#（3）RPM安装的优缺点" class="headerlink" title="（3）RPM安装的优缺点"></a>（3）RPM安装的优缺点</h3><p>优点：</p><ul><li>由于已经编译完成并且打包完毕，所以软件传输与安装上很方便 (不需要再重新编译)</li><li>由于软件的信息都已经记录在Linux主机的数据库上，很<strong>方便查询、升级与卸载</strong></li></ul><p>缺点：</p><ul><li>不能根据自己的需求灵活配置</li><li>可能存在打包环境与安装环境不一致，运行不起来，导致安装失败；或者存在依赖，也会安装失败，比如安装tomcat之前需要安装jdk</li><li>更新慢</li></ul><h2 id="3、yum（centOS）"><a href="#3、yum（centOS）" class="headerlink" title="3、yum（centOS）"></a>3、yum（centOS）</h2><h3 id="（1）yum安装方式简介"><a href="#（1）yum安装方式简介" class="headerlink" title="（1）yum安装方式简介"></a>（1）yum安装方式简介</h3><p>yum安装概念：在Fedora和Redhat以及SUSE、CentOS中的软件包管理器</p><p>yum安装的特点：</p><ul><li><p>yum是基于rpm包的</p></li><li><p>但是，对比rpm，yum有以下不同</p><ul><li><p>yum能够从指定的服务器自动下载rpm包并且安装</p></li><li><p>可以自动处理包依赖关系，并且一次安装所有依赖的软件包</p><p>如何实现的：镜像mirror：软件运行时所需要的其他软件（依赖），以及运行环境都打成一个包，保证yum必然可以运行</p></li></ul></li></ul><h3 id="（2）安装步骤"><a href="#（2）安装步骤" class="headerlink" title="（2）安装步骤"></a>（2）安装步骤</h3><p>以wget命令的安装为例演示过程：</p><h4 id="1）安装包-yum-y-install"><a href="#1）安装包-yum-y-install" class="headerlink" title="1）安装包==yum -y install=="></a>1）安装包==yum -y install==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">-y（当安装过程提示选择全部为 "yes"），-q（不显示安装的过程）等等</span><br></pre></td></tr></tbody></table></figure><h4 id="2）列出通过yum已安装的软件-yum-list-installed"><a href="#2）列出通过yum已安装的软件-yum-list-installed" class="headerlink" title="2）列出通过yum已安装的软件==yum list installed=="></a>2）列出通过yum已安装的软件==yum list installed==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep 名称</span><br><span class="line">查询是否安装某个软件</span><br></pre></td></tr></tbody></table></figure><ul><li><p>查所有通过yum安装的软件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed</span><br></pre></td></tr></tbody></table></figure><p>每一行就是一个软件：</p><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429144605962.png" alt="image-20240429144605962" style="zoom: 50%;"></p></li><li><p>具体查询是否通过yum安装过wget</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep wget</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429144643834.png" alt="image-20240429144643834" style="zoom:50%;"></p></li></ul><h4 id="3）删除包-yum-y-remove"><a href="#3）删除包-yum-y-remove" class="headerlink" title="3）删除包==yum -y remove=="></a>3）删除包==yum -y remove==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove wget</span><br><span class="line">-y（当安装过程提示选择全部为 "yes"），-q（不显示安装的过程）等等</span><br></pre></td></tr></tbody></table></figure><h3 id="（3）优缺点"><a href="#（3）优缺点" class="headerlink" title="（3）优缺点"></a>（3）优缺点</h3><p>优点：</p><ul><li>从指定服务器下载软件包，不需要手动下载</li><li>自动解决依赖包的问题，基本上就是一键式安装。</li></ul><h2 id="4、apt-get（Ubuntu）"><a href="#4、apt-get（Ubuntu）" class="headerlink" title="4、apt-get（Ubuntu）"></a>4、apt-get（Ubuntu）</h2><p>概念：Debian，Ubuntu发行版的包管理工具、与Redhat中的yum工具类似</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install wget</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、压缩与打包&quot;&gt;&lt;a href=&quot;#一、压缩与打包&quot; class=&quot;headerlink&quot; title=&quot;一、压缩与打包&quot;&gt;&lt;/a&gt;一、压缩与打包&lt;/h1&gt;&lt;h2 id=&quot;0、打包和压缩的区别：&quot;&gt;&lt;a href=&quot;#0、打包和压缩的区别：&quot; class=&quot;headerlink&quot; title=&quot;0、打包和压缩的区别：&quot;&gt;&lt;/a&gt;0、打包和压缩的区别：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;打包是指把文件和目录的结构和内容==拷贝==到一个文件里&lt;/li&gt;
&lt;li&gt;压缩是把文件经过一些算法变成体积上更小的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以WinRAR为例，一般是既打包也压缩，也可以不压缩，只打包&lt;/p&gt;
&lt;h2 id=&quot;1、压缩命令-gzip-、查看压缩内容-zcat&quot;&gt;&lt;a href=&quot;#1、压缩命令-gzip-、查看压缩内容-zcat&quot; class=&quot;headerlink&quot; title=&quot;1、压缩命令==gzip==、查看压缩内容==zcat==&quot;&gt;&lt;/a&gt;1、压缩命令==gzip==、查看压缩内容==zcat==&lt;/h2&gt;&lt;h3 id=&quot;（1）gzip压缩&quot;&gt;&lt;a href=&quot;#（1）gzip压缩&quot; class=&quot;headerlink&quot; title=&quot;（1）gzip压缩&quot;&gt;&lt;/a&gt;（1）gzip压缩&lt;/h3&gt;&lt;p&gt;1）gzip命令，压缩一个或多个文件，==压缩成分别的压缩文件，不能对整个目录压缩，但可以通过-r参数分别压缩目录下的文件==&lt;/p&gt;
&lt;p&gt;2）压缩完原文件不在，变为.gz文件&lt;/p&gt;
&lt;p&gt;3）格式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;压缩格式：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gzip 文件名；(压缩完成后，原来的文件会被替换成&amp;lt;name&amp;gt;.gz，原文件消失)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;压缩scp.log文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gzip scp.out&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;原始文件大小为129&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429190259032.png&quot; alt=&quot;image-20240429190259032&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对其进行压缩，压缩后变为 &lt;code&gt;.gz&lt;/code&gt; 文件，大小变为112：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429190414673.png&quot; alt=&quot;image-20240429190414673&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;压缩test目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无法压缩目录本身，但是可以-r压缩子文件&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gzip -r /home/test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-r：递归压缩，压缩其子文件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行命令后，会将test目录下的每个文件进行分别压缩，如图压缩前是&lt;code&gt;catalina.out&lt;/code&gt;和&lt;code&gt;locahost.2024-04-29.log&lt;/code&gt;文件，压缩后分别变成压缩包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/29/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/image-20240429101324023.png&quot; alt=&quot;image-20240429101324023&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Linux" scheme="https://laylaycjl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件权限管理</title>
    <link href="https://laylaycjl.github.io/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>https://laylaycjl.github.io/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</id>
    <published>2024-04-28T07:42:50.000Z</published>
    <updated>2024-04-28T11:55:40.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、文件访问权限和用户种类"><a href="#一、文件访问权限和用户种类" class="headerlink" title="一、文件访问权限和用户种类"></a>一、文件访问权限和用户种类</h1><h2 id="1、文件访问权限"><a href="#1、文件访问权限" class="headerlink" title="1、文件访问权限"></a>1、文件访问权限</h2><h3 id="（1）用ls查看时，显示内容说明："><a href="#（1）用ls查看时，显示内容说明：" class="headerlink" title="（1）用ls查看时，显示内容说明："></a>（1）用ls查看时，显示内容说明：</h3><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428154306993.png" style="zoom: 67%;"></p><p>文件类型说明：</p><ul><li>“-”表示普通文件；</li><li>“d”表示目录；</li><li>“l”表示链接文件；</li><li>“p”表示管理文件；</li><li>“b”表示块设备文件；</li><li>“c”表示字符设备文件；</li><li>“s”表示套接字文件；</li></ul><p>权限说明：</p><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428155458149.png" alt="image-20240428155458149" style="zoom:50%;"></p><h3 id="（2）文件权限分类"><a href="#（2）文件权限分类" class="headerlink" title="（2）文件权限分类"></a>（2）文件权限分类</h3><div class="table-container"><table><thead><tr><th><strong>权限</strong></th><th><strong>文件的存取权限</strong></th><th><strong>目录的存取权限</strong></th></tr></thead><tbody><tr><td>r</td><td>具有<strong>读</strong>文件的权限</td><td>对文件：能查看文件内容（cat、less、head、tail、ls、more命令可以执行）  对目录：可以查看目录内容</td></tr><tr><td>w</td><td>具有<strong>写</strong>文件的权限</td><td>能创建和删除文件（比如：在文件夹下面，使用touch命令创建文件）</td></tr><tr><td>x</td><td>具有<strong>执行</strong>文件的权限</td><td>能使用该目录下的文件（如cd命令），能进入该目录</td></tr></tbody></table></div><span id="more"></span><h5 id="1-读权限举例："><a href="#1-读权限举例：" class="headerlink" title="1))读权限举例："></a>1))读权限举例：</h5><ul><li><p>对文件来说jack用户没有对test.sh的任何权限</p><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428160749491.png" alt="image-20240428160749491" style="zoom:67%;"></p><p>给jack用户增加权限之后，就可以查看相应内容</p><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428160908250.png" alt="image-20240428160908250" style="zoom: 50%;"></p></li><li><p>对目录来说，jack文件没有对tom目录的读权限，增加权限之后，可读</p><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428160150911.png" alt="image-20240428160150911" style="zoom: 50%;"></p></li></ul><h5 id="2-写权限举例"><a href="#2-写权限举例" class="headerlink" title="2))写权限举例"></a>2))写权限举例</h5><ul><li><p>对文件来说，没有写权限，显示为readonly，给jack加上写权利后，就可以写文件了</p><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428161521690.png" alt="image-20240428161521690" style="zoom:67%;"></p></li><li><p>对于目录来说，没有写权限，就无法mkdir，rmdir目录，也无法创建文件，无法移动和复制</p><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428161715454.png" alt="image-20240428161715454" style="zoom:67%;"></p></li></ul><h5 id="3-可执行权限举例："><a href="#3-可执行权限举例：" class="headerlink" title="3))可执行权限举例："></a>3))可执行权限举例：</h5><ul><li>对于文件来说，没有执行权限就无法运行该文件</li></ul><h2 id="2、用户分类"><a href="#2、用户分类" class="headerlink" title="2、用户分类"></a>2、用户分类</h2><p>对于文件来说用户分为三类</p><ul><li>owner：所有者，一般这个文件谁创建，谁就是owner</li><li>group：组用户，谁创建了文件，这个用户的<strong>主组</strong>就是文件所属组</li><li>others：其他用户，既不是所有者，也不是组用户</li></ul><h1 id="二、修改文件访问权限-chmod"><a href="#二、修改文件访问权限-chmod" class="headerlink" title="二、修改文件访问权限==chmod=="></a>二、修改文件访问权限==chmod==</h1><ul><li>==谁可以改变文件访问权限？root和owner==</li></ul><h2 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">语法：chmod [who][operation][permission] filename</span><br><span class="line">例如：chmod u+x file01</span><br><span class="line"></span><br><span class="line">who项表示用户类型，它的内容为以下一项或多项</span><br><span class="line">u                     拥有者（user --owner）</span><br><span class="line">g                     与拥有者同一组的用户（group）</span><br><span class="line">o                     其他人（other）</span><br><span class="line">a                     所有人（all）</span><br><span class="line"></span><br><span class="line">operiation项表示动作</span><br><span class="line">+                          表示要加上permission指定的权限</span><br><span class="line">-                          表示要取消permission指定的权限</span><br><span class="line"></span><br><span class="line">permission项为存取权限，它的内容为以下一项或多项</span><br><span class="line">r                         表示可读</span><br><span class="line">w                        表示可写</span><br><span class="line">x                         表示可执行</span><br></pre></td></tr></tbody></table></figure><h2 id="2、三种写法"><a href="#2、三种写法" class="headerlink" title="2、三种写法"></a>2、三种写法</h2><h3 id="（1）增加-、减少-权限"><a href="#（1）增加-、减少-权限" class="headerlink" title="（1）增加+、减少-权限"></a>（1）增加<code>+</code>、减少<code>-</code>权限</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">针对file01，给其他用户加一个可执行权限</span><br><span class="line">chmod o+x file01</span><br><span class="line"></span><br><span class="line">针对文件file01，给其他用户和组用户增加写权限</span><br><span class="line">chmod og+w file01</span><br><span class="line"></span><br><span class="line">针对文件file01，给owner用户增加读写执行权限，给组用户可读可写权限，其他用户执行权限(用逗号隔开)</span><br><span class="line">chmod u+rwx,g+rw,o+x file01</span><br><span class="line"></span><br><span class="line">针对文件file01，给其他用户取消写权限</span><br><span class="line">chmod o-w file01</span><br></pre></td></tr></tbody></table></figure><h3 id="（2）-，赋予权限，不关心原始权限"><a href="#（2）-，赋予权限，不关心原始权限" class="headerlink" title="（2）=，赋予权限，不关心原始权限"></a>（2）=，赋予权限，不关心原始权限</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">针对文件file01，给owner用户增加读写执行权限，给组用户可读可写权限，其他用户执行权限(用逗号隔开)</span><br><span class="line">chmod u=rwx,g=rw,o=x file01</span><br></pre></td></tr></tbody></table></figure><h3 id="（3）r、w、x分别用4、2、1数字来表示"><a href="#（3）r、w、x分别用4、2、1数字来表示" class="headerlink" title="（3）r、w、x分别用4、2、1数字来表示"></a>（3）r、w、x分别用4、2、1数字来表示</h3><p><img src="/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428165537604.png" alt="image-20240428165537604" style="zoom:50%;"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">owner用户、group用户和其他用户权限均可读可写可执行：</span><br><span class="line">chmod 777 file01</span><br><span class="line"></span><br><span class="line">owner用户可读可写可执行、group用户可读可写、其他用户可读可执行</span><br><span class="line">chmod 765 file01</span><br><span class="line"></span><br><span class="line">0：什么权限都没有</span><br><span class="line">1：可执行</span><br><span class="line">2：可写</span><br><span class="line">3：可写可执行</span><br><span class="line">4：可读</span><br><span class="line">5：可读可执行</span><br><span class="line">6：可读可写</span><br><span class="line">7：可读可写可执行</span><br></pre></td></tr></tbody></table></figure><h1 id="三、修改文件所属用户和所属组-chown"><a href="#三、修改文件所属用户和所属组-chown" class="headerlink" title="三、修改文件所属用户和所属组==chown=="></a>三、修改文件所属用户和所属组==chown==</h1><p>谁可以改变文件的所有者和所属组？</p><p>==只有root用户，owner都不行==</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">语法：chown [参数] [用户]:[组] 文件</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-R：级联修改，递归</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">只修改文件所属者：把文件file01的所有者改成jack：</span><br><span class="line">chown jack file01</span><br><span class="line">只修改文件的所属组：把文件file01的所属组改成jack：</span><br><span class="line">chown :jack file01</span><br><span class="line">把文件file02的所有者改成jack，所属组改成jack：</span><br><span class="line">chown jack:jack file02</span><br><span class="line"></span><br><span class="line">把目录dir01以及下面所有的子目录和文件的所有者改成jack：</span><br><span class="line">chown -R jack dir01</span><br><span class="line">把目录dir01以及下面所有的子目录和文件的所属组改成jack：</span><br><span class="line">chown -R :jack dir01</span><br><span class="line">把目录dir02以及下面所有的子目录和文件的所有者改成jack，所属组改成jack：</span><br><span class="line">chown -R jack:jack dir02</span><br><span class="line"></span><br><span class="line">不加-R：chown jack dir01：只修改dir01这个目录的所有者，子目录和文件不修改</span><br></pre></td></tr></tbody></table></figure><h1 id="四、只修改文件所属组-chgrp"><a href="#四、只修改文件所属组-chgrp" class="headerlink" title="四、只修改文件所属组==chgrp=="></a>四、只修改文件所属组==chgrp==</h1><p><strong>chown可以替代chgrp</strong></p><p>谁可以改变文件的所属组？</p><p>==root，owner（只能改变到owner所在的组）==</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chgrp</span><br><span class="line">语法：chgrp [选项]…[组] 文件</span><br><span class="line">举例：chgrp jack file01把file01的所属组改成jack</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、文件访问权限和用户种类&quot;&gt;&lt;a href=&quot;#一、文件访问权限和用户种类&quot; class=&quot;headerlink&quot; title=&quot;一、文件访问权限和用户种类&quot;&gt;&lt;/a&gt;一、文件访问权限和用户种类&lt;/h1&gt;&lt;h2 id=&quot;1、文件访问权限&quot;&gt;&lt;a href=&quot;#1、文件访问权限&quot; class=&quot;headerlink&quot; title=&quot;1、文件访问权限&quot;&gt;&lt;/a&gt;1、文件访问权限&lt;/h2&gt;&lt;h3 id=&quot;（1）用ls查看时，显示内容说明：&quot;&gt;&lt;a href=&quot;#（1）用ls查看时，显示内容说明：&quot; class=&quot;headerlink&quot; title=&quot;（1）用ls查看时，显示内容说明：&quot;&gt;&lt;/a&gt;（1）用ls查看时，显示内容说明：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428154306993.png&quot; style=&quot;zoom: 67%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;文件类型说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“-”表示普通文件；&lt;/li&gt;
&lt;li&gt;“d”表示目录；&lt;/li&gt;
&lt;li&gt;“l”表示链接文件；&lt;/li&gt;
&lt;li&gt;“p”表示管理文件；&lt;/li&gt;
&lt;li&gt;“b”表示块设备文件；&lt;/li&gt;
&lt;li&gt;“c”表示字符设备文件；&lt;/li&gt;
&lt;li&gt;“s”表示套接字文件；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;权限说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/28/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20240428155458149.png&quot; alt=&quot;image-20240428155458149&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;（2）文件权限分类&quot;&gt;&lt;a href=&quot;#（2）文件权限分类&quot; class=&quot;headerlink&quot; title=&quot;（2）文件权限分类&quot;&gt;&lt;/a&gt;（2）文件权限分类&lt;/h3&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;权限&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;文件的存取权限&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;目录的存取权限&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;具有&lt;strong&gt;读&lt;/strong&gt;文件的权限&lt;/td&gt;
&lt;td&gt;对文件：能查看文件内容（cat、less、head、tail、ls、more命令可以执行）  对目录：可以查看目录内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;具有&lt;strong&gt;写&lt;/strong&gt;文件的权限&lt;/td&gt;
&lt;td&gt;能创建和删除文件（比如：在文件夹下面，使用touch命令创建文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;具有&lt;strong&gt;执行&lt;/strong&gt;文件的权限&lt;/td&gt;
&lt;td&gt;能使用该目录下的文件（如cd命令），能进入该目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Linux" scheme="https://laylaycjl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>用户管理</title>
    <link href="https://laylaycjl.github.io/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>https://laylaycjl.github.io/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</id>
    <published>2024-04-28T06:01:09.000Z</published>
    <updated>2024-04-28T08:36:45.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、用户和用户组"><a href="#一、用户和用户组" class="headerlink" title="一、用户和用户组"></a>一、用户和用户组</h1><h3 id="1、用户、用户组概念"><a href="#1、用户、用户组概念" class="headerlink" title="1、用户、用户组概念"></a>1、用户、用户组概念</h3><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428141914666.png" alt="image-20240428141914666" style="zoom:50%;"></p><ul><li><p>Linux是一个多用户的操作系统</p></li><li><p>任何一个要使用系统资源的用户，必须登录进入系统</p></li><li><p>Linux用户属于一个或多个特定的组，称为用户组，即group</p></li></ul><h3 id="2、为什么分组"><a href="#2、为什么分组" class="headerlink" title="2、为什么分组"></a>2、为什么分组</h3><ul><li><p>资源访问控制：文件（泛义上的文件）</p></li><li><p>所有文件都属于一个特定的用户，和一个特定的用户组</p></li><li><p>每个文件都有一定的访问权限，用户限制不同用户和用户组的访问行为</p></li></ul><h3 id="3、用户和用户组的关系"><a href="#3、用户和用户组的关系" class="headerlink" title="3、用户和用户组的关系"></a>3、用户和用户组的关系</h3><ul><li><p><strong>多对多</strong>的关系</p><p>Linux系统以组Group方式管理用户，用户和组的对应关系为多对多，即某个用户可属于一个或多个组，某个组可以有0个、1个或多个用户。</p></li><li><p>组的分类</p><p>从用户的角度，分为主组和附属组：</p><ul><li><strong>主组</strong>：也被称为primary group、first group或initial login group，用户的默认组，用户的gid所标识的组</li><li><strong>附属组</strong>：也被称为Secondary group或supplementary group，用户的附加组</li><li><strong>用户必须有且只能有一个主组，就可以有0个、1个或多个附属组</strong>，如我们一定会有一个用来安家的房子（类同主组），还可以有n个用于投资或其他打算的房子（附属组）</li></ul></li></ul><h3 id="4、用户分类"><a href="#4、用户分类" class="headerlink" title="4、用户分类"></a>4、用户分类</h3><p>（1）root用户：超级管理员用户，具有操作系统的最大权限</p><p>（2）普通用户：由超级用户创建及授权，并且可以登录到Linux系统执行某些任务</p><p>（3）系统用户：系统内创建了若干用户，如mail、ftp、bin等，默认情况下，系统用户都是无法登录的</p><span id="more"></span><h1 id="二、用户管理操作"><a href="#二、用户管理操作" class="headerlink" title="二、用户管理操作"></a>二、用户管理操作</h1><h3 id="1、查看用户和组信息"><a href="#1、查看用户和组信息" class="headerlink" title="1、查看用户和组信息"></a>1、查看用户和组信息</h3><h4 id="（1）查看用户-cat-etc-passwd"><a href="#（1）查看用户-cat-etc-passwd" class="headerlink" title="（1）查看用户==cat /etc/passwd=="></a>（1）查看用户==cat /etc/passwd==</h4><h5 id="1）查看所有用户"><a href="#1）查看所有用户" class="headerlink" title="1）查看所有用户"></a>1）查看所有用户</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></tbody></table></figure><ul><li>用户展现顺序：</li></ul><p>==超级管理员（id为0）—— &gt; 系统用户（id为1到999）：nologin ——&gt; 普通用户（id从1000开始）==</p><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428140839244.png" alt="image-20240428140839244" style="zoom:50%;"></p><ul><li>查询结果含义解释：</li></ul><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428151416824.png" alt="image-20240428151416824" style="zoom:80%;"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root：用户名</span><br><span class="line">x：密码</span><br><span class="line">0：用户id</span><br><span class="line">0：用户组id</span><br><span class="line">root：</span><br><span class="line">/root：该用户的家目录路径</span><br><span class="line">/bin/bash：用户默认的shell</span><br></pre></td></tr></tbody></table></figure><h5 id="2）查看某个用户信息："><a href="#2）查看某个用户信息：" class="headerlink" title="2）查看某个用户信息："></a>2）查看某个用户信息：</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | grep clj</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428151541979.png" alt="image-20240428151541979" style="zoom:50%;"></p><h4 id="（2）查看组-cat-etc-group"><a href="#（2）查看组-cat-etc-group" class="headerlink" title="（2）查看组==cat /etc/group=="></a>（2）查看组==cat /etc/group==</h4><h5 id="1）查看所有组"><a href="#1）查看所有组" class="headerlink" title="1）查看所有组"></a>1）查看所有组</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group</span><br></pre></td></tr></tbody></table></figure><h5 id="2）查看zhangsan的用户组"><a href="#2）查看zhangsan的用户组" class="headerlink" title="2）查看zhangsan的用户组"></a>2）查看zhangsan的用户组</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | grep zhangsan</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428144414279.png" alt="image-20240428144414279" style="zoom:67%;"></p><h3 id="2、添加用户-useradd"><a href="#2、添加用户-useradd" class="headerlink" title="2、添加用户==useradd=="></a>2、添加用户==useradd==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名 [-g用户组名][-d家目录]</span><br><span class="line">-g：指明用户所属组，该用户组必须存在</span><br><span class="line">-d：可以指定用户的家目录，如果没有指定，那么默认家目录在/home</span><br></pre></td></tr></tbody></table></figure><p>该命令完成的事情：（默认没有指定<code>-g</code>和<code>-d</code>）</p><ul><li><p>在/etc/passwd文件中增加一行数据，表示该用户的信息</p></li><li><p>为该用户<strong>创建用户组</strong>，将该用户标识符加在/etc/group文件中，如果有-g选项，则不创建用户组，而是将该用户加入指定组中</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group 可以查询用户组</span><br></pre></td></tr></tbody></table></figure></li><li><p>为该用户<strong>创建一个家目录</strong>（home directory），将家目录的拥有者改为该用户所有</p></li></ul><h3 id="3、设置、修改用户密码-passwd"><a href="#3、设置、修改用户密码-passwd" class="headerlink" title="3、设置、修改用户密码==passwd=="></a>3、设置、修改用户密码==passwd==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 用户名</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428142357737.png" alt="image-20240428142357737" style="zoom:50%;"></p><ul><li>创建了用户之后，其密码是随机的</li><li>用户可以修改自己的密码（需要输入当前密码）</li><li>只有root用户可以修改其他用户密码</li></ul><h3 id="4、修改用户所属组-usermod"><a href="#4、修改用户所属组-usermod" class="headerlink" title="4、修改用户所属组==usermod=="></a>4、修改用户所属组==usermod==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">usermod</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-g修改主组</span><br><span class="line">-G修改附属组</span><br><span class="line">-a增加附属组</span><br><span class="line">-L lock锁定</span><br><span class="line">-U unlock解锁</span><br></pre></td></tr></tbody></table></figure><p><code>-g</code> 修改主组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g root jim //修改用户jim的主组为root</span><br></pre></td></tr></tbody></table></figure><p><code>-G</code> 修改附属组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -G g2,g3 jim //修改用户jim的附属组为g2、g3</span><br></pre></td></tr></tbody></table></figure><p><code>-a</code>增加附属组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -a -G g4 jim //增加用户jim的附属组g4</span><br></pre></td></tr></tbody></table></figure><p><code>-L</code> lock锁定</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -L jim //锁定jim用户，锁定后该用户不能再登录</span><br></pre></td></tr></tbody></table></figure><p><code>-U</code> unlock解锁</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -U jim //解锁jim用户，解锁后该用户可以再登录</span><br></pre></td></tr></tbody></table></figure><h3 id="5、删除用户-userdel"><a href="#5、删除用户-userdel" class="headerlink" title="5、删除用户==userdel=="></a>5、删除用户==userdel==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userdel 用户名</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-r：加-r删除更彻底</span><br></pre></td></tr></tbody></table></figure><p>不加<code>-r</code> 删除用户时，删除不彻底，家目录和邮箱目录都在：</p><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428144709336.png" alt="image-20240428144709336" style="zoom:50%;"></p><p>加<code>-r</code> 删除用户时，是彻底删除：</p><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428145008963.png" alt="image-20240428145008963" style="zoom:50%;"></p><h3 id="6、查询用户"><a href="#6、查询用户" class="headerlink" title="6、查询用户"></a>6、查询用户</h3><p>用户可以使用下列指令查询用户相关信息</p><h4 id="（1）-who"><a href="#（1）-who" class="headerlink" title="（1）==who=="></a>（1）==who==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who</span><br></pre></td></tr></tbody></table></figure><p>注意：查询当前在线的用户，只能查询在登录页面输入了用户名密码登录的用户，<strong>通过su命令切换方式登录的用户，用who命令无法查询到该用户！！</strong></p><p>目前在登录状态的有root和zhangsan：</p><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428153125523.png" alt="image-20240428153125523" style="zoom:67%;"></p><h4 id="（2）-whoami"><a href="#（2）-whoami" class="headerlink" title="（2）==whoami=="></a>（2）==whoami==</h4><p>用户身份查询，当前所在的用户</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428153207695.png" alt="image-20240428153207695" style="zoom:67%;"></p><h4 id="（3）-id"><a href="#（3）-id" class="headerlink" title="（3）==id=="></a>（3）==id==</h4><p>显示当前用户信息</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428153244865.png" alt="image-20240428153244865" style="zoom:67%;"></p><h4 id="（4）-groups-用户名"><a href="#（4）-groups-用户名" class="headerlink" title="（4）==groups 用户名=="></a>（4）==groups 用户名==</h4><p>查询用户所属的组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groups jack</span><br><span class="line">jack : user05 user03 user04</span><br></pre></td></tr></tbody></table></figure><h1 id="三、用户之间的切换-su"><a href="#三、用户之间的切换-su" class="headerlink" title="三、用户之间的切换==su=="></a>三、用户之间的切换==su==</h1><h3 id="1、root切换到普通用户"><a href="#1、root切换到普通用户" class="headerlink" title="1、root切换到普通用户"></a>1、root切换到普通用户</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - 普通用户用户名</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428142744888.png" alt="image-20240428142744888" style="zoom:67%;"></p><ul><li><p>不用输入密码</p></li><li><p><strong>有没有 <code>-</code> 的区别</strong>：有 <code>-</code> 会重新初始化环境，比如全新用户home目录，新的环境变量。没有加 <code>-</code> 切换得不彻底，没有完整地初始化用户环境</p><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428143013726.png" alt="image-20240428143013726" style="zoom:50%;"></p><p>比如，从zhangsan用户切换到root之后：</p><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428143728952.png" alt="image-20240428143728952" style="zoom:67%;"></p><p>显示MAIL、PWD、HOME等环境变量依旧是zhangsan的环境变量，没有初始化到root的环境变量</p></li></ul><h3 id="2、普通用户切换到root"><a href="#2、普通用户切换到root" class="headerlink" title="2、普通用户切换到root"></a>2、普通用户切换到root</h3><p>要输入密码才能切换</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428142744888.png" alt="image-20240428142744888" style="zoom:50%;"></p><h1 id="四、用户组的创建和删除"><a href="#四、用户组的创建和删除" class="headerlink" title="四、用户组的创建和删除"></a>四、用户组的创建和删除</h1><p>==只有root用户可以操作==</p><h3 id="1、创建组-groupadd"><a href="#1、创建组-groupadd" class="headerlink" title="1、创建组==groupadd=="></a>1、创建组==groupadd==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groupadd：创建组</span><br><span class="line">eg.root用户创建用户组sales</span><br><span class="line">   groupadd sales</span><br><span class="line">eg.root用户创建用户sa01，sa02用户，并把它们添加到sales组里</span><br><span class="line">   useradd -g sales sa01</span><br><span class="line">   useradd -g sales sa02</span><br></pre></td></tr></tbody></table></figure><h3 id="2、删除组-groupdel"><a href="#2、删除组-groupdel" class="headerlink" title="2、删除组==groupdel=="></a>2、删除组==groupdel==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupdel：删除组</span><br><span class="line">eg.root用户删除用户组sales</span><br><span class="line">   groupdel sales</span><br></pre></td></tr></tbody></table></figure><p>注意：如果有用户属于这个组呢？—<strong>primary组不能删除</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、用户和用户组&quot;&gt;&lt;a href=&quot;#一、用户和用户组&quot; class=&quot;headerlink&quot; title=&quot;一、用户和用户组&quot;&gt;&lt;/a&gt;一、用户和用户组&lt;/h1&gt;&lt;h3 id=&quot;1、用户、用户组概念&quot;&gt;&lt;a href=&quot;#1、用户、用户组概念&quot; class=&quot;headerlink&quot; title=&quot;1、用户、用户组概念&quot;&gt;&lt;/a&gt;1、用户、用户组概念&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2024/04/28/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/image-20240428141914666.png&quot; alt=&quot;image-20240428141914666&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linux是一个多用户的操作系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任何一个要使用系统资源的用户，必须登录进入系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Linux用户属于一个或多个特定的组，称为用户组，即group&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2、为什么分组&quot;&gt;&lt;a href=&quot;#2、为什么分组&quot; class=&quot;headerlink&quot; title=&quot;2、为什么分组&quot;&gt;&lt;/a&gt;2、为什么分组&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;资源访问控制：文件（泛义上的文件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有文件都属于一个特定的用户，和一个特定的用户组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个文件都有一定的访问权限，用户限制不同用户和用户组的访问行为&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3、用户和用户组的关系&quot;&gt;&lt;a href=&quot;#3、用户和用户组的关系&quot; class=&quot;headerlink&quot; title=&quot;3、用户和用户组的关系&quot;&gt;&lt;/a&gt;3、用户和用户组的关系&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;多对多&lt;/strong&gt;的关系&lt;/p&gt;
&lt;p&gt;Linux系统以组Group方式管理用户，用户和组的对应关系为多对多，即某个用户可属于一个或多个组，某个组可以有0个、1个或多个用户。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组的分类&lt;/p&gt;
&lt;p&gt;从用户的角度，分为主组和附属组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主组&lt;/strong&gt;：也被称为primary group、first group或initial login group，用户的默认组，用户的gid所标识的组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;附属组&lt;/strong&gt;：也被称为Secondary group或supplementary group，用户的附加组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户必须有且只能有一个主组，就可以有0个、1个或多个附属组&lt;/strong&gt;，如我们一定会有一个用来安家的房子（类同主组），还可以有n个用于投资或其他打算的房子（附属组）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4、用户分类&quot;&gt;&lt;a href=&quot;#4、用户分类&quot; class=&quot;headerlink&quot; title=&quot;4、用户分类&quot;&gt;&lt;/a&gt;4、用户分类&lt;/h3&gt;&lt;p&gt;（1）root用户：超级管理员用户，具有操作系统的最大权限&lt;/p&gt;
&lt;p&gt;（2）普通用户：由超级用户创建及授权，并且可以登录到Linux系统执行某些任务&lt;/p&gt;
&lt;p&gt;（3）系统用户：系统内创建了若干用户，如mail、ftp、bin等，默认情况下，系统用户都是无法登录的&lt;/p&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Linux" scheme="https://laylaycjl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>重定向、管道与环境变量</title>
    <link href="https://laylaycjl.github.io/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https://laylaycjl.github.io/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2024-04-26T08:42:46.000Z</published>
    <updated>2024-04-28T06:02:57.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、重定向"><a href="#一、重定向" class="headerlink" title="一、重定向"></a>一、重定向</h1><h2 id="1、标准输入、标准输出、标准错误"><a href="#1、标准输入、标准输出、标准错误" class="headerlink" title="1、标准输入、标准输出、标准错误"></a>1、标准输入、标准输出、标准错误</h2><p>执行一个shell命令行时通常会自动打开三个标准文件，即：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426164557090.png" alt="image-20240426164557090" style="zoom:50%;"></p><ul><li><p>标准输入文件（stdin），通常对应终端的键盘，stdin的文件描述符为==0==，Unix程序默认从stdin读取数据</p></li><li><p>标准输出文件（stdout），对应终端的屏幕，stdout 的文件描述符为==1==，Unix程序默认向stdout输出数据</p></li><li>标准错误输出文件（stderr），对应终端的屏幕，stderr的文件描述符为==2==，Unix程序会向stderr流中写入错误信息</li></ul><p>进程将从标准输入文件中得到输入数据，将<strong>正常输出数据</strong>输出到<u>标准输出文件</u>，而将<strong>错误信息</strong>送到<u>标准错误文件</u>中</p><span id="more"></span><h2 id="2、输出重定向"><a href="#2、输出重定向" class="headerlink" title="2、输出重定向"></a>2、输出重定向</h2><h3 id="1、标准输出重定向"><a href="#1、标准输出重定向" class="headerlink" title="1、标准输出重定向"></a>1、标准输出重定向</h3><h4 id="（1）为什么重定向？"><a href="#（1）为什么重定向？" class="headerlink" title="（1）为什么重定向？"></a>（1）为什么重定向？</h4><p>有时候命令结果要使用，不想输出到终端上，可以将输出定向到别的设备，比如重定向到一个文件中</p><h4 id="（2）如何输出重定向"><a href="#（2）如何输出重定向" class="headerlink" title="（2）如何输出重定向"></a>（2）如何输出重定向</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">命令 &gt; 文件(输出重定向)</span><br><span class="line">命令 &gt;&gt; 文件（不覆盖文件，追加到文件末尾）</span><br><span class="line"></span><br><span class="line">比如：ps -ef &gt; file01 表示把ps -ef的结果重定向到文件file01中</span><br></pre></td></tr></tbody></table></figure><p><strong>注意</strong>：输出重定向会覆盖文件内容，如果不希望文件内容被覆盖，可以使用 <code>&gt;&gt;</code>追加到文件末尾</p><h4 id="（3）输出重定向符号的特殊用法"><a href="#（3）输出重定向符号的特殊用法" class="headerlink" title="（3）输出重定向符号的特殊用法"></a>（3）输出重定向符号的特殊用法</h4><h5 id="1）新建文件"><a href="#1）新建文件" class="headerlink" title="1）新建文件"></a>1）新建文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文件名</span><br><span class="line">eg.&gt; file01</span><br><span class="line">当file01文件不存在时，就会新建file01</span><br></pre></td></tr></tbody></table></figure><h5 id="2）清空文件"><a href="#2）清空文件" class="headerlink" title="2）清空文件"></a>2）清空文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文件名</span><br><span class="line">eg.&gt; file01</span><br><span class="line">当file01文件存在时，就会覆盖file01，从而清空file01</span><br></pre></td></tr></tbody></table></figure><h4 id="（4）输出重定向的应用"><a href="#（4）输出重定向的应用" class="headerlink" title="（4）输出重定向的应用"></a>（4）输出重定向的应用</h4><h5 id="1）把错误信息重定向到文件里，方便分析"><a href="#1）把错误信息重定向到文件里，方便分析" class="headerlink" title="1）把错误信息重定向到文件里，方便分析"></a>1）把错误信息重定向到文件里，方便分析</h5><ul><li><p>用grep查找catalina.log中的错误信息</p><p>会直接打印到屏幕上，不方便</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -i -E "error|Illegal" catalina.out</span><br><span class="line">-i 不区分大小写</span><br><span class="line">-E 正则</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426173716608.png" alt="image-20240426173716608" style="zoom:50%;"></p></li><li><p>把错误信息重定向到catalina_error文件里</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i -E "error|illegal" catalina.out &gt; catalina_error</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="2）实时监控日志，重定向到文件里"><a href="#2）实时监控日志，重定向到文件里" class="headerlink" title="2）实时监控日志，重定向到文件里"></a>2）实时监控日志，重定向到文件里</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f catalina.out &gt; catalina_output.log</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426174158802.png" alt="image-20240426174158802" style="zoom: 67%;"></p><h3 id="2、标准错误重定向"><a href="#2、标准错误重定向" class="headerlink" title="2、标准错误重定向"></a>2、标准错误重定向</h3><h4 id="（1）如何错误重定向"><a href="#（1）如何错误重定向" class="headerlink" title="（1）如何错误重定向"></a>（1）如何错误重定向</h4><p>默认情况下，<code>命令 &gt; 文件</code>会将输出重定向到 file</p><ul><li><p>如果希望将错误重定向到文件，可以这样写：命令 2 &gt; 文件</p></li><li><p>同样可以用&gt;&gt;来追加错误到文件末尾。</p></li><li><p>举例：直接重定向错误信息，会失败：<code>Ls &gt;&gt; file02</code></p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426171302675.png" alt="image-20240426171302675" style="zoom: 50%;"></p><p>加上限定2，定向成功：<code>Ls 2&gt;&gt; file02</code></p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426171533588.png" alt="image-20240426171533588" style="zoom:50%;"></p></li></ul><h4 id="（2）同时重定向标准输出和标准错误"><a href="#（2）同时重定向标准输出和标准错误" class="headerlink" title="（2）同时重定向标准输出和标准错误"></a>（2）同时重定向标准输出和标准错误</h4><p>执行文件中既有正确输出也有错误信息：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426171922457.png" alt="image-20240426171922457" style="zoom:50%;"></p><p>直接重定向，会让标准错误重定向失败：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426172147959.png" alt="image-20240426172147959" style="zoom: 50%;"></p><h5 id="1）重定向标准输出和标准错误到同一个文件"><a href="#1）重定向标准输出和标准错误到同一个文件" class="headerlink" title="1）重定向标准输出和标准错误到同一个文件"></a>1）重定向标准输出和标准错误到同一个文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：可执行命令/文件 &gt; file 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">注意：可执行命令/文件 &gt; file 1&gt;&amp;2会失败，必须按照2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426172302520.png" alt="image-20240426172302520" style="zoom:50%;"></p><h5 id="2）分别重定向标准输出和标准错误到不同一个文件"><a href="#2）分别重定向标准输出和标准错误到不同一个文件" class="headerlink" title="2）分别重定向标准输出和标准错误到不同一个文件"></a>2）分别重定向标准输出和标准错误到不同一个文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：可执行命令/文件 1&gt;正确file 2&gt;错误file</span><br><span class="line">将1（标准输出）重定向到正确的file，将2（标准错误）重定向到错误的file</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426172623372.png" alt="image-20240426172623372" style="zoom:50%;"></p><h2 id="3、输入重定向"><a href="#3、输入重定向" class="headerlink" title="3、输入重定向"></a>3、输入重定向</h2><h4 id="（1）语法"><a href="#（1）语法" class="headerlink" title="（1）语法"></a>（1）语法</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：命令 &lt; 文件</span><br><span class="line">比如：rm -i file01 &lt; file02表示从file02文件中读取内容作为命令的输入</span><br></pre></td></tr></tbody></table></figure><p>默认输入会显示在屏幕上：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426173137483.png" alt="image-20240426173137483" style="zoom:50%;"></p><p>将输入结果重定向到yes文件中：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426173315924.png" alt="image-20240426173315924" style="zoom:50%;"></p><h4 id="（2）常见用法"><a href="#（2）常见用法" class="headerlink" title="（2）常见用法"></a>（2）常见用法</h4><h5 id="1）通过cat编可视化编辑文件"><a href="#1）通过cat编可视化编辑文件" class="headerlink" title="1）通过cat编可视化编辑文件"></a>1）通过cat编可视化编辑文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF</span><br><span class="line">EOF代表End Of File</span><br><span class="line">输入命令之后进入编辑，输入EOF结束编辑</span><br><span class="line">还可以将编辑内容重定向到别的文件中，比如test61.log</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428095940677.png" alt="image-20240428095940677" style="zoom: 67%;"></p><h1 id="二、管道"><a href="#二、管道" class="headerlink" title="二、管道"></a>二、管道</h1><h2 id="1、管道的用法"><a href="#1、管道的用法" class="headerlink" title="1、管道的用法"></a>1、管道的用法</h2><p>经常要将一个命令的输出的内容，给另一个命令作为输入的内容进行处理</p><ul><li><p>例如，查看所有jack进程：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef &gt; ps.log</span><br><span class="line">将所有进程重定向到ps.log中</span><br><span class="line">grep jack ps.log</span><br><span class="line">查找所有带jack的行，也就是查所有jack进程</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428100445822.png" alt="image-20240428100445822" style="zoom:50%;"></p><p>如此导致ps命令的结果，会被下一个命令grep使用，为了方便，可以把ps命令的结果直接放入管道，给下一个命令使用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep jack</span><br></pre></td></tr></tbody></table></figure></li><li><p>再例如，统计jack进程有多少个</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法1：</span><br><span class="line">ps -ef &gt; ps.log</span><br><span class="line">grep jack ps.log &gt; jackps.log</span><br><span class="line">wc -l jackps.log</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法2：</span><br><span class="line">ps -ef &gt; ps.log</span><br><span class="line">grep -c jack ps.log &gt; jacknum.log</span><br></pre></td></tr></tbody></table></figure><p>使用管道就简单很多</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1：</span><br><span class="line">ps -ef | grep jack | wc -l</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法2：</span><br><span class="line">ps -ef | grep -c jack</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="2、管道示意图"><a href="#2、管道示意图" class="headerlink" title="2、管道示意图"></a>2、管道示意图</h3><h4 id="（1）图示"><a href="#（1）图示" class="headerlink" title="（1）图示"></a>（1）图示</h4><p>将前面的ps -ef命令的stdout（本来是输出到终端设备的）重定向到一个==临时管道设备==里</p><p>同时将后一个命令grep 1182的stdin重定向到这个临时的管道设备里</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428101313951.png" alt="image-20240428101313951" style="zoom:67%;"></p><h4 id="（2）例子"><a href="#（2）例子" class="headerlink" title="（2）例子"></a>（2）例子</h4><p>区分两者的区别，虽然输出结果一样</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428102114494.png" alt="image-20240428102114494" style="zoom:50%;"></p><p>1、直接屏幕输出错误信息</p><ul><li>运行test.sh后有标准输出hello world，还有标准错误command not found</li><li>将标准输出放入管道后查询command，自然没有查询到</li><li>标准错误没有被重定向，所以直接输出到屏幕</li></ul><p>2、重定向错误信息到管道，然后grep查询后输出</p><ul><li>运行test.sh后有标准输出hello world，还有标准错误command not found</li><li>将标准输出和标准错误都放入管道后查询command</li><li>查询到含有command的行，输出到屏幕</li></ul><h1 id="三、环境变量"><a href="#三、环境变量" class="headerlink" title="三、环境变量"></a>三、环境变量</h1><h2 id="1、什么是环境变量"><a href="#1、什么是环境变量" class="headerlink" title="1、什么是环境变量"></a>1、什么是环境变量</h2><h3 id="（1）变量"><a href="#（1）变量" class="headerlink" title="（1）变量"></a>（1）变量</h3><p>让某个特定的字符串代表不固定的内容就是变量</p><h3 id="（2）Linux系统的环境变量"><a href="#（2）Linux系统的环境变量" class="headerlink" title="（2）Linux系统的环境变量"></a>（2）Linux系统的环境变量</h3><ul><li>Linux是一个<strong>多用户</strong>的操作系统，每个用户登录系统后，都会有一个<strong>专用的运行环境</strong></li><li>这个<strong>运行环境是用一组环境变量来定义</strong>的。用户也可以对自己的运行环境进行定制，其方法就是修改相应的系统环境变量。</li></ul><p>打印环境变量的命令： env、 printenv</p><p>常见的环境变量如HOME，PWD，PATH等</p><h2 id="2、查看环境变量命令-env-、-printenv-、-echo"><a href="#2、查看环境变量命令-env-、-printenv-、-echo" class="headerlink" title="2、查看环境变量命令==env== 、==printenv==、==echo=="></a>2、查看环境变量命令==env== 、==printenv==、==echo==</h2><h3 id="（1）查看系统的所有环境变量及值env、printenv："><a href="#（1）查看系统的所有环境变量及值env、printenv：" class="headerlink" title="（1）查看系统的所有环境变量及值env、printenv："></a>（1）查看系统的<strong>所有</strong>环境变量及值env、printenv：</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env</span><br><span class="line">或</span><br><span class="line">printenv</span><br></pre></td></tr></tbody></table></figure><p>例：<img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428110034279.png" alt="image-20240428110034279" style="zoom:50%;"></p><h3 id="（2）查看系统的某个环境变量的值echo："><a href="#（2）查看系统的某个环境变量的值echo：" class="headerlink" title="（2）查看系统的某个环境变量的值echo："></a>（2）查看系统的<strong>某个</strong>环境变量的值echo：</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $变量名</span><br><span class="line">比如：echo $PATH</span><br></pre></td></tr></tbody></table></figure><p><code>echo</code>命令的作用是==显示字符==，<code>$</code>放在变量名前表示==引用==某个变量，不然整个配置文件都可能出问题</p><p>查看PATH：<img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428110251396.png" alt="image-20240428110251396" style="zoom:67%;"></p><p>查看HOME、SHELL：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428110346405.png" alt="image-20240428110346405" style="zoom: 67%;"></p><h2 id="3、常见的环境变量"><a href="#3、常见的环境变量" class="headerlink" title="3、常见的环境变量"></a>3、常见的环境变量</h2><ul><li><code>USER</code> - 这指的是当前登录的用户。</li><li><code>HOME</code> - 这显示了当前用户的主目录。</li><li><code>SHELL</code> - 这存储了当前用户的 shell 路径，如 bash 或 zsh。</li><li><code>LANG</code> - 这个变量指向当前的语言 /locales 设置。</li><li><code>MAIL</code> - 这显示了当前用户的邮件存储的位置。</li></ul><h3 id="（1）PATH"><a href="#（1）PATH" class="headerlink" title="（1）PATH"></a>（1）PATH</h3><ul><li><p>当输入命令的时候Linux会去查找PATH里面记录的路径</p><p>举例说明，在根目录/下可以输入命令<code>ls</code>，在<code>/usr</code>目录下也可以输入<code>ls</code>，但其实<code>ls</code>这个命令根本不在这个两个目录下，所有当你输入命令的时候Linux会去<code>/bin</code>，<code>/usr/bin</code>，<code>/sbin</code>等目录下面去找你此时输入的命令，而PATH的值恰恰就是<code>/bin:/sbin:/usr/bin:……</code>（其中的冒号使目录与目录之间隔开），一个个地查找此命令的可执行二进制文件</p><p><strong>找到了就正常执行</strong>：<img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428111546416.png" alt="image-20240428111546416" style="zoom:67%;"></p><ul><li><p>==找到第一个就会执行，不会再继续找==：</p><p>例如：<img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428114621370.png" alt="image-20240428114621370" style="zoom:50%;"></p><p>图中test文件夹和data文件夹中都有test.sh这个可执行文件，且两个test.sh文件的执行内容不同，将他们都配置到<code>/etc/profile</code>中，最后执行时，只会执行目录靠前的test.sh</p></li></ul><p><strong>没找到就显示错误</strong>：<img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428111328897.png" alt="image-20240428111328897" style="zoom:67%;"></p></li></ul><h2 id="4、如何设置环境变量-export"><a href="#4、如何设置环境变量-export" class="headerlink" title="4、如何设置环境变量==export=="></a>4、如何设置环境变量==export==</h2><p>==注意：添加到path的一定是目录、而不是可执行文件！！！==</p><p>常用的就是修改PATH环境变量和新增环境变量，修改方法举例在下面，新增环境变量方法如图：</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428114118345.png" alt="image-20240428114118345" style="zoom:67%;"></p><h3 id="（1）临时方案（常用于测试）"><a href="#（1）临时方案（常用于测试）" class="headerlink" title="（1）临时方案（常用于测试）"></a>（1）临时方案（常用于测试）</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置环境变量命令：export</span><br><span class="line">举例：修改环境变量PATH的值，增加/www/data</span><br><span class="line">命令如下：</span><br><span class="line">export PATH=$PATH:/www/data</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428112453503.png" alt="image-20240428112453503" style="zoom:67%;"></p><p>但是，直接执行这个命令设置的变量值只是临时有效的，在重启系统后会失效，如果要永久有效，需要修改配置文件</p><h3 id="（2）永久方案"><a href="#（2）永久方案" class="headerlink" title="（2）永久方案"></a>（2）永久方案</h3><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>把<code>export PATH=$PATH:/www/data</code>的命令添加到配置文件的末尾</p><p>1）如果要配置对<strong>所有用户</strong>永久生效，则添加到配置文件<code>/etc/profile</code></p><ul><li><p>进入配置文件<code>vim /etc/profile</code></p></li><li><p>添加配置文件：把可执行文件的==目录==加入其中，<code>$</code>表示引用，不可省略</p><p><img src="/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240428112934817.png" alt="image-20240428112934817" style="zoom:50%;"></p></li></ul><p>2）如果要配置对<strong>当前用户</strong>生效，则添加到配置文件<code>~/.bashrc</code></p><ul><li>步骤略</li></ul><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>执行如下命令使配置生效</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、重定向&quot;&gt;&lt;a href=&quot;#一、重定向&quot; class=&quot;headerlink&quot; title=&quot;一、重定向&quot;&gt;&lt;/a&gt;一、重定向&lt;/h1&gt;&lt;h2 id=&quot;1、标准输入、标准输出、标准错误&quot;&gt;&lt;a href=&quot;#1、标准输入、标准输出、标准错误&quot; class=&quot;headerlink&quot; title=&quot;1、标准输入、标准输出、标准错误&quot;&gt;&lt;/a&gt;1、标准输入、标准输出、标准错误&lt;/h2&gt;&lt;p&gt;执行一个shell命令行时通常会自动打开三个标准文件，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/26/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240426164557090.png&quot; alt=&quot;image-20240426164557090&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标准输入文件（stdin），通常对应终端的键盘，stdin的文件描述符为==0==，Unix程序默认从stdin读取数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标准输出文件（stdout），对应终端的屏幕，stdout 的文件描述符为==1==，Unix程序默认向stdout输出数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;标准错误输出文件（stderr），对应终端的屏幕，stderr的文件描述符为==2==，Unix程序会向stderr流中写入错误信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程将从标准输入文件中得到输入数据，将&lt;strong&gt;正常输出数据&lt;/strong&gt;输出到&lt;u&gt;标准输出文件&lt;/u&gt;，而将&lt;strong&gt;错误信息&lt;/strong&gt;送到&lt;u&gt;标准错误文件&lt;/u&gt;中&lt;/p&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Linux" scheme="https://laylaycjl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>软件测试基础</title>
    <link href="https://laylaycjl.github.io/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://laylaycjl.github.io/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</id>
    <published>2024-04-25T07:04:06.000Z</published>
    <updated>2024-05-15T14:53:24.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、目的、原则、流程、职责"><a href="#一、目的、原则、流程、职责" class="headerlink" title="一、目的、原则、流程、职责"></a>一、目的、原则、流程、职责</h1><h2 id="1、软件测试目的、概念"><a href="#1、软件测试目的、概念" class="headerlink" title="1、软件测试目的、概念"></a>1、软件测试目的、概念</h2><h3 id="（1）测试目的"><a href="#（1）测试目的" class="headerlink" title="（1）测试目的"></a>（1）测试目的</h3><ul><li>软件测试是程序的执行过程，目的在于<strong>发现错误</strong>,尽可能多的找出缺陷</li><li>软件测试的目的是确保交给用户的软件产品<strong>符合用户的需求</strong></li><li>软件测试的目的是检验软件产品是否满足用户的<strong>显性和隐性需求</strong><ul><li>显性需求:产品经理(跟客户对接、整理需求)—-》需求文档</li><li>隐形需求:按照约定俗成，应该要实现的需求（删除弹出确认对话框、金额小数点2位、密码*显示)</li></ul></li></ul><h3 id="（2）测试的概念"><a href="#（2）测试的概念" class="headerlink" title="（2）测试的概念"></a>（2）测试的概念</h3><ul><li>60-70年代梅耶执行程序，发现错误</li><li>80-90年代特定条件下操作软件，发现错误，评估质量（是否达到质量标准)</li><li>2000 IEEE 使用人工或自动化手段，来<strong>运行</strong>或<strong>测试</strong>某个系统的过程，其目的在于检验它<strong>是否满足规定的需求</strong>或<strong>弄清预期结果与实际结果之间的差别</strong>。</li></ul><span id="more"></span><h2 id="2、-软件测试的原则"><a href="#2、-软件测试的原则" class="headerlink" title="2、==软件测试的原则=="></a>2、==软件测试的原则==</h2><ul><li><p>测试证明软件存在缺陷</p><p>只能证明软件存在缺陷，而无法证明软件不存在哪些缺陷</p></li><li><p>测试不能穷尽</p><p>测试的场景和数据非常多，无法穷尽</p></li><li><p>测试的2/8现象</p><p>80%的缺陷集中在20%的模块中</p></li><li><p>测试应尽早介入</p><p>越早发现问题，修复的成本就越低</p></li><li><p>杀虫剂现象</p><p>避免杀虫剂现象，不断调整测试计划、策略、优化测试用例</p></li><li><p>避免开发测试自己的代码</p><p>避免思维定式，很难发现问题</p></li><li><p>用例包含合理和不合理的输入条件</p><p>应该有正确的和不正确的条件</p></li><li><p>所有的软件测试都应追溯到用户需求</p><p>黑盒测试（根据需求文档&lt;———客户的需求)</p></li></ul><h2 id="3、-测试流程"><a href="#3、-测试流程" class="headerlink" title="3、==测试流程=="></a>3、==测试流程==</h2><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240425201450519.png" alt="image-20240425201450519" style="zoom:80%;"></p><ul><li>1、需求分析：测试首先要对软件需求有着深入的理解，所以我们会开需求评审会议，分析和讨论需求。</li><li>2、指定测试计划：这个计划会明确测试的范围、方法、资源分配、时间表和目标。</li><li>3、测试用例设计：基于测试计划，设计详细的测试用例。这些用例应该覆盖所有功能点，包括正常情况和边界情况的测试。</li><li>4、测试用例评审</li><li>5、搭建和配置适合的测试环境，执行测试用例，记录测试结果(找bug),将在测试过程中发现的缺陷报告给开发团队</li><li>6、回归测试：每当代码发生更改后，执行回归测试以确保新的更改没有破坏现有的功能</li><li>7、性能测试:评估系统的响应时间、稳定性和扩展性。</li><li>8、部署项目到预生产环境，在预生产环境测试</li><li>9、编写测试报告，总结测试活动的结果，包括测试覆盖率、发现的缺陷和未解决的问题。</li><li>10、项目上线后，根据反馈进行复盘和总结。</li></ul><h2 id="4、软件测试对象"><a href="#4、软件测试对象" class="headerlink" title="4、软件测试对象"></a>4、软件测试对象</h2><p>程序+数据+文档</p><h2 id="5、测试的风险（5大风险）"><a href="#5、测试的风险（5大风险）" class="headerlink" title="5、测试的风险（5大风险）"></a>5、测试的风险（5大风险）</h2><ul><li><p>进度风险</p><p>开发提交测试时延迟，进度被耽误</p></li><li><p>人员风险</p><p>人员数量不够：解决方法就是加班，加人，优先级高的部分优先测试</p><p>人员技术不足：集中培训、一对一辅导、自学</p></li><li><p>成本风险</p><p>与进度、人员、质量风险都有关</p></li><li><p>质量风险</p><p>开发和测试对质量的理解不一致</p><ul><li><p>如果测试提交了一个问题，开发认为不是问题，你会怎么办？</p><p>沟通，讲清楚问题的原因，找产品经理，问题要跟踪到底</p></li></ul></li><li><p>变更风险</p><p>需求变更：新增、修改、删除</p><p>（难点在于，需求变更之后，对其他模块的影响分析，需要刷新测试用例）</p></li></ul><h2 id="6、测试工程师具备的技能"><a href="#6、测试工程师具备的技能" class="headerlink" title="6、测试工程师具备的技能"></a>6、测试工程师具备的技能</h2><ul><li>计算机相关基础知识</li><li>软件基础知识：软件生命周期，测试理论和测试方式有较深的理解</li><li>软件测试技术，方法，流程，测试文档编写，能独立设计和执行测试用例，提交完整的缺陷报告单,编写测试报告</li><li>软件开发语言：Python</li><li>数据库：MySQL，Redis</li><li>操作系统：Linux，iOS，Android，DOS</li><li>业务知识</li><li>网络基本知识，能够独立完成测试环境的搭建</li><li>学好一门或多门外语</li></ul><h2 id="7、测试人员具备素质"><a href="#7、测试人员具备素质" class="headerlink" title="7、测试人员具备素质"></a>7、测试人员具备素质</h2><p>三心二力一精神</p><ul><li>三心：细心、耐心、责任心</li><li>二力：洞察力沟通能力</li><li>—精神：团队合作精神</li></ul><h2 id="8、测试工程师的工作职责"><a href="#8、测试工程师的工作职责" class="headerlink" title="8、测试工程师的工作职责"></a>8、测试工程师的工作职责</h2><p>1、编写测试计划</p><p>2、提取测试点</p><p>3、编写测试用例</p><p>4、搭建测试环境</p><p>5、测试执行、缺陷管理</p><p>6、编写测试报告</p><h1 id="二、研发流程与模型"><a href="#二、研发流程与模型" class="headerlink" title="二、研发流程与模型"></a>二、研发流程与模型</h1><h3 id="1、软件研发流程"><a href="#1、软件研发流程" class="headerlink" title="1、软件研发流程"></a>1、软件研发流程</h3><h4 id="（1）开发流程"><a href="#（1）开发流程" class="headerlink" title="（1）开发流程"></a>（1）开发流程</h4><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240506194022031.png" alt="image-20240506194022031"></p><h4 id="（2）测试流程（简略版）"><a href="#（2）测试流程（简略版）" class="headerlink" title="（2）测试流程（简略版）"></a>（2）测试流程（简略版）</h4><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240506194055231.png" alt="image-20240506194055231" style="zoom: 50%;"></p><h4 id="（3）项目组成员"><a href="#（3）项目组成员" class="headerlink" title="（3）项目组成员"></a>（3）项目组成员</h4><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240506194313351.png" alt="image-20240506194313351" style="zoom:80%;"></p><ul><li>项目经理：对项目的进度、成本、质量、资源的管理1个(兼职其他项目)</li><li>产品经理：负责整理需求，输出需求文档(需求规格说明书、原型图)，1个(兼职其他项目)</li><li>ui设计师：ui设计，1个(兼职其他项目)</li><li>开发人员：编码、修复缺陷，开发测试人力比3/1~8/1</li><li>测试人员：测试分析—》编写测试计划—》测试设计—》编写测试用例—》执行测试、管理缺陷—-》编写测试报告等文档</li><li>架构师：负责设计软件架构</li><li>测试经理：测试团队比较大，可能分了几个测试小组，测试经理对多个测试小组进行管理和统筹</li><li>配置管理员：CMO，软件打包、项目权限管理</li><li>资料工程师：负责开发软件配套的资料</li><li>QA：质量保证，制定项目的质量体系和规范</li></ul><h3 id="2、软件的研发模型"><a href="#2、软件的研发模型" class="headerlink" title="2、软件的研发模型"></a>2、软件的研发模型</h3><p>软件研发模型是一个从软件项目需求定义开始，直至软件消亡为止，跨越整个生产周期的系统开发、运作和维护所实施的全部过程、活动和任务的结构框架。</p><ul><li>软件研发模型的目的：<ul><li>保证最终产品满足用户需求</li><li>提高产品质量，降低产品开发成本</li><li>保证项目可管理，进度可控制</li></ul></li><li>研发模型的总结<ul><li>瀑布、v和w：线性化、不可逆<br>适用的项目：军工、航天，例如微信开发操作系统</li><li>增量、迭代、敏捷：分多个周期完成，适应变化<br>适用的项目：适应变化，一开始不能明确所有的需求，例如:微信</li></ul></li></ul><h4 id="（1）-瀑布模型"><a href="#（1）-瀑布模型" class="headerlink" title="（1）==瀑布模型=="></a>（1）==瀑布模型==</h4><p>瀑布模型是一种线形的、顺序的软件开发模型</p><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240506184859204.png" alt="image-20240506184859204" style="zoom: 80%;"></p><p>线性化模型结构、各阶段具有里程碑特征、基于文档的驱动、严格的阶段评审机制</p><h5 id="1）优点"><a href="#1）优点" class="headerlink" title="1）优点"></a>1）优点</h5><ul><li><p>提供了软件开发的基本框架，比靠“个人技艺”开发好的多</p></li><li><p>有利于大型软件开发过程的人员的组织和管理</p></li><li>有利于开发方法和工具的使用</li><li>提高了软件的质量和效率</li></ul><h5 id="2）缺点"><a href="#2）缺点" class="headerlink" title="2）缺点"></a>2）缺点</h5><ul><li>初始阶段指出全部需求，可能用户和项目负责人需要很长的时间才能拿到需求版本，如果需要修改，则会蒙受损失</li></ul><h4 id="（2）V模型"><a href="#（2）V模型" class="headerlink" title="（2）V模型"></a>（2）V模型</h4><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240506185254297.png" alt="image-20240506185254297" style="zoom: 67%;"></p><h5 id="1）优点-1"><a href="#1）优点-1" class="headerlink" title="1）优点"></a>1）优点</h5><ul><li>明确标明了测试过程中存在的不同级别</li><li>清楚地描述了测试阶段与开发过程各阶段的对应关系与开发同步(引入检测机制,需求分析做的好不好，看验收测试)</li><li>V模型的测试策略既包括了低层测试(代码级的测试)，又包括了高层测试（需求级的测试)</li></ul><h5 id="2）缺点-1"><a href="#2）缺点-1" class="headerlink" title="2）缺点"></a>2）缺点</h5><ul><li>它仅仅把测试过程作为需求分析，概要设计，详细设计编码之后的一个阶段，容易让人理解为测试是软件开发的最后一个阶段。</li><li>没有明确说明早期的测试，不符合越早测试和不断地进行测试的原则(用户需求对不对要到验收测试才能发现)。</li><li>和瀑布模型一样，流程也是单向的，不可逆。</li></ul><h4 id="（3）W模型"><a href="#（3）W模型" class="headerlink" title="（3）W模型"></a>（3）W模型</h4><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240506185530615.png" alt="image-20240506185530615" style="zoom: 67%;"></p><h5 id="1）优点-2"><a href="#1）优点-2" class="headerlink" title="1）优点"></a>1）优点</h5><ul><li>符合尽早测试和不断测试的原则</li><li>符合实际工作中的测试活动</li></ul><h5 id="2）缺点-2"><a href="#2）缺点-2" class="headerlink" title="2）缺点"></a>2）缺点</h5><ul><li>W模型与V模型一样，视软件开发活动是一系列串行的活动，开发和测试保持━种线性的前后关系，这样就无法支持迭代</li></ul><h4 id="（4）增量模型"><a href="#（4）增量模型" class="headerlink" title="（4）增量模型"></a>（4）增量模型</h4><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240506185735030.png" alt="image-20240506185735030" style="zoom: 67%;"></p><p>增量模型又称为渐增模型，也称为有计划的产品改进模型，它从一组给定的需求开始，通过构造一系列可执行中间版本来实施开发活动。第一个版本纳入一部分需求，下一个版本纳入另一部分的需求,依此类推，直到系统完成。每个中间版本都要执行必需的过程、活动和任务。</p><h5 id="1）优点-3"><a href="#1）优点-3" class="headerlink" title="1）优点"></a>1）优点</h5><ul><li>可以分批次地交付产品;</li><li>降低了软件开发的风险;</li><li>开发顺序灵活。</li></ul><h5 id="2）缺点-3"><a href="#2）缺点-3" class="headerlink" title="2）缺点"></a>2）缺点</h5><ul><li>待开发的软件系统必须要能模块化，如果待开发的软件系统很难被模块化，那么将会给增量开发带来很多麻烦</li></ul><h4 id="（5）-迭代模型"><a href="#（5）-迭代模型" class="headerlink" title="（5）==迭代模型=="></a>（5）==迭代模型==</h4><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240506190021270.png" alt="image-20240506190021270" style="zoom: 67%;"></p><p>迭代模型中的每次迭代都是一次完整地经过所有工作流程的过程:需求分析、设计、实施和测试工作流程。它类似小型的瀑布模型。每一次的迭代都会产生一个可以发布的产品，这个产品是最终产品的一个子集</p><ul><li>与增量的区别：</li></ul><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240506190157952.png" alt="image-20240506190157952" style="zoom:50%;"></p><ul><li><p>迭代周期的划分原则</p><p>每个迭代的周期长短依据该迭代工作量的不同而不同，如果工作量小，一周可以有两个迭代。如果工作量大，可能4周一个迭代</p></li><li><p>每个迭代实现模块优先级的确定原则</p><p>产品核心功能、能够给用户带来最大利益的功能，需要在前面的迭代中实现</p></li></ul><h5 id="1）优点-4"><a href="#1）优点-4" class="headerlink" title="1）优点"></a>1）优点</h5><ul><li>以小步快跑的方式，让产品快速进入市场;</li><li>有效提高开发工作的效率</li><li>更适应需求变化的产品。</li></ul><h5 id="2）缺点-4"><a href="#2）缺点-4" class="headerlink" title="2）缺点"></a>2）缺点</h5><ul><li>可能会导致产品被多次更改;</li><li>可能会增加成本;</li><li>可能会导致项目交付日期不确定</li></ul><h4 id="（6）-敏捷开发模型"><a href="#（6）-敏捷开发模型" class="headerlink" title="（6）==敏捷开发模型=="></a>（6）==敏捷开发模型==</h4><p>敏捷开发没有明确告诉我们到底采用什么样的流程进行开发，而Scrum就是敏捷开发思想中最为出名、使用最广的流程框架：</p><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240506191048015.png" alt="image-20240506191048015" style="zoom:80%;"></p><p>敏捷开发：以人为核心，适应变化，迭代，循序渐进的开发方法</p><p>敏捷开发的理念：1、个体和交互，胜过过程和工具。2、可以工作的软件，胜过面面俱到的文档。3．客户合作，胜过合同谈判。4．响应变化，胜过遵循计划</p><p>敏捷开发核心价值观：沟通、简单、反馈、勇气、尊重</p><p>==敏捷开发角色==：</p><ul><li>product owner(产品经理):整理User story</li><li>master(项目经理)︰制定项目计划、召开相关会议（迭代计划会议、每日站会、演示会议、迭代回顾会议)、分配Story开发任务、关注进度</li><li>Team(研发团队):主要是开发和测试人员</li></ul><p>==关键词==:</p><ul><li>product Backlog:所有用户故事</li><li>print Backlog:某轮迭代的用户故事</li><li>User story:用户故事</li><li>Daily meeting:每日站会</li><li>sprint burn down:燃尽图</li><li>Reviewing meeting:迭代回顾会议</li></ul><p>==Scrum的基本流程==</p><ul><li>产品负责人负责整理user story，形成左侧的product backlog。</li><li>发布计划会议：product owner负责讲解user story，对其进行估算和排序，发布计划会议的产出就是制定出这一期迭代要完成的story列表sprint backlog。</li><li>迭代计划会议：项目团队对每一个story进行任务分解，分解的标准是完成该story的所有任务，终每个任务都有明确的负责人，并完成工时的<br>初估计。</li><li>每日例会：每天scrum master召集站立会议，团队成员回答昨天做了什么今天计划做什么，有什么问题。</li><li>演示会议：迭代结束之后，召开演示会议，相关人员都受邀参加，团队负责向大家展示本次迭代取得的成果。期间大家的反馈记录下来，由product owner整理，形成新的story。</li><li>回顾会议：项目团队对本期迭代进行总结，发现不足，制定改进计划，下一次迭代继续改进，已达到持续改进的效果。</li></ul><h5 id="1）优点-5"><a href="#1）优点-5" class="headerlink" title="1）优点"></a>1）优点</h5><ul><li>投资回报率高;</li><li>精确要求，精准成果;</li><li>团队工作效率高</li></ul><h5 id="2）缺点-5"><a href="#2）缺点-5" class="headerlink" title="2）缺点"></a>2）缺点</h5><ul><li>适用于小型项目;</li><li>可能缺乏必要的设计和文档;</li></ul><h1 id="三、测试分类"><a href="#三、测试分类" class="headerlink" title="三、测试分类"></a>三、测试分类</h1><h2 id="（1）从是否执行程序"><a href="#（1）从是否执行程序" class="headerlink" title="（1）从是否执行程序"></a>（1）从是否执行程序</h2><h3 id="1）静态测试"><a href="#1）静态测试" class="headerlink" title="1）静态测试"></a>1）静态测试</h3><p>不运行被测试的软件，而只是静态的检查代码、界面或者文档</p><div class="table-container"><table><thead><tr><th>方式</th><th>执行人</th><th>检查内容</th><th>检测过程</th></tr></thead><tbody><tr><td>桌面检查</td><td>程序员</td><td>对源程序代码进行分析、检验，并补充相关的文档，发现程序中的错误</td><td></td></tr><tr><td>代码审查</td><td>程序员和测试员组成的审查小组</td><td>通过阅读、讨论和争议，以程序进行静态分析的过程</td><td>第一步：小组成员提前阅读设计规格书、程序文本等相关文档<br>第二步：召开程序审查会，开发人员读程序审查小组讨论、发现、解决问题</td></tr><tr><td>走查</td><td>程序员和测试员组成的审查小组</td><td>汤过逻辑运行程序，发现问题</td><td>第—步：小组成员提前阅读设计规格书、程序文本等相关文档<br>第二步：利用测试用例，使程序逻辑运行,记录程序的踪迹，发现、讨论、解决问题</td></tr></tbody></table></div><h3 id="2）-动态测试"><a href="#2）-动态测试" class="headerlink" title="2）==动态测试=="></a>2）==动态测试==</h3><p>实际运行被测试的软件，输入相应的测试数据，检查实际的输出结果是否和页其期结果相—致的过程</p><h2 id="（2）从测试实现方法"><a href="#（2）从测试实现方法" class="headerlink" title="（2）从测试实现方法"></a>（2）从测试实现方法</h2><h3 id="1）-手工测试"><a href="#1）-手工测试" class="headerlink" title="1）==手工测试=="></a>1）==手工测试==</h3><p>是指由人根据用例进行数据输入，并分析判断测试结果的方式</p><h3 id="2）自动化测试"><a href="#2）自动化测试" class="headerlink" title="2）自动化测试"></a>2）自动化测试</h3><p>是指由程序实现的工具代替人进行测试条件预置、程序运行、测试结果分析判断的方式</p><h2 id="（3）从阶段划分"><a href="#（3）从阶段划分" class="headerlink" title="（3）从阶段划分"></a>（3）从阶段划分</h2><h3 id="1）单元测试（了解）"><a href="#1）单元测试（了解）" class="headerlink" title="1）单元测试（了解）"></a>1）单元测试（了解）</h3><p>单元测试(unit testing)，是指对软件中的最小可测试单元进行检查和验证</p><ul><li><p>对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。</p></li><li><p>总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p></li></ul><p>单元测试包含内容：</p><ul><li>入口和出口函数</li><li>输入和输出信息</li><li>错误处理信息</li><li>部分边界数值测试</li></ul><h3 id="2）集成测试（了解）"><a href="#2）集成测试（了解）" class="headerlink" title="2）集成测试（了解）"></a>2）集成测试（了解）</h3><p>什么是集成测试？</p><ul><li>集成测试(integration testing)，也叫组装测试或联合测试。</li><li>在单元测试的基础上，将所有模块按照设计要求(如根据结构图〕组装成为子系统或系统，进行集成测试</li><li>实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。程序在某些局部反映不出来的问题，在全局上很可能暴露出来，影响功能的实现</li></ul><p>集成测试的两种方法</p><ul><li><p>1.非增量式集成（一次性测试）</p></li><li><p>2.增量式集成</p><p>自顶向下增量式测试——桩程序</p><p>自底向上增量式测试——驱动程序</p></li></ul><h3 id="3）-系统测试"><a href="#3）-系统测试" class="headerlink" title="3）==系统测试=="></a>3）==系统测试==</h3><p>什么是系统测试：</p><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240514224227256.png" alt="image-20240514224227256" style="zoom:67%;"></p><p>System Testing：将已经确认的软件、计算机硬件、外设、网络等其他元素结合在一起，进行信息系统的各种组装测试和确认测试</p><ul><li>系统测试是针对整个产品系统进行的测试</li><li>目的是验证系统是否满足了需求规格的定义，找出与需求规格不符或与之矛盾的地方，从而提出更加完善的方案</li><li>系统测试发现问题之后要经过调试找出错误原因和位置，然后进行改正。是基于系统整体需求说明书的<strong>黑盒类测试</strong>，应覆盖系统所有联合的部件</li><li>对象不仅仅包括需测试的软件，还要包含软件所依赖的<strong>硬件</strong>、<strong>外设</strong>甚至包括某些<strong>数据</strong>、某些<strong>支持软件及其接口</strong>等</li></ul><h4 id="1-功能测试"><a href="#1-功能测试" class="headerlink" title="1))功能测试"></a>1))功能测试</h4><p> 软件功能是否实现、实现的是否准确、是否符合《需求规格说明书》中的功能</p><h4 id="2-性能测试"><a href="#2-性能测试" class="headerlink" title="2))性能测试"></a>2))性能测试</h4><p> 主要测试系统运行时的各种指标（CPU、内存、点击率、用户并发量、吞吐量等）</p><h4 id="3-负载测试"><a href="#3-负载测试" class="headerlink" title="3))==负载测试=="></a>3))==负载测试==</h4><ul><li>性能测试的一种，不断给系统施加压力，检测系统的最大承受能力</li><li>指通过对被测系统不断地加压，直到超过预定的指标（比如响应时间要求小于2s）或者部分资源已经<strong>达到了一种饱和状态不能再加压为止</strong>。</li></ul><p>说明：</p><font color="red">1.负载测试的目的是找系统的<u>最佳拐点</u>，负载测试是最常进行的性能测试</font><font color="red">2.负载测试通常通过阶梯加压的方式来实现</font><h4 id="4-压力测试"><a href="#4-压力测试" class="headerlink" title="4))==压力测试=="></a>4))==压力测试==</h4><ul><li>性能测试的一种，不断给系统施加压力，在<strong>饱和状态</strong>下运行一段时间，来验证系统的最大承受能力</li><li>压力测试与负载测试有点类似，但两者的<strong>目的不一样</strong><ul><li>负载测试的目的是找性能的<u>最佳拐点</u>（最佳性能点）</li><li>压力测试的目的是找到把<u>系统压崩溃（不可用）的最大并发用户数</u>。</li></ul></li><li>压力测试做之前<strong>先做负载测试</strong>，先通过负载测试的最佳拐点，然后继续压，找到压垮系统的最大点</li></ul><h4 id="5-稳定性测试"><a href="#5-稳定性测试" class="headerlink" title="5))稳定性测试"></a>5))稳定性测试</h4><ul><li>又称可靠性测试，主要是通过长时间（7*24 小时）模拟被测系统的测试负载，来<u>观察系统在长期运行过程中是否有潜在的问题</u></li><li>通过对系统指标的监控，稳定性测试可以发现诸如内存泄漏、资源非法占用等问题</li></ul><p>说明：</p><p>1、在稳定性测试时，需要模拟一定的流量，但也不是极限的流量。</p><p>2、长时间运行，最好7*24小时</p><h4 id="6-兼容性测试"><a href="#6-兼容性测试" class="headerlink" title="6))兼容性测试"></a>6))兼容性测试</h4><p>软件兼容性主要考虑：常见系统：BS架构、CS架构（APP）</p><p>BS：浏览器兼容（举例：在chrome上）</p><p>CS：在不同的操作系统上，屏幕大小和分辨率</p><h4 id="7-容量测试"><a href="#7-容量测试" class="headerlink" title="7))容量测试"></a>7))容量测试</h4><p>面向数据的测试，测试系统的最大承载的数据量</p><h4 id="8-数据备份测试"><a href="#8-数据备份测试" class="headerlink" title="8))数据备份测试"></a>8))数据备份测试</h4><p>系统出现故障时候，备份数据的能力（手工备份，自动备份）</p><h4 id="9-失效恢复测试"><a href="#9-失效恢复测试" class="headerlink" title="9))失效恢复测试"></a>9))失效恢复测试</h4><p> 系统故障后，恢复系统的能力（完整性、恢复的时间）</p><h4 id="10-可用性测试"><a href="#10-可用性测试" class="headerlink" title="10))可用性测试"></a>10))可用性测试</h4><p>检查系统或软件的易用性和可操作性 （微信和QQ，微信为啥使用比较广泛，易用性好）</p><h4 id="11-健壮性测试"><a href="#11-健壮性测试" class="headerlink" title="11))健壮性测试"></a>11))健壮性测试</h4><p>测试系统在出现故障时，是否能够自动恢复或者忽略故障继续运行（输入用户名是5位，不会异常，而且会有提示信息）</p><h4 id="12-安装测试"><a href="#12-安装测试" class="headerlink" title="12))安装测试"></a>12))安装测试</h4><p>是否能够安装、是否按照正确的路径安装、是否有良好的信息提示，安装中是否有残留的文件、是否能取消安装、再次安装，是否可以更新安装、修复、卸载。</p><h4 id="13-配置测试"><a href="#13-配置测试" class="headerlink" title="13))配置测试"></a>13))配置测试</h4><p>面向硬件。检查系统硬件之间的配合。(这个软件适用的最优硬件配置，玩游戏的时候，有推荐配置)</p><h4 id="14-文档测试"><a href="#14-文档测试" class="headerlink" title="14))文档测试"></a>14))文档测试</h4><p>《用户手册》《帮助文档》</p><h4 id="15-在线帮助测试"><a href="#15-在线帮助测试" class="headerlink" title="15))在线帮助测试"></a>15))在线帮助测试</h4><p>验证系统提供的实时咨询服务的可操作性</p><h4 id="16-GUI测试-graphical-User-interface"><a href="#16-GUI测试-graphical-User-interface" class="headerlink" title="16))GUI测试(graphical User interface)"></a>16))GUI测试(graphical User interface)</h4><p>图形用户界面，主要测试菜单、按钮、文本框，测试页面实现是否和UI一致</p><h4 id="17-安全性测试"><a href="#17-安全性测试" class="headerlink" title="17))安全性测试"></a>17))安全性测试</h4><p>非法或者非正常途径入侵系统时，检查系统的保护和防御机制</p><h3 id="4）-验收测试"><a href="#4）-验收测试" class="headerlink" title="4）==验收测试=="></a>4）==验收测试==</h3><ul><li><p>什么是验收测试</p><ul><li>它是一项确定产品是否能够满足合同或用户所规定需求的测试。这是管理性和防御性控制</li><li>主要确认软件是否按合同要求进行工作，既是否满足软件需求规格说明书中的要求</li></ul></li><li><p>验收测试包括两种方法</p><p>1．非正式的验收测试</p><ul><li>α测试：<strong>内测</strong>，公司内部组织的、选择<strong>客户代表</strong>进行验收，发现问题、修改问题</li><li>β测试：<strong>公测</strong>，软件公司组织，挑选<strong>典型客户</strong>来测试，反馈问题、修改问题</li></ul><p>2．正式的验收测试</p><ul><li>客户来测。有正规的测试过程，需要制定测试计划、定义测试方案、选择测试用例，进行测试，结果提交</li><li>着重考虑软件是否满足合同规定的所有功能和性能，文档资料是否完整、准确，人机界面和其他方面</li></ul></li></ul><h2 id="（4）从介入代码的程度"><a href="#（4）从介入代码的程度" class="headerlink" title="（4）从介入代码的程度"></a>（4）从介入代码的程度</h2><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240506200552294.png" alt="image-20240506200552294" style="zoom: 67%;"></p><h3 id="1）-黑盒测试"><a href="#1）-黑盒测试" class="headerlink" title="1）==黑盒测试=="></a>1）==黑盒测试==</h3><p>把软件看成一个黑盒子，不管内部逻辑和内部特性，只依据规格说明书检查程序的功能是否符合功能说明又称为功能测试或数据驱动测试</p><ul><li><p>优点</p><p>1.对较大的代码单元来说，黑盒测试比白盒测试的效率高</p><p>2.测试人员不需要了解实现的细节，包括特定的编程语言</p><p>3.测试人员和编程人员是相互独立的</p><p>4.从用户的角度进行测试，很容易被接受和理解</p><p>5.有助于暴露任何与规格不一致或者歧异的地方</p><p>6.测试用例可以在规格完成后马上进行</p></li><li><p>缺点</p><p>1.不能测试程序内部特定部位</p><p>⒉程序未执行的代码无法发现</p><p>3.没有清晰的和简明的规格</p></li></ul><h3 id="2）白盒测试"><a href="#2）白盒测试" class="headerlink" title="2）白盒测试"></a>2）白盒测试</h3><p>又称为结构测试或逻辑驱动测试。着重于程序内部结构和算法，不关心功能和性能指标</p><ul><li><p>优点</p><p>1.迫使测试人员去了解软件的实现</p><p>2.检测代码中的每条路径和分支</p><p>3.揭示隐藏在代码中的错误</p><p>4.对代码的测试进行比较彻底</p></li><li><p>缺点</p><p>1.白盒测试投入较大，成本较高</p><p>2.白盒测试不验证规格的正确性</p><p>3.无法检查代码中遗漏的路径和数据敏感性错误</p></li></ul><h3 id="3）灰盒测试"><a href="#3）灰盒测试" class="headerlink" title="3）灰盒测试"></a>3）灰盒测试</h3><p>介于白盒和黑盒测试之间，基于程序运行时刻的外部表现同时又结合程序内部逻辑结构来设计用例，执行程序并采集程序路径执行信息和外部用户接口结果的测试技术</p><h2 id="（5）其它类型"><a href="#（5）其它类型" class="headerlink" title="（5）其它类型"></a>（5）其它类型</h2><h3 id="1）-冒烟测试"><a href="#1）-冒烟测试" class="headerlink" title="1）==冒烟测试=="></a>1）==冒烟测试==</h3><p>是对软件基本的功能进行测试，测试的对象是每一个新编译的需要正式测试的软件版本，目的是确认软件基本的功能正常，保证软件系统能跑的起来，可以进行后续的正式测试工作。</p><h3 id="2）发散测试"><a href="#2）发散测试" class="headerlink" title="2）发散测试"></a>2）发散测试</h3><p>是指测试人员基于对被测对象的理解，在不受测试计划、测试用例等相关规则的约束进行的自由测试。</p><h3 id="3）探索性测试"><a href="#3）探索性测试" class="headerlink" title="3）探索性测试"></a>3）探索性测试</h3><p>是指在对测试对象进行测试的同时学习测试对象，并设计测试，在测试过程中利用对测试对象的理解来设计更好的测试。其典型的过程如下图所示：</p><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240506201323169.png" alt="image-20240506201323169" style="zoom:50%;"></p><h3 id="4）-回归测试"><a href="#4）-回归测试" class="headerlink" title="4）==回归测试=="></a>4）==回归测试==</h3><p>是指软件bug被修改后，进行的测试，以确认原来的bug已经被解决，并且没有因为此次修改而引入新的bug</p><h1 id="四、软件八大质量特性"><a href="#四、软件八大质量特性" class="headerlink" title="四、软件八大质量特性"></a>四、软件八大质量特性</h1><p><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240515093015096.png" alt="image-20240515093015096"></p><ul><li>QA即英文quality assurance的简称，中文意思是质量保证<ul><li>QA是流程的监督者，职责是创建和执行 改进软件开发过程，并防止软件缺陷发生的标准和方法</li></ul></li><li>QC即英文quality control的简称，中文意义是质量控制<ul><li>QC就是测试人员，职责是尽可能早地发现软件的缺陷，并确保缺陷得到修复（有些企业里，测试人员被称为SQA）</li></ul></li><li>QC和QA的主要区别：前者是<strong>保证产品质量符合规定</strong>，后者是<strong>建立体系并确保体系按要求运作，以提供内外部的信任</strong></li></ul><h2 id="1、功能性"><a href="#1、功能性" class="headerlink" title="1、功能性"></a>1、功能性</h2><p>当软件在指定条件下使用时，软件产品提供满足<strong>明确</strong>和<strong>隐含</strong>要求的功能的能力</p><p>（1）<strong>适合性</strong>：软件为指定任务和用户目标，提供了一组合适功能的能力</p><p>（2）<strong>准确性</strong>：软件系统提供给用户的功能是否满足用户对该功能的精确度要求</p><p>（3）<strong>互操作性</strong>：软件系统和一个或多个周边系统进行信息交互的能力</p><p>（4）<strong>功能性的依从性</strong>：遵循相关的标准（国际标准、国家标准、行业标准、企业内部规范等)约定或法规以及类似规定的能力</p><h2 id="2、安全性"><a href="#2、安全性" class="headerlink" title="2、安全性"></a>2、安全性</h2><ul><li>软件系统保护信息和数据的能力：两个方面</li></ul><blockquote><p>Ⅰ、防止未得到授权的人或系统访问相关的信息或数据</p><p>Ⅱ、保证得到授权的人或系统能正常访问相关的信息或数据</p></blockquote><ul><li>常见的安全性测试：</li></ul><p>（1）<strong>用户验证</strong>：登录密码验证、IP地址访问限制等</p><p>（2）<strong>用户权限管理</strong>：验证低级别用户是否具有了高级别用户的权限，各级别用户权限都得到了实现</p><p>（3）<strong>系统数据的保护</strong>：对例如系统文件、用户密码文件等进行隐藏、密码验证、内容加密、备份</p><p>（4）<strong>加密、解密</strong></p><p>（5）<strong>防DoS攻击（拒绝服务）</strong>：Denial of Service</p><ul><li>dos攻击的两种情形示例<ul><li><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240515190742684.png" alt="image-20240515190742684" style="zoom:50%;"></li><li><img src="/2024/04/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/image-20240515191035662.png" alt="image-20240515191035662" style="zoom:50%;"></li></ul></li><li>解决方法：限制请求次数</li><li>如何验证是否有防Dos攻击手段：首先要分析业务处理中哪些会消耗大量资源，哪些的响应时间特别长，针对这类业务有目的地去验证是否有防Dos攻击手段</li></ul><h2 id="3、可靠性"><a href="#3、可靠性" class="headerlink" title="3、可靠性"></a>3、可靠性</h2><ul><li><p>可靠性，是指在特定的条件下使用时，软件产品维持规定的性能级别的能力</p></li><li><p>可靠性三要素：<strong>规定的环境</strong>、<strong>规定的时间</strong>、<strong>规定的性能</strong></p></li><li><p>可靠性的四大子特性：</p><ul><li><strong>成熟性</strong>：软件为避免由软件中的错误而导致软件失效的能力</li><li><strong>容错性</strong>：软件出现故障或者违反了制定接口的情况（例如：检查外部传进来的指针是否非空、或者外部传进来的参数是否合法）</li><li><strong>易恢复性</strong>：系统失效后重新恢复原有功能、性能的能力（恢复程度、恢复速度）</li><li><strong>可靠性依从性</strong>：遵循相关的标准（国际标准、国家标准、行业标准、企业内部规范等)约定或法规以及类似规定的能力</li></ul></li></ul><h2 id="4、易用性"><a href="#4、易用性" class="headerlink" title="4、易用性"></a>4、易用性</h2><p>在指定条件下使用时，软件产品被理解、学习、使用和吸引用户的能力</p><p>（1）<strong>易理解性</strong></p><p>用户在使用软件系统的过程中，系统交互给用户的信息是否准确、清晰、易懂，能帮助</p><p>用户准确理解系统当前真实的状态，指导其进一步的操作</p><p>（2）<strong>易学性</strong></p><p>软件系统提供相关辅助手段，帮助用户学习使用它的能力（用户手册，在线帮助）</p><p>（3）<strong>易操作性</strong></p><p>软件使用户能操作和控制它的能力</p><p>（4）<strong>吸引性</strong></p><p>软件吸引用户的能力，美观的UI设计、新颖实用的功能</p><p>（5）<strong>易用性的依从性</strong></p><p>遵循相关的标准（国际标准、国家标准、行业标准、企业内部规范等)约定或法规以及类似规定的能力</p><h2 id="5、效率（性能测试）"><a href="#5、效率（性能测试）" class="headerlink" title="5、效率（性能测试）"></a>5、效率（性能测试）</h2><p>（1）<strong>时间效率</strong></p><p>系统在各业务场景下完成用户指定的业务请求所需的响应时间</p><p>eg.榨一公斤黄豆需要多长时间？</p><p>（2）<strong>资源效率</strong></p><p>系统在各业务场景下完成用户指定的业务请求所消耗的系统资源</p><p>（如：CPU使用率、内存使用率、IO、通信带宽使用等）</p><p> eg.榨一公斤黄豆在这么长的时间里耗掉我多少电，机器损耗有多大？</p><p>（3）<strong>效率依从性</strong></p><p>遵循相关的标准（国际标准、国家标准、行业标准、企业内部规范等)约定或法规以及类似规定的能力</p><h2 id="6、维护性"><a href="#6、维护性" class="headerlink" title="6、维护性"></a>6、维护性</h2><p>（1）<strong>易分析性</strong></p><p>是指软件产品诊断软件中的缺陷或失效原因，以及判定待修改的部分的能力 </p><p>例如：  软件系统提供辅助手段帮助开发人员分析、识别缺陷、失效产生的原因，找出待修复部分的能力，降低缺陷定位的成本（例子：软件的日志功能）</p><p>（2）<strong>易改变性</strong></p><p>是指软件产品使指定的修改可以被实现的能力</p><p>（3）<strong>稳定性</strong></p><p>稳定性，是指软件产品避免由于软件修改而造成意外结果的能力</p><p>例如：代码中的有物理含义的数字，一定要用变量代替</p><p>（4）<strong>易测试性</strong>（降低发现缺陷的成本）</p><p>  是指软件产品使已修改软件能被确认的能力</p><p>①软件可控制：软件系统提供辅助手段帮助测试工程师控制该系统的运行，实现其测</p><p>试执行步骤的能力（如：API测试，通过打点、改变内部状态、值等手段）</p><p>②可观察：</p><p> 软件系统提供辅助手段帮助测试工程师获得充分的系统运行信息，以正确判断系统运行状态和测试执行结果的能力</p><p> a、设计单独的测试模式</p><p> b、提供单独的测试版本（如：测试版本上打开日志功能）</p><p>（5）<strong>维护性的依从性</strong></p><p>  遵循相关的标准（国际标准、国家标准、行业标准、企业内部规范等)约定或法规以及类似规定的能力</p><h2 id="7、可移植性"><a href="#7、可移植性" class="headerlink" title="7、可移植性"></a>7、可移植性</h2><p>（1）<strong>适应性</strong></p><p>软件系统无需做任何相应变动就能适应不同运行环境（操作系统平台、数据库平台、硬件平台等）的能力</p><ul><li>解决平台无关、可移植性问题的一个常用思路是构造出一个虚拟层，虚拟层将下层细节屏蔽，对上层提供统一口（例如：JAVA，JVM）</li></ul><p>（2）<strong>易安装性</strong></p><p>易安装性，是指软件产品在指定环境中被安装的能力</p><ul><li>例子：软件的安装类型是文本界面，还是图形导向</li></ul><p>（3）<strong>共存性</strong></p><p>软件系统和在公共环境与其共享资源的其他系统共存的能力</p><ul><li><p>测试不仅需要关注自身特性的实现，还要关注本软件是否影响了其</p><p>他软件的正常功能</p></li></ul><p>（4）<strong>易替换性</strong></p><p>是指软件产品在环境相同、目的相同的情况下替代另一个指定软件产品的能力</p><ul><li>例如：软件系统升级的能力，在线升级、打补丁升级等</li></ul><p>（5）<strong>可移植性的依从性</strong></p><p>遵循相关的标准（国际标准、国家标准、行业标准、企业内部规范等)约定或法规以及类似规定的能力</p><h2 id="8、兼容性"><a href="#8、兼容性" class="headerlink" title="8、兼容性"></a>8、兼容性</h2><div class="table-container"><table><thead><tr><th>架构</th><th>兼容性测试内容</th><th>优势</th><th>劣势</th><th>说明</th></tr></thead><tbody><tr><td>BS架构</td><td>不同浏览器的兼容性</td><td>可维护性比较好</td><td>性能相对差一些</td><td>浏览器—&gt;前端—&gt;后端架构的原因，导致性能相对差一些</td></tr><tr><td>CS架构</td><td>操作系统、屏幕大小、分辨率</td><td>性能比较好</td><td>维护性不太好</td><td>发布了新版本，APP需要升级，同时APP上架还需要审核（IOS需要一周时间审核）</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、目的、原则、流程、职责&quot;&gt;&lt;a href=&quot;#一、目的、原则、流程、职责&quot; class=&quot;headerlink&quot; title=&quot;一、目的、原则、流程、职责&quot;&gt;&lt;/a&gt;一、目的、原则、流程、职责&lt;/h1&gt;&lt;h2 id=&quot;1、软件测试目的、概念&quot;&gt;&lt;a href=&quot;#1、软件测试目的、概念&quot; class=&quot;headerlink&quot; title=&quot;1、软件测试目的、概念&quot;&gt;&lt;/a&gt;1、软件测试目的、概念&lt;/h2&gt;&lt;h3 id=&quot;（1）测试目的&quot;&gt;&lt;a href=&quot;#（1）测试目的&quot; class=&quot;headerlink&quot; title=&quot;（1）测试目的&quot;&gt;&lt;/a&gt;（1）测试目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;软件测试是程序的执行过程，目的在于&lt;strong&gt;发现错误&lt;/strong&gt;,尽可能多的找出缺陷&lt;/li&gt;
&lt;li&gt;软件测试的目的是确保交给用户的软件产品&lt;strong&gt;符合用户的需求&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;软件测试的目的是检验软件产品是否满足用户的&lt;strong&gt;显性和隐性需求&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;显性需求:产品经理(跟客户对接、整理需求)—-》需求文档&lt;/li&gt;
&lt;li&gt;隐形需求:按照约定俗成，应该要实现的需求（删除弹出确认对话框、金额小数点2位、密码*显示)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;（2）测试的概念&quot;&gt;&lt;a href=&quot;#（2）测试的概念&quot; class=&quot;headerlink&quot; title=&quot;（2）测试的概念&quot;&gt;&lt;/a&gt;（2）测试的概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;60-70年代梅耶执行程序，发现错误&lt;/li&gt;
&lt;li&gt;80-90年代特定条件下操作软件，发现错误，评估质量（是否达到质量标准)&lt;/li&gt;
&lt;li&gt;2000 IEEE 使用人工或自动化手段，来&lt;strong&gt;运行&lt;/strong&gt;或&lt;strong&gt;测试&lt;/strong&gt;某个系统的过程，其目的在于检验它&lt;strong&gt;是否满足规定的需求&lt;/strong&gt;或&lt;strong&gt;弄清预期结果与实际结果之间的差别&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试基础" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux概述与常用命令</title>
    <link href="https://laylaycjl.github.io/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://laylaycjl.github.io/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2024-04-24T11:19:20.000Z</published>
    <updated>2024-04-27T13:29:17.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、操作系统"><a href="#一、操作系统" class="headerlink" title="一、操作系统"></a>一、操作系统</h2><ul><li><p>操作系统（Operating System，OS）：管理硬件和应用程序的一套==系统软件==。</p></li><li><p>操作系统的作用： CPU管理、内存管理、文件系统管理、进程管理、外设管理、用户管理…（<em>理解：表现出来就是让CPU可以开始判断逻辑与运算数值，让内存可以开始加载/读出数据与程序代码，让硬盘可以开始被访问，让网卡可以开始传输数据，让所有周边设备可以开始运转等，总之硬件的所有操作都必须要通过操作系统来完成。</em>）</p></li><li><p>一个操作系统的核心叫==内核==，操作系统的各项功能都是通过内核实现的。</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424195236588-1714013539134.png" style="zoom:50%;"></p></li></ul><h3 id="1、常见的操作系统："><a href="#1、常见的操作系统：" class="headerlink" title="1、常见的操作系统："></a>1、常见的操作系统：</h3><ul><li>DoS：个人电脑；</li><li>Windows：个人电脑，Windows7、Windows10、WindowsServer；</li><li>Mac OS X：MacBook系列笔记本；</li><li>Android：安卓手机、平板、机顶盒、智能电视机、手环；</li><li>ios：iPhone、iPad、iWatch、iPod等；</li><li>Unix（服务器）</li><li>Linux：免费、可靠、安全、稳定、多平台；（服务器）</li></ul><h3 id="2、操作系统之间的关系"><a href="#2、操作系统之间的关系" class="headerlink" title="2、操作系统之间的关系"></a>2、操作系统之间的关系</h3><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424195349886.png" alt="image-20240424195349886" style="zoom:67%;"></p><h3 id="3、主要学习Linux原因："><a href="#3、主要学习Linux原因：" class="headerlink" title="3、主要学习Linux原因："></a>3、主要学习Linux原因：</h3><ul><li>大部分软件都运行在Linux上<ul><li>Linux作为服务器的操作系统，大部分软件都运行在Linux操作系统上;</li><li>互联网Web服务、物联网、车联网、大数据、云计算服务、人工智能、智能运维等各个方面都广泛应用;</li></ul></li><li>工作中要用Linux</li></ul><span id="more"></span><h2 id="二、Linux系统简介"><a href="#二、Linux系统简介" class="headerlink" title="二、Linux系统简介"></a>二、Linux系统简介</h2><h3 id="1、Linux系统结构"><a href="#1、Linux系统结构" class="headerlink" title="1、Linux系统结构"></a>1、Linux系统结构</h3><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424195322986.png" alt="image-20240424195322986" style="zoom: 67%;"></p><p>kernel——内核（所有命令最终由内核完成）</p><p>shell——<strong>负责接受命令，然后找到该命令对应的二进制文件</strong></p><p>file system——文件系统（组织和管理系统文件）</p><p>users application——应用程序</p><h3 id="2、Linux发行版本"><a href="#2、Linux发行版本" class="headerlink" title="2、Linux发行版本"></a>2、Linux发行版本</h3><p>各种组织或单位采用Linux内核和GNU工具集以及各类软件，编译及包装成自己所谓的Linux发行版（就像安卓)</p><ul><li>一类是<strong>商业公司</strong>维护的发行版本：以Redhat企业版（RHEL)为代表<ul><li>Redhat系列: RHEL ( Redhat Enterprise Linux ) 、Fedora Core、OpenSUSE(德国著名Linux)</li></ul></li><li><p>一类是<strong>社区组织</strong>维护的发行版本：以CentOS、Debian为代表</p><ul><li>Debian系列: Debian、Ubuntu、CentOS (RHEL的社区克隆版本，免费)不同系列的内核都是采用Linux内核，大部分命令相同，部分命令不一样</li></ul></li></ul><h3 id="3、Linux系统特点"><a href="#3、Linux系统特点" class="headerlink" title="3、Linux系统特点"></a>3、Linux系统特点</h3><ul><li>多用户：同时支持多个用户登录使用_(用户管理)<ul><li>与win的明显差异，支持多用户是Linux的一大特点</li></ul></li><li>多任务：多个任务（程序）可以同时运行（与Windows类似)·安全:源代码开源，有问题可以及时发现和优化</li><li>源码公开：任何人、组织只要遵守官方许可条款，就可以自由使用Linux源代码</li><li>广泛的硬件/软件支持：常见的应用先为Linux版本开发，后续才移植到其他平台</li><li>强大的命令、工具</li><li>稳定：可以长时间地稳定运行</li></ul><h3 id="4、Linux系统在软件测试中的应用"><a href="#4、Linux系统在软件测试中的应用" class="headerlink" title="4、Linux系统在软件测试中的应用"></a>4、Linux系统在软件测试中的应用</h3><ul><li><p>Linux作为操作系统在企业中广泛使用</p></li><li><p>大量的公司项目软件安装在Linux操作系统上</p></li><li><p>公司软件运行过程中出现问题，需要运用Linux知识去排查和解决</p><p>如：==a.网络故障排查、b.程序状态查看、c.定时启动一个程序、d.<strong>查看日志</strong>(重点)、e.软件安装/卸载、f.程序配置文件修改==</p></li></ul><p>（重点学Linux怎么看日志，方便定位问题）</p><h2 id="三、Linux指令"><a href="#三、Linux指令" class="headerlink" title="三、Linux指令"></a>三、Linux指令</h2><h3 id="1、Linux系统登录"><a href="#1、Linux系统登录" class="headerlink" title="1、Linux系统登录"></a>1、Linux系统登录</h3><ul><li><p>本地登录</p></li><li><p>远程登录：通过远程登录工具登录，如SecureCRT/Xshell/putty等</p></li></ul><p><strong>远程无法登录时，去查看虚拟机分配的ip地址是否改变</strong></p><h3 id="2、Linux运行级别（runlevel）"><a href="#2、Linux运行级别（runlevel）" class="headerlink" title="2、Linux运行级别（runlevel）"></a>2、Linux运行级别（runlevel）</h3><h4 id="（1）0-6级别"><a href="#（1）0-6级别" class="headerlink" title="（1）0-6级别"></a>（1）0-6级别</h4><blockquote><p><strong>0： 系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</strong></p><p>1： 单用户工作状态，root权限，用于系统维护，禁止远程登陆</p><p>（超级管理员）</p><p>2： 多用户无网络状态(没有NFS) </p><p><strong>3： 多用户有网络状态(有NFS)，登陆后进入控制台==命令行模式==</strong></p><p>（默认运行级别3）</p><p>4： 系统未使用，保留 </p><p>5： 多用户有网络，登陆后进入图形GUI模式 </p><p><strong>6： 系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启</strong></p><p> <strong>动</strong></p></blockquote><h4 id="（2）修改运行级别-sudo"><a href="#（2）修改运行级别-sudo" class="headerlink" title="（2）修改运行级别==sudo=="></a>（2）修改运行级别==sudo==</h4><p>1）运行时修改，转换为3级运行模式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo init 3</span><br></pre></td></tr></tbody></table></figure><p>2）开机启动时指定运行模式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/inittab</span><br></pre></td></tr></tbody></table></figure><p>3）查看运行级别</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ runlevel</span><br><span class="line">2 3</span><br></pre></td></tr></tbody></table></figure><p> 2和3分别是刚刚的运行级别，和现在当前的运行级别</p><h3 id="3、Shell与Shell脚本"><a href="#3、Shell与Shell脚本" class="headerlink" title="3、Shell与Shell脚本"></a>3、Shell与Shell脚本</h3><h4 id="（1）Shell"><a href="#（1）Shell" class="headerlink" title="（1）Shell"></a>（1）Shell</h4><ul><li><p>Shell是一个用C语言编写的==程序==，是用户通过命令和Linux进行交互的<strong>桥梁</strong>，它接受用户从字符终端输入的命令，并<strong>调用对应的程序</strong>去执行</p></li><li><p>==Linux是通过Shell来解释执行命令（命令解释器）==</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424195554007.png" alt="image-20240424195554007" style="zoom: 80%;"></p><p>可以看到用于处理cd命令的程序在/usr/bin/cd 中，由shell来调用</p></li><li><p>Linux默认的Shell是bash</p><p>Shell种类：</p><ul><li>标准shell（ash）：是Linux 中占用系统资源最少的一个小Shell，它只包含24个内部命令，因而使用起来很不方便</li><li><strong>Bonrne Again Shell（bash）</strong>：bash是Linux系统默认使用的Shell，内部命令一共有40 个。Linux 使用它作为默认的Shell是因为它具有以下特色：1、可以使用类似DOS下面的doskey的功能，用上下方向键查阅和快速输入并修改命令。2、自动通过查找匹配的方式，给出以某字串开头的命令。3、包含了自身的帮助功能，你只要在提示符下面键入help就可以得到相关的帮助信息。</li><li>Korn shell（ksh）：该Shell最大的优点是几乎和商业发行版的ksh 完全相容，这样就可以在不用花钱购买商业版本的情况下尝试商业版本的性能。</li><li>C shell（csh）：csh 是Linux 比较大的内核，它由以William Joy 为代表的共计47 位作者编成，共有52个内部命令。该Shell其实是指向/bin/tcsh这样的一个Shell，也就是说，csh其实就是tcsh。</li></ul></li></ul><h4 id="（2）Shell脚本"><a href="#（2）Shell脚本" class="headerlink" title="（2）Shell脚本"></a>（2）Shell脚本</h4><p>shell与shell脚本的区别：</p><ul><li><p>shell是命令解释器，作用是接受终端输入的命令，找到命令对应的可执行文件运行；</p></li><li><p>shell script是shell脚本，一种为 shell 编写的脚本程序</p><ul><li>vim创建一个shell脚本：test.sh</li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200011636.png" alt="image-20240424200011636" style="zoom:67%;"></p><ul><li><p>进入test.sh，编辑脚本：cat查看脚本内容，第一行是声明：<code>#!/bin/bash</code>；然后输出hello world</p></li><li><p>运行：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200051533.png" alt="image-20240424200051533" style="zoom:80%;"></p></li></ul></li></ul><h3 id="4、Linux常用命令"><a href="#4、Linux常用命令" class="headerlink" title="4、Linux常用命令"></a>4、Linux常用命令</h3><p>==格式：命令 参数1 参数2…参数n==</p><ul><li>Linux命令由一个命令（command）和<strong>零到多个参数构成</strong>，命令和参数之间，以及参数与参数之间用空格隔开</li><li>命令和参数严格区分大小写</li></ul><h4 id="（1）-ps-用于查看进程"><a href="#（1）-ps-用于查看进程" class="headerlink" title="（1）==ps==用于查看进程"></a>（1）==ps==用于查看进程</h4><p><code>ps -e -f</code>：<code>-e</code>查看所有进程；<code>-f</code>明确显示格式</p><p><code>ps -e -f | wc -l</code>：查看进程个数</p><p>其中<code>ps -e -f</code>与<code>ps -ef</code>作用一样，即多个参数可以合并</p><h4 id="（2）-man-命令查看命令的说明和参数"><a href="#（2）-man-命令查看命令的说明和参数" class="headerlink" title="（2）==man==命令查看命令的说明和参数"></a>（2）==man==命令查看命令的说明和参数</h4><p><code>man ps</code>：查看ps命令的作用和所有参数的作用</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200143538.png" alt="image-20240424200143538" style="zoom:67%;"></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200217701.png" alt="image-20240424200217701" style="zoom: 67%;"></p><h4 id="（3）-date-查看时间"><a href="#（3）-date-查看时间" class="headerlink" title="（3）==date==查看时间"></a>（3）==date==查看时间</h4><p>默认表达式星期 月份 日 具体时间 年</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200249970.png" alt="image-20240424200249970" style="zoom: 67%;"></p><p>格式化显示时间<code>date +'%Y-%m-%d %H:%M:%S'</code></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200405547.png" alt="image-20240424200405547" style="zoom:67%;"></p><p>设置时间<code>date -s "当前时间"</code>：-s参数用于设置时间，时间为string类型</p><h4 id="（4）查看发行版本号cat-etc-release"><a href="#（4）查看发行版本号cat-etc-release" class="headerlink" title="（4）查看发行版本号cat /etc/*release"></a>（4）查看发行版本号<code>cat /etc/*release</code></h4><p>完整的写法<code>cat /etc /redhat-release</code>,两个写法作用一样，经常用星号省略</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424200554736.png" alt="image-20240424200554736" style="zoom:67%;"></p><h4 id="（5）退出登录-exit"><a href="#（5）退出登录-exit" class="headerlink" title="（5）退出登录==exit=="></a>（5）退出登录==exit==</h4><p>退出Linux之后，标记会变成红色，显示未连接到服务器，且命令行变成Windows的dos系统</p><h4 id="（6）关机和重启-init"><a href="#（6）关机和重启-init" class="headerlink" title="（6）关机和重启==init=="></a>（6）关机和重启==init==</h4><ul><li>关机命令：<code>init 0</code>、<code>poweroff</code>、<code>shutdown -h now</code>、<code>halt -p</code></li><li>重启命令：<code>init 6</code>、<code>reboot</code>、<code>shutdown -r now</code></li></ul><h2 id="四、Linux文件和文件夹操作基础"><a href="#四、Linux文件和文件夹操作基础" class="headerlink" title="四、Linux文件和文件夹操作基础"></a>四、Linux文件和文件夹操作基础</h2><h3 id="1、对比Windows目录"><a href="#1、对比Windows目录" class="headerlink" title="1、对比Windows目录"></a>1、对比Windows目录</h3><h4 id="（1）win"><a href="#（1）win" class="headerlink" title="（1）win"></a>（1）win</h4><ul><li><p>Windows的目录结构是多个<strong>并列的树状结构</strong></p><p>最顶部是不同的磁盘（分区)，如C，D文件路径都是从盘符开始</p></li><li><p>Windows文件系统里面都是文件或文件夹</p></li><li><p>Windows文件路径是大小写不区分的，层级用\表示</p></li></ul><h4 id="（2）Linux"><a href="#（2）Linux" class="headerlink" title="（2）Linux"></a>（2）Linux</h4><p>没有盘符，一切从/根目录开始，单个的树状结构</p><h3 id="2、Linux常用目录"><a href="#2、Linux常用目录" class="headerlink" title="2、Linux常用目录"></a>2、Linux常用目录</h3><ul><li><p><strong>/         Linux系统的根目录</strong></p></li><li><p><strong>==/etc==      系统管理和配置文件</strong></p><p>例如 profile就是配置文件</p></li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425095459818.png" alt="image-20240425095459818"></p><ul><li><p><strong>==/home==    用户主目录，比如jack用户的主目录就是/home/jack</strong></p><p>linux系统支持多用户，所有用户的主目录都是home</p><p>jack用户在home有jack文件夹，存放jack用户的文件</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425095732037.png" alt="image-20240425095732037"></p></li><li><p><strong>/boot     Linux系统的内核文件放在该目录下</strong></p></li><li><p><strong>==/sbin==     系统管理命令，这里存放的是系统管理员使用的管理程序</strong></p><p>bin代指binary，放的都是可执行文件，所以sbin放的是系统管理程序，每个命令对应一个可执行程序，这个可执行程序就放在这里</p></li><li><p><strong>/root     系统管理员root的家目录</strong></p><ul><li>root用户是超级管理员，它的家目录在/root；普通用户的家目录在/home/username</li><li>且超级管理员的命令提示符是#，普通用户的命令提示符是$</li></ul></li><li><p><strong>==/bin==   常用可执行文件</strong>，主要有：cat，chmod，chown， date，mv，mkdir，cp，bash等</p><p>以cat文件为例：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425100455933.png" alt="image-20240425100455933"></p><p>cat命令的可执行文件就放在这里</p></li><li><p><strong>/dev   设备文件</strong>，如/dev/cd0</p></li><li><p><strong>==/usr==   用户级应用程序和文件几乎都在这个目录下面</strong></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425100558249.png" alt="image-20240425100558249"></p></li><li><p><strong>/proc  一个虚拟文件系统</strong></p><p>放置的数据都是在内存当中，例如系统核心、进程信息（process）、设备状态及网络状态等，特点：开机就存在，关机就消失</p></li><li><p><strong>/tmp   公共的临时文件存储点，存放一些临时文件</strong></p></li><li><p><strong>/lib    一些库文件</strong></p><p>库是别人写好的现有的，成熟的，可以复用的代码</p></li></ul><h3 id="3、Linux文件名和特殊文件"><a href="#3、Linux文件名和特殊文件" class="headerlink" title="3、Linux文件名和特殊文件"></a>3、Linux文件名和特殊文件</h3><h4 id="（1）查看目录下的文件-ls"><a href="#（1）查看目录下的文件-ls" class="headerlink" title="（1）查看目录下的文件==ls=="></a>（1）查看目录下的文件==ls==</h4><ul><li><p>Linux文件名称：大小写敏感，无专用扩展名</p><p>例如：/opt/a2018和/opt/A2018是两个文件</p><p>a.txt表示整个文件名称为a.txt，非文本文件</p></li><li><p>ls命令查看某个目录下有哪些文件和目录（文件夹）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls 列出目录内容</span><br><span class="line">ls -l 以列表方式显示</span><br><span class="line">ls -al 查看该目录下所有内容（包括隐藏文件：以.或..开头的文件）</span><br><span class="line">ls -R 递归显示所有目录</span><br></pre></td></tr></tbody></table></figure></li></ul><p><code>ls</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425101235250.png" alt="image-20240425101235250" style="zoom:67%;"></p><p><code>ls -l</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425101322595.png" alt="image-20240425101322595" style="zoom:67%;"></p><p><code>ls -al</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425101605704.png" alt="image-20240425101605704" style="zoom:67%;"></p><p>  注：如何区分是目录还是文件：<strong>开头是<code>-</code>就是文件，开头是<code>d</code>就是目录</strong></p><p>  <code>ls -R</code>：递归地显示所有目录</p><p>  <img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425140406796.png" alt="image-20240425140406796" style="zoom: 80%;"></p><p>  <code>ls -R</code>和<code>tree</code>很相似</p><p>  <img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425140640049.png" alt="image-20240425140640049" style="zoom: 67%;"></p><h4 id="（2）Linux特殊文件"><a href="#（2）Linux特殊文件" class="headerlink" title="（2）Linux特殊文件"></a>（2）Linux特殊文件</h4><p>不同符号对应的文件含义：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/  表示根目录</span><br><span class="line"></span><br><span class="line">.  表示当前目录</span><br><span class="line"></span><br><span class="line">..  表示当前目录的父目录</span><br><span class="line"></span><br><span class="line">.字符串 表示隐藏文件，如“.bash_profile”文件</span><br></pre></td></tr></tbody></table></figure><h4 id="（3）删除文件或目录指令-rm"><a href="#（3）删除文件或目录指令-rm" class="headerlink" title="（3）删除文件或目录指令==rm=="></a>（3）删除文件或目录指令==rm==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm:用于删除文件或目录</span><br><span class="line">rm -f:force强制删除</span><br><span class="line">rm -r:recursive递归地删除</span><br><span class="line">rm -rf *:强制删除所有文件和目录</span><br><span class="line">或者rm -rf file1 file2 file3：一次删掉多个文件</span><br></pre></td></tr></tbody></table></figure><p>先创建data目录，并在data里创建三个文件三个目录：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425111908016.png" alt="image-20240425111908016" style="zoom:50%;"></p><p>不加参数直接删除：报错，因为目录不为空；删除文件时可以直接删，不加参数</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425111951929.png" alt="image-20240425111951929" style="zoom:67%;"></p><p><code>-r</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425112049419.png" alt="image-20240425112049419" style="zoom:67%;"></p><p>递归式的删除，需要确认每一个文件和目录</p><p><code>-f</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425112147709.png" alt="image-20240425112147709" style="zoom:67%;"></p><p>直接强制删除，不会再让user确认是否删除</p><p><code>rm -rf *</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425112830042.png" alt="image-20240425112830042" style="zoom:67%;"></p><p>删除当前下所有文件</p><h3 id="4、绝对路径与相对路径"><a href="#4、绝对路径与相对路径" class="headerlink" title="4、绝对路径与相对路径"></a>4、绝对路径与相对路径</h3><h4 id="（1）当前目录（创建删除目录命令-mkdir-、-rmdir-）"><a href="#（1）当前目录（创建删除目录命令-mkdir-、-rmdir-）" class="headerlink" title="（1）当前目录（创建删除目录命令==mkdir==、==rmdir==）"></a>（1）当前目录（创建删除目录命令==mkdir==、==rmdir==）</h4><p>就是我们（Shell）所工作的目录</p><ul><li><p>当用户刚登陆系统时，当前目录是用户的家目录/home/username，如果以超级管理员身份登录，那么当前目录就是/root</p></li><li><p>当前目录下的所有文件都可以直接访问，指令都默认作用在当前目录上</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwd:查看当前目录命令</span><br><span class="line">mkdir:创建目录</span><br><span class="line">mkdir -p:parents</span><br><span class="line">mkdir -v:verbose</span><br></pre></td></tr></tbody></table></figure><p><code>-p</code>：在没有www父目录的情况下，无法直接连创两级，但是加上-p参数之后，不会报错，会自动先创建www父目录，再创建子目录<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425110716237.png" alt="image-20240425110716237" style="zoom:80%;"></p><p><code>-v</code>：可以显示目录创建的过程</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425110940253.png" alt="image-20240425110940253" style="zoom:67%;"></p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir:删除目录，必须是空目录才能用这个命名删除,否则报错</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425111206752.png" alt="image-20240425111206752" style="zoom:67%;"></p><h4 id="（2）绝对路径"><a href="#（2）绝对路径" class="headerlink" title="（2）绝对路径"></a>（2）绝对路径</h4><p>开始于根目录，紧跟着目录树的一个个分支，一直到达所期望的目录或文件</p><h4 id="（3）相对路径（切换目录命令-cd-）"><a href="#（3）相对路径（切换目录命令-cd-）" class="headerlink" title="（3）相对路径（切换目录命令==cd==）"></a>（3）相对路径（切换目录命令==cd==）</h4><p>开始于当前目录，紧跟着目录树的一个个分支，一直到达所期望的目录或文件</p><p>“.”（点）和“..”（点点）表示当前目录和父目录</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd目录（相对路径、绝对路径)</span><br><span class="line">cd~切换到家目录</span><br><span class="line">cd ..:切换到父级目录</span><br><span class="line">cd -:2个目录之间切换</span><br></pre></td></tr></tbody></table></figure><h3 id="5、文件操作"><a href="#5、文件操作" class="headerlink" title="5、文件操作"></a>5、文件操作</h3><h4 id="（1）查看文件内容"><a href="#（1）查看文件内容" class="headerlink" title="（1）查看文件内容"></a>（1）查看文件内容</h4><h5 id="1）-cat-：适合查看短文件"><a href="#1）-cat-：适合查看短文件" class="headerlink" title="1）==cat==：适合查看短文件"></a>1）==cat==：适合查看短文件</h5><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425114246630.png" alt="image-20240425114246630" style="zoom:67%;"></p><h5 id="2）-less-：查看长文件"><a href="#2）-less-：查看长文件" class="headerlink" title="2）==less==：查看长文件"></a>2）==less==：查看长文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以通过快捷键查看翻页：</span><br><span class="line"> k向上一行</span><br><span class="line"> j向下一行</span><br><span class="line"> Page up向上一页</span><br><span class="line"> Page down向下一页</span><br><span class="line"> q退出</span><br></pre></td></tr></tbody></table></figure><h5 id="3）-head-：用于查看文件的头部n行"><a href="#3）-head-：用于查看文件的头部n行" class="headerlink" title="3）==head==：用于查看文件的头部n行"></a>3）==head==：用于查看文件的头部n行</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head -n filename看文件的前n行</span><br><span class="line">没有指定多少行的时候，默认查看10行</span><br></pre></td></tr></tbody></table></figure><p>看文件的前5行：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425114313418.png" alt="image-20240425114313418" style="zoom:67%;"></p><p>查看前5位用户：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425114448067.png" alt="image-20240425114448067" style="zoom:67%;"></p><h5 id="4）-tail-：用于查看文件的尾部n行"><a href="#4）-tail-：用于查看文件的尾部n行" class="headerlink" title="4）==tail==：用于查看文件的尾部n行"></a>4）<strong>==tail==：用于查看文件的尾部n行</strong></h5><p><code>tail -f</code> ：用于实时监控日志</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tail -n filename看文件的末尾n行</span><br><span class="line">没有指定多少行的时候，默认查看10行</span><br><span class="line"></span><br><span class="line">-f：follow实时查看文件的内容，因为某些日志文件的尾部数据会一直改变</span><br></pre></td></tr></tbody></table></figure><p>看文件后6行：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425114601527.png" alt="image-20240425114601527" style="zoom:67%;"></p><p><code>-f</code>：<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240425114941164.png" alt="image-20240425114941164" style="zoom:67%;"></p><p>默认查看后10行，但区别是加了参数<code>-f</code>之后，查询结果不固定，光标一直闪烁，如果数据更新，会显示新数据</p><h4 id="（2）通配符，模糊指代"><a href="#（2）通配符，模糊指代" class="headerlink" title="（2）通配符，模糊指代"></a>（2）通配符，模糊指代</h4><p>通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件</p><div class="table-container"><table><thead><tr><th>模式</th><th>匹配对象</th></tr></thead><tbody><tr><td>*</td><td>所有文件</td></tr><tr><td>g*</td><td>文件名以g开头的文件</td></tr><tr><td>b*.txt</td><td>以b开头，中间有零个或任意多个字符，并以.txt结尾的文件</td></tr><tr><td>Data???</td><td>以Data开头，后面紧跟3个字符的文件文件名</td></tr><tr><td>[abc]*</td><td>以a，b或c开头的文件</td></tr></tbody></table></div><p>例如：</p><p>删除文件名为六个字符的文件</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ??????</span><br></pre></td></tr></tbody></table></figure><p>删除以file开头的所有文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf file*</span><br></pre></td></tr></tbody></table></figure><p>删除以test开头，中间有任意字符且以.sh结尾的文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf file*.sh</span><br></pre></td></tr></tbody></table></figure><p>删除以f或t开头的所有文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf [ft]*</span><br></pre></td></tr></tbody></table></figure><h4 id="（3）创建文件"><a href="#（3）创建文件" class="headerlink" title="（3）创建文件"></a>（3）创建文件</h4><h5 id="1）-touch"><a href="#1）-touch" class="headerlink" title="1）==touch=="></a>1）==touch==</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch /home/test/file01:在指定目录下新建空文件file01</span><br><span class="line">touch file02:在当前目录下新建空文件file02</span><br><span class="line">touch file01 file02 /home/test/file03：可以同时创建多个文件</span><br></pre></td></tr></tbody></table></figure><h5 id="2）-vi"><a href="#2）-vi" class="headerlink" title="2）==vi=="></a>2）==vi==</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi file01创建号文件后直接进入编辑模式</span><br><span class="line">insert打开插入模式</span><br><span class="line">编辑文件</span><br><span class="line">按esc进入底线模式</span><br><span class="line">:wq wirte quit保存并退出</span><br></pre></td></tr></tbody></table></figure><h5 id="3）-gt-（重定向符号）"><a href="#3）-gt-（重定向符号）" class="headerlink" title="3）==>==（重定向符号）"></a>3）==<strong>&gt;</strong>==（重定向符号）</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以通过重定向符号新建文件</span><br><span class="line"></span><br><span class="line">后面学</span><br><span class="line">比如将file01的前20行重定向到file_mini中：</span><br><span class="line">head -20 ./file01 &gt; file_mini</span><br></pre></td></tr></tbody></table></figure><h5 id="4）底线模式新建文件"><a href="#4）底线模式新建文件" class="headerlink" title="4）底线模式新建文件"></a>4）底线模式新建文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">还可以通过底线模式，将文件的某一段截取出来放到新文件里</span><br><span class="line">在底线模式下</span><br><span class="line">:2,12 w newfile</span><br><span class="line">表示将该文件的第2行到第12行的内容放入newfile文件中</span><br></pre></td></tr></tbody></table></figure><h4 id="（4）复制文件、目录-cp"><a href="#（4）复制文件、目录-cp" class="headerlink" title="（4）复制文件、目录==cp=="></a>（4）复制文件、目录==cp==</h4><ul><li><p><strong>复制文件命令：cp 源文件 目标文件</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cp file01 file01_backup</span><br><span class="line">将file01中的文件复制到file01_backup中（同一目录下不能同名）</span><br><span class="line"></span><br><span class="line">cp file01 /home/test/ </span><br><span class="line">将file01中的文件复制到/home/test目录下，默认不同目录下源文件和目标文件可以同名</span><br><span class="line"></span><br><span class="line">cp file01 /home/test/file02</span><br><span class="line">也可以指定名字</span><br><span class="line"></span><br><span class="line">cp file* /home/test</span><br><span class="line">利用通配符，可以将所有file+任意字符的所有文件一次性复制到指定目录</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>复制目录</strong></p><p>复制目录必须参数<code>-r</code>,否则报错</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复制目录</span><br><span class="line">cp -r dir01 dir02：当前目录复制，源和目标目录名称必须不同</span><br><span class="line">cp -r file01 dir01 /home/jim/dir02：源可以是多个文件、或目录，可以把多个目录或文</span><br><span class="line">件复制到目标目录中</span><br><span class="line">参数-r或-R都有效</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="（5）移动、重命名文件和目录-mv"><a href="#（5）移动、重命名文件和目录-mv" class="headerlink" title="（5）移动、重命名文件和目录==mv=="></a>（5）移动、重命名文件和目录==mv==</h4><ul><li><p><strong>重命名文件和目录</strong></p><p>mv：源地址和目的地址==相同==就是重命名</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv file01 file02#重命名文件file01为file02</span><br><span class="line">mv dir01 dir02#重命名目录dir01为dir02</span><br><span class="line">mv dir01/file01 dir01/file02#重命名文件file01为file02</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>移动文件和目录</strong></p><p>mv：源地址和目的地址==不同==就是移动</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mv file01 dir01/  </span><br><span class="line">移动file01到dir01目录</span><br><span class="line"></span><br><span class="line">mv file01 dir01/file02</span><br><span class="line">移动file01到dir01目录且重命名为file02</span><br><span class="line"></span><br><span class="line">mv file01 file02 dir01 dir02</span><br><span class="line">移动file01、file02、dir01到dir02</span><br><span class="line">(此时dir02必须存在，因为无法重命名多个文件或目录，只有移动)</span><br><span class="line">不然会报错，如下图所示</span><br><span class="line"></span><br><span class="line">mv dir01 dir02</span><br><span class="line">如果dir02不存在，则重命名，如果dir02存在，则移动目录dir01到dir02目录下</span><br></pre></td></tr></tbody></table></figure></li></ul><p>  <img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425154330400.png" alt="image-20240425154330400" style="zoom:50%;"></p><h4 id="（6）文件链接-ln"><a href="#（6）文件链接-ln" class="headerlink" title="（6）文件链接==ln=="></a>（6）文件链接==ln==</h4><h5 id="1）文件链接概念"><a href="#1）文件链接概念" class="headerlink" title="1）文件链接概念"></a>1）文件链接概念</h5><p>我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。</p><ul><li><p>用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；</p></li><li><p>元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。</p></li></ul><p>在 Linux 中，元数据中的 <strong>inode 号</strong>（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的<strong>唯一标识</strong>而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。</p><p>下图展示了程序通过文件名获取文件内容的过程。</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425155918428.png" alt="image-20240425155918428" style="zoom: 67%;"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看文件inode命令：stat或ls -i</span><br><span class="line"></span><br><span class="line">[root@localhost test]# ls -i file01</span><br><span class="line">34355716 file01</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425160200351.png" alt=""></p><h5 id="2-为什么需要链接？"><a href="#2-为什么需要链接？" class="headerlink" title="2) 为什么需要链接？"></a>2) 为什么需要链接？</h5><ul><li>实现文件的<strong>共享</strong>使用（原因:不能移动，其他文件使用时只能通过链接访问)</li><li>提供了隐藏文件路径、增加权限<strong>安全</strong>及<strong>节省存储</strong>等好处</li><li>和复制的区别:文件在磁盘中只有一个拷贝，节省磁盘空间</li></ul><h5 id="3）链接的种类与创建"><a href="#3）链接的种类与创建" class="headerlink" title="3）链接的种类与创建"></a>3）链接的种类与创建</h5><p>硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）</p><ul><li><p>创建硬链接： <code>ln filename filename-hardlink</code></p><p>硬链接和源文件属性一样</p></li><li><p>创建软链接： <code>ln -s filename filename-softlink</code></p></li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425155637496.png" style="zoom:67%;"></p><h5 id="4）软硬链接的区别"><a href="#4）软硬链接的区别" class="headerlink" title="4）软硬链接的区别"></a>4）软硬链接的区别</h5><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425160631740.png" style="zoom:67%;"></p><p>详细区别：</p><p><strong>硬链接</strong>：若—个inode号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是==同一个文件使用了多个别名==</p><ul><li><p><strong>文件有相同的inode 及 data block;</strong></p><p>查询硬链接inode号：和源文件一样，硬链接的data block保存的就是源文件的文件内容</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425160455936.png" style="zoom:67%;"></p><p>查询软连接iNode号：和源文件不一样，软链接的data block保存了源文件的路径名的指向</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425160534653.png" style="zoom:67%;"></p><p>硬链接data block大小与源文件一致，软链接则不一样</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425162215724.png" style="zoom:67%;"></p></li><li><p><strong>只能对已存在的文件进行创建;</strong></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425161954624.png"></p></li><li><p><strong>不能跨文件系统进行硬链接的创建;</strong><br>不同文件所使用的文件系统不一样,/dev使用的是devtmpfs文件系统，/dev/shm使用的则是tmpfs文件系统</p><p>查看文件系统指令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -Th</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425164719117.png" alt="image-20240425164719117" style="zoom:67%;"></p><p> 硬链接跨系统创建失败：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425164839326.png" alt="image-20240425164839326"></p><p> 软链接可以：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425164927185.png" alt="image-20240425164927185" style="zoom:67%;"></p></li><li><p><strong>不能对目录进行创建，只可对文件创建；</strong></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425164538159.png" alt="image-20240425164538159" style="zoom: 67%;"></p></li><li><p><strong>删除一个硬链接文件并不影响其他有相同 inode 号的文件</strong></p><ul><li><p>就算删掉源文件，源文件的硬链接依旧可以使用，这就达到了备份的效果</p></li><li><p>源文件删除之后，即使新建了一个同名源文件之后，由于inode号改变，新文件和源硬链接已经不存在链接关系</p></li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425165738696.png" alt="image-20240425165738696" style="zoom:67%;"></p></li></ul><p><strong>软链接（符号链接）</strong>：若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软链接。==软链接就是一个普通文件，只是数据块内容有点特殊==。类似于Windows的快捷方式</p><ul><li>软链接<u>有自己的文件属性及权限</u>等；</li><li>可对不存在的文件或目录创建软链接；</li><li>软链接可交叉文件系统；</li><li>软链接<strong>可对文件或目录创建</strong>；</li><li>创建软链接时，链接计数 i_nlink 不会增加；</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为<strong>死链接</strong>（即 <strong>dangling link</strong>（创建一个和源文件同名同地址的新文件后，<strong>死链接可恢复</strong>为正常的软链接）。</li></ul><p>对源文件的修改，软、硬链接文件内容也一样的修改，因为都是指向同一个文件的内容。</p><h5 id="5）链接文件作用"><a href="#5）链接文件作用" class="headerlink" title="5）链接文件作用"></a>5）链接文件作用</h5><ul><li>硬链接：相当于同一个文件有多个别名，每个别名背后对应的是同一个文件，inode相同，但在存储的时候，只会在磁盘上存一份（跟复制两个文件不同)，可以节约存储空间。</li><li>软链接：相当于快捷方式，软链接文件和目标文件是两个不同的文件，但软链接文件指向的是目录文件。</li></ul><h5 id="6）什么情况下需要创建链接-使用场景"><a href="#6）什么情况下需要创建链接-使用场景" class="headerlink" title="6）什么情况下需要创建链接?使用场景"></a>6）什么情况下需要创建链接?使用场景</h5><ul><li><p>硬链接<br>对于有些重要文件,为了防止被用户意外删除或出于该目录的权限考虑，可以为该文件在其他目录中建立硬链接，让其他用户访问，实现重要文件的备份和共享。</p></li><li><p>软链接<br>为了在任意目录下都可以执行python命令，可以通过两种方式实现<br>1）把/usr/local/python3/bin添加到<strong>环境变量PATH</strong>中</p><ul><li>环境变量PATH作用：在终端执行命令的时候，会从PATH环境变量的每个目录下查找命令的可执行文件，找不到就会显示commend not found<img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240425171704558.png" alt="image-20240425171704558" style="zoom:67%;"></li><li>把/usr/local/python3/bin添加到环境变量PATH中</li></ul><p>2）配置软链接</p><p>可以在/usr/bin目录下创建一个软链接文件python指向/usr/local/python3/bin/python3.7，<br>因为/usr/bin目录默认就是在环境变量PATH中，所以这样就可以直接执行python命令</p></li></ul><h4 id="（7）查找文件"><a href="#（7）查找文件" class="headerlink" title="（7）查找文件"></a>（7）查找文件</h4><h5 id="1）-which"><a href="#1）-which" class="headerlink" title="1）==which=="></a>1）==which==</h5><p>which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果；Linux系统中，每个命令都有可执行文件</p><p>which用来==查找可执行文件的位置==、显示命令所在路径；</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：which 系统命令</span><br><span class="line">举例：which vi</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426101041139.png" alt="image-20240426101041139" style="zoom:67%;"></p><h5 id="2）-whereis"><a href="#2）-whereis" class="headerlink" title="2）==whereis=="></a>2）==whereis==</h5><p>whereis 命令则是用来快速查找程序的==二进制文件==、==源代码==和==man手册文件==的路径；</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：whereis 系统命令</span><br><span class="line">举例：whereis vi</span><br></pre></td></tr></tbody></table></figure><p> 查找那么找到的结果就比which vi命令找到的结果多，因为which命令只会列出二进制文件路径，而whereis命令会把vi的二进制文件、源代码、帮助手册都返回</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426104901689.png" alt="image-20240426104901689"></p><h5 id="3）-find"><a href="#3）-find" class="headerlink" title="3）==find=="></a>3）==find==</h5><p>find命令会在==指定目录及其子目录下==查找符合条件的特定文件，当我们忘记文档路径时，可以使用该命令</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法：find 目录名 条件</span><br><span class="line">举例：find /home/tom -name test.sh</span><br><span class="line">     find / -name test.sh</span><br><span class="line">条件</span><br><span class="line">-name文件名</span><br><span class="line">-type文件or目录：文件用f，目录用d</span><br><span class="line">-atime -5 :5天内访问过的</span><br><span class="line">-atime +5:5天前访问过的</span><br><span class="line">-amin -5:5分钟内访问过的</span><br><span class="line">-amin +5:5分钟之前访问过的</span><br></pre></td></tr></tbody></table></figure><p>例如：在/test目录下，查找以file开头的文件</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426101619083.png" alt="image-20240426101619083" style="zoom:67%;"></p><p>在当前目录下，查找以d开头的所有<strong>目录</strong></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426101952954.png" alt="image-20240426101952954" style="zoom:67%;"></p><p>atime、amin举例</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426102608535.png" alt="image-20240426102608535" style="zoom: 67%;"></p><h4 id="（8）文本关键字搜索-grep"><a href="#（8）文本关键字搜索-grep" class="headerlink" title="（8）文本关键字搜索 ==grep=="></a>（8）文本关键字搜索 ==grep==</h4><p>一种强大的文本搜索工具，并把匹配的行打印出来。用于==查看日志==、==查看命令输出==。且grep默认<strong>关键字大小写敏感、支持正则表达式</strong>。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">命令格式：grep 要搜索的关键字 文件</span><br><span class="line">比如：grep root /var/log/message</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-c：count 只输出匹配行的行数（有多少行匹配）</span><br><span class="line">-i：ignore case不区分大小写</span><br><span class="line">-n：line-number 只显示匹配行及行号</span><br><span class="line">-v：invert-match 显示不含匹配文本的所有行</span><br><span class="line">-F：指明pattern非正则表达式</span><br><span class="line">-E：指明pattern正则表达式</span><br></pre></td></tr></tbody></table></figure><h5 id="1）参数说明"><a href="#1）参数说明" class="headerlink" title="1）参数说明"></a>1）参数说明</h5><ul><li><p>基本举例：新建一个file11，输入内容如下： </p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426105746796.png" alt="image-20240426105746796" style="zoom:67%;"></p><ul><li>用grep查找file11中包含line的内容</li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426105907240.png" alt="image-20240426105907240" style="zoom:67%;"></p></li><li><p>参数<code>-c</code>：只输出匹配行的行数（有多少行匹配）</p><ul><li>查询file11中包含line的内容有几行</li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426110206150.png" alt="image-20240426110206150" style="zoom:67%;"></p><ul><li><p>==如何统计文件里一共多少行==</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c "" file11</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426111909462.png" alt="image-20240426111909462" style="zoom:67%;"></p></li></ul></li><li><p>参数<code>-i</code>：（ignore capital）不区分大小写，默认严格区分大小写，例如，查包含line的关键词，区分大小写时有两条，不区分大小写时有六行</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426110412644.png" alt="image-20240426110412644" style="zoom:67%;"></p></li><li><p>参数<code>-n</code>：（number）只显示匹配行及行号</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426110531032.png" alt="image-20240426110531032" style="zoom: 67%;"></p></li><li><p>参数<code>-v</code>：（invert match反选）显示不含匹配文本的所有行</p><p>显示不包含line的行，且不区分line的大小写</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426110711799.png" alt="image-20240426110711799" style="zoom:50%;"></p></li><li><p>参数<code>-E</code>：指明pattern正则表达式</p><ul><li><p>==用于查看日志文件中的错误信息==</p><p>包含关键字: error或者exception或者fatal，加<code>-i</code>不区分大小写，因为有的ERROR是大写，有的是小写</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i -E "error|exception|fatal" 文件名</span><br></pre></td></tr></tbody></table></figure></li></ul><p>参数<code>-F</code>：指明pattern非正则表达式</p></li></ul><h5 id="2）grep命令特殊符例子"><a href="#2）grep命令特殊符例子" class="headerlink" title="2）grep命令特殊符例子"></a>2）grep命令特殊符例子</h5><ul><li><p>搜索以line开头的行：<code>^</code>符号</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep "^line" file11</span><br><span class="line">显示行号：grep -n "^line" file11</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426112623072.png" alt="image-20240426112623072" style="zoom:67%;"></p></li><li><p>搜索以”行”字结尾的行：<code>$</code>符号</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep "line$" file11</span><br><span class="line">显示行号：grep -n "行$" file11</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426112912986.png" alt="image-20240426112912986" style="zoom: 67%;"></p></li><li><p>搜索当前目录下以f开头的文件中，包含line关键字的所有行：<code>*</code>符号</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep "line" ./f*</span><br><span class="line">显示行号且不区分大小写：grep -n -i "line" ./f*</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426113303223.png" alt="image-20240426113303223" style="zoom:67%;"></p></li><li><p>在目录及子目录下查找包含关键字的行：<code>-r</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n -i "line" -r ./dir0</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426114227362.png" alt="image-20240426114227362" style="zoom:67%;"></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426114410375.png" alt="image-20240426114410375" style="zoom:67%;"></p></li><li><p>grep最常用的用法，查看某个进程，比如查看tomcat、nginx进程</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep tomcat</span><br><span class="line">-ef:-e查看所有进程; -f明确显示格式</span><br><span class="line">| :管道符</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426114636422.png" alt="image-20240426114636422" style="zoom:50%;"></p></li></ul><h4 id="（9）统计文件内容-wc"><a href="#（9）统计文件内容-wc" class="headerlink" title="（9）统计文件内容==wc=="></a>（9）统计文件内容==wc==</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wc 参数 文件</span><br><span class="line">参数：</span><br><span class="line">-l多少行: wc -l ./file02：统计当前目录下file02文件有多少行</span><br><span class="line">-c多少个字节: wc -c /etc/passwd：统计/etc/passwd文件有多少个字节</span><br><span class="line">通常带着管道符一起使用：</span><br><span class="line">例如：统计有多少进程正在运行</span><br><span class="line">ps -ef |wc -l</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426140638480.png" alt="image-20240426140638480" style="zoom:67%;"></p><p>统计root下有多少进程正在运行：</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426140916165.png" alt="image-20240426140916165" style="zoom: 80%;"></p><h4 id="（10）查看目录-文件占用的磁盘空间-du、df"><a href="#（10）查看目录-文件占用的磁盘空间-du、df" class="headerlink" title="（10）查看目录/文件占用的磁盘空间 ==du、df=="></a>（10）查看目录/文件占用的磁盘空间 ==du、df==</h4><p>1）<code>du</code>命令是查看==文件或目录的磁盘使用空间==，即占用磁盘大小</p><p>2）<code>du</code>使用的情形：比如，服务器磁盘空间不够用了，已经被占用了80%以上，就会出现服务器响应速度很慢，需要清理磁盘空间</p><p>具体操作：</p><ul><li><p>用<code>df</code>查看==文件系统==的磁盘使用情况，比如总空间多大、使用了多少，可用空间多少、使用率等信息；</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df</span><br><span class="line">参数</span><br><span class="line">-T：显示文件类型</span><br><span class="line">-h：可读</span><br></pre></td></tr></tbody></table></figure><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426142338539.png" alt="image-20240426142338539" style="zoom:67%;"></p><p>加参数<code>-T</code>：会显示type，文件类型</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426143258411.png" alt="image-20240426143258411" style="zoom:67%;"></p><p>加参数<code>-h</code>：可读，发现根目录下占用磁盘空间最大，所以<code>cd /</code>，进入磁盘，查看情况</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426143410604.png" alt="image-20240426143410604" style="zoom: 50%;"></p></li><li><p>进入占用磁盘空间最大的目录，用<code>du -sh ./*</code>统计来排查到底是那个文件，然后进入这个文件进一步查看，可以再进<code>./local</code>，再又用<code>du -sh ./*</code></p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426143655028.png" alt="image-20240426143655028" style="zoom:67%;"></p></li><li><p>最后通过<code>rm -rf 文件</code></p></li></ul><p>3）语法和参数</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：du -sh 文件名或者目录名</span><br><span class="line">参数：</span><br><span class="line">-a：统计所有文件或目录</span><br><span class="line">-h：human-readable，在打印文件大小时，用k，m，g等可读方式展示</span><br><span class="line">-s：summarize</span><br></pre></td></tr></tbody></table></figure><ul><li><p>参数<code>-a</code>：展示当前目录下所有文件和目录的大小</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426141550025.png" alt="image-20240426141550025" style="zoom:67%;"></p></li><li><p>参数<code>-h</code>：以<strong>可读</strong>方式展现所占内存大小</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426141513769.png" alt="image-20240426141513769" style="zoom:67%;"></p></li><li><p>参数<code>-s</code>：当前目录总的大小为44</p></li></ul><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426141442627.png" alt="image-20240426141442627" style="zoom: 67%;"></p><h3 id="6、Linux文本编辑器-vi"><a href="#6、Linux文本编辑器-vi" class="headerlink" title="6、Linux文本编辑器==vi=="></a>6、Linux文本编辑器==vi==</h3><h4 id="（1）vi-vim概述"><a href="#（1）vi-vim概述" class="headerlink" title="（1）vi/vim概述"></a>（1）vi/vim概述</h4><ul><li>vi/vim是所有Linux系统都提供的文本编辑器，它提供了一个窗口，通过它可以编辑文件；</li><li>vim是vi的增强版本，支持vi的全部功能<ul><li>vim命令更多</li><li>vim有增强功能包括颜色标记功能，更方便</li></ul></li></ul><h4 id="（2）vi格式"><a href="#（2）vi格式" class="headerlink" title="（2）vi格式"></a>（2）vi格式</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi  文件名</span><br><span class="line">vim 文件名</span><br></pre></td></tr></tbody></table></figure><p>如果文件已存在，则打开并编辑文件，底部提示文件多少行，多少字节</p><p>如果文件不存在，则新建并编辑文件，底部提示new file</p><p>常用操作：</p><h5 id="1）修改环境变量："><a href="#1）修改环境变量：" class="headerlink" title="1）修改环境变量："></a>1）修改环境变量：</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">shift +g快速移动到最后一行</span><br><span class="line">insert进入插入模式</span><br><span class="line">编辑文件，例如：export PATH=$PATH:/home/test</span><br><span class="line">ESC到底线模式</span><br><span class="line">：wq保存退出</span><br></pre></td></tr></tbody></table></figure><h5 id="2）修改tomcat、Nginx配置文件"><a href="#2）修改tomcat、Nginx配置文件" class="headerlink" title="2）修改tomcat、Nginx配置文件"></a>2）修改tomcat、Nginx配置文件</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim application.yml 进入配置文件</span><br><span class="line">:/port 定位到port，输入n可以下移，找到要修改的port</span><br><span class="line">i 进入插入模式</span><br><span class="line">编辑文件，修改port</span><br><span class="line">ESC到底线模式</span><br><span class="line">：wq保存退出</span><br></pre></td></tr></tbody></table></figure><h5 id="3）启动时报错，如何修改报错代码"><a href="#3）启动时报错，如何修改报错代码" class="headerlink" title="3）启动时报错，如何修改报错代码"></a>3）启动时报错，如何修改报错代码</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim application.yml</span><br><span class="line">:20进入底线模式，定位到第20行（假设第20行报错）</span><br><span class="line">insert进入插入模式</span><br><span class="line">修改报错代码</span><br><span class="line">ESC到底线模式</span><br><span class="line">：wq保存退出</span><br></pre></td></tr></tbody></table></figure><h4 id="（3）三种模式"><a href="#（3）三种模式" class="headerlink" title="（3）三种模式"></a>（3）三种模式</h4><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426150327095.png" alt="image-20240426150327095" style="zoom:67%;"></p><h5 id="1）命令模式command-mode"><a href="#1）命令模式command-mode" class="headerlink" title="1）命令模式command mode"></a>1）命令模式command mode</h5><ul><li><p>刚进入时的默认模式就是命令模式</p></li><li><p>命令模式的特点：</p><ul><li><p>此时不可以直接添加文字</p></li><li><p>不能用退格删除文字</p></li><li><p><strong>==控制光标的快速移动==</strong></p><ul><li>快速移动到最后一行的行首：==<code>shift+G</code>==</li><li>快速移动到第一行行首：==<code>GG</code>==</li><li>移动光标到当前行的行尾：==<code>shift+$</code>==</li><li>移动光标到当前行的行首：==<code>shift+^</code>==</li></ul></li><li><p><strong>可以进行字符的删除、复制、粘贴</strong></p><p><code>x</code>：删除</p><ul><li><p>x是往后删，相当于delete键，X是往前删，相当于Backspace键</p></li><li><p>3x表示删除光标所在位置开始的3个字符，包括光标所在位置</p></li><li><p>如果输入命令错误，可以按Esc键取消</p></li></ul><p><code>dw</code>：删除光标所在处直到词尾的内容</p><p><code>dd</code>：删除光标所在行</p><ul><li>3dd表示删除从光标所在行开始的3行，包括光标所在行</li></ul><p><code>yw</code>：复制光标所在处到词尾的内容</p><p><code>yy</code>：复制光标所在行</p><ul><li>3yy表示复制3行</li></ul><p><code>p</code>：粘贴</p></li><li><p><strong>替换、撤销</strong></p><p><code>r</code>：替换光标所在处的字符</p><p><code>shift + r</code>：连续替换字符直到按ESC为止</p><p><code>u</code>：假如误操作一个命令，可以马上按u进行撤销，可以连续按u撤销多个之前做出的操作（等于Windows下的ctrl + z）</p><p><code>Ctrl + r</code>：反撤销</p></li></ul></li></ul><h5 id="2）底线模式"><a href="#2）底线模式" class="headerlink" title="2）底线模式"></a>2）底线模式</h5><p>在命令模式下输入冒号进入底线模式</p><p>==<strong>1))、查找、定位</strong>==</p><ul><li>==<code>:set nu</code>== 在每一行的行首显示行号</li><li>==<code>:set nonu</code>== 关闭显示行号</li><li>==<code>:n</code>== n是你要输入的数字，再按回车，光标将跳转到数字指定的行</li><li>==<code>:/关键字</code>==先按/，再输入你要查找的字符<ul><li>找到所有关键字后，光标默认指向第一个，可以输入<code>n</code>（next），向下继续查找</li><li><code>shift+n</code>是往上查找</li><li><code>set ic</code>：查找关键字时，设置忽略大小写（ignore capital）</li><li><code>set noic</code>：查找关键字时，设置不忽略大小写（not ignore capital）</li></ul></li></ul><p>==<strong>2))、字符替换</strong>==</p><ul><li>在底线模式下输入<code>1,$s/oldstring/newstring/g</code>会将全文的oldstring字符串替换成newstring字符串<ul><li>1,$表示从第一行到最后一行</li><li>s表示替换</li><li>g表示每行全部替换</li></ul></li></ul><p>或者简写成：<code>%s/oldstring/newstring/g</code></p><p>eg.将文件里的LINE全部替换为line</p><p><img src="/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240426153805604.png" alt="image-20240426153805604" style="zoom:67%;"></p><ul><li><p>指定行：</p><p><code>:1,20s/oldstring/newstring/g</code>将1至20行间的oldstring替换成newstring字符串</p></li></ul><p><strong>3))、编辑完成之后的==保存、退出==</strong></p><ul><li><code>:起始行号,结尾行号 w 文件名</code> 如果你想摘取文件的某一段，存为另一个文件，可以使用这个指令，例如：<code>30,50 w nice</code>代表将30到50行摘录下来，并另存为nice文件</li><li><code>:w</code> 新文件名 将文件<strong>另存为</strong>新文件</li><li><code>:wq</code> <strong>保存</strong>并退出</li><li><code>:q!</code> 强制退出vi并<strong>不保存</strong>当前的修改内容</li></ul><h5 id="3）插入模式"><a href="#3）插入模式" class="headerlink" title="3）插入模式"></a>3）插入模式</h5><p>进入插入模式：insert、i、a、o都可以进入</p><p>三者的区别在于：insert和i进入插入模式，光标不会移动；a进入插入模式，光标向后移动一位；o进入插入模式，光标向下移动一行</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、操作系统&quot;&gt;&lt;a href=&quot;#一、操作系统&quot; class=&quot;headerlink&quot; title=&quot;一、操作系统&quot;&gt;&lt;/a&gt;一、操作系统&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;操作系统（Operating System，OS）：管理硬件和应用程序的一套==系统软件==。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作系统的作用： CPU管理、内存管理、文件系统管理、进程管理、外设管理、用户管理…（&lt;em&gt;理解：表现出来就是让CPU可以开始判断逻辑与运算数值，让内存可以开始加载/读出数据与程序代码，让硬盘可以开始被访问，让网卡可以开始传输数据，让所有周边设备可以开始运转等，总之硬件的所有操作都必须要通过操作系统来完成。&lt;/em&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个操作系统的核心叫==内核==，操作系统的各项功能都是通过内核实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424195236588-1714013539134.png&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1、常见的操作系统：&quot;&gt;&lt;a href=&quot;#1、常见的操作系统：&quot; class=&quot;headerlink&quot; title=&quot;1、常见的操作系统：&quot;&gt;&lt;/a&gt;1、常见的操作系统：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DoS：个人电脑；&lt;/li&gt;
&lt;li&gt;Windows：个人电脑，Windows7、Windows10、WindowsServer；&lt;/li&gt;
&lt;li&gt;Mac OS X：MacBook系列笔记本；&lt;/li&gt;
&lt;li&gt;Android：安卓手机、平板、机顶盒、智能电视机、手环；&lt;/li&gt;
&lt;li&gt;ios：iPhone、iPad、iWatch、iPod等；&lt;/li&gt;
&lt;li&gt;Unix（服务器）&lt;/li&gt;
&lt;li&gt;Linux：免费、可靠、安全、稳定、多平台；（服务器）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2、操作系统之间的关系&quot;&gt;&lt;a href=&quot;#2、操作系统之间的关系&quot; class=&quot;headerlink&quot; title=&quot;2、操作系统之间的关系&quot;&gt;&lt;/a&gt;2、操作系统之间的关系&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2024/04/24/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Linux%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20240424195349886.png&quot; alt=&quot;image-20240424195349886&quot; style=&quot;zoom:67%;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;3、主要学习Linux原因：&quot;&gt;&lt;a href=&quot;#3、主要学习Linux原因：&quot; class=&quot;headerlink&quot; title=&quot;3、主要学习Linux原因：&quot;&gt;&lt;/a&gt;3、主要学习Linux原因：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;大部分软件都运行在Linux上&lt;ul&gt;
&lt;li&gt;Linux作为服务器的操作系统，大部分软件都运行在Linux操作系统上;&lt;/li&gt;
&lt;li&gt;互联网Web服务、物联网、车联网、大数据、云计算服务、人工智能、智能运维等各个方面都广泛应用;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工作中要用Linux&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Linux" scheme="https://laylaycjl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>测试报告</title>
    <link href="https://laylaycjl.github.io/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/"/>
    <id>https://laylaycjl.github.io/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/</id>
    <published>2024-04-24T10:50:21.000Z</published>
    <updated>2024-04-24T12:16:00.928Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>什么是测试报告？</p><p>测试报告是测试人员在<strong>完成整个系统的测试工作之后</strong>所撰写的文档，该文档可以反映测试<strong>过程</strong>与测试<strong>结果</strong>，是对阶段性测试任务的<u>总结</u>。</p></li><li><p>测试报告作用？</p><ul><li>可以评估项目当前状态和产品质量</li><li>确定产品是否准备好发布的最终文档</li></ul></li></ul><h2 id="一、测试报告的几大要素"><a href="#一、测试报告的几大要素" class="headerlink" title="一、测试报告的几大要素"></a>一、测试报告的几大要素</h2><h3 id="1、人力投入"><a href="#1、人力投入" class="headerlink" title="1、人力投入"></a>1、人力投入</h3><p>对不同测试阶段所花的时间有清晰记录</p><p>eg. 测试用例编写：人员、工作量</p><p>测试执行：人员、工作量</p><h3 id="2、用例覆盖度"><a href="#2、用例覆盖度" class="headerlink" title="2、用例覆盖度"></a>2、用例覆盖度</h3><p>==用例覆盖率=（pass+fail）/总用例数==</p><p>用例状态：pass（通过）、fail（未通过）、NT（not test尚未测试）、block（阻塞，暂时没有条件执行）、investigate（观察中，正在测试）</p><p>eg.pass和fail一共251，总用例263个</p><p>用例覆盖率=251/263=95%</p><h3 id="3、缺陷统计"><a href="#3、缺陷统计" class="headerlink" title="3、缺陷统计"></a>3、缺陷统计</h3><ul><li><p>bug严重等级：其中致命bug少的原因——开发自测和冒烟测试已经筛掉了大部分致命bug</p></li><li><p>功能型bug最多</p></li><li><p>bug状态：激活、已解决、已关闭</p><p>==缺陷遗留率=（激活+已解决）/总bug数==</p><p>只认准已关闭的bug为已解决</p></li><li><p>bug来源：一般是需求、编码类bug较多</p></li></ul><h3 id="4、缺陷遗留问题"><a href="#4、缺陷遗留问题" class="headerlink" title="4、缺陷遗留问题"></a>4、缺陷遗留问题</h3><p>缺陷遗留率：是否达标? 3%、一般、提示没有关闭的缺陷数/缺陷总数</p><ul><li>对于影响大的问题，不能遗留，需要在当前版本立马解决</li><li>对于某些兼容性问题且只有ie6浏览器会出现问题时，可以忽略，因为有规避措施，换浏览器就可以解决</li></ul><span id="more"></span><h3 id="5、测试结论"><a href="#5、测试结论" class="headerlink" title="5、测试结论"></a>5、测试结论</h3><p>测试结论应该明确</p><h2 id="二、测试报告书写格式"><a href="#二、测试报告书写格式" class="headerlink" title="二、测试报告书写格式"></a>二、测试报告书写格式</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1编写目的"><a href="#1-1编写目的" class="headerlink" title="1.1编写目的"></a>1.1编写目的</h4><p>1）本报告按照<strong>项目的技术要求反映</strong>项目的测试结果。</p><p>2）阅读对象为项目组所有成员及其相关授权的人员。</p><h4 id="1-2项目背景"><a href="#1-2项目背景" class="headerlink" title="1.2项目背景"></a>1.2项目背景</h4><p><strong>项目背景</strong>:这里简单介绍该项目产生的背景，可以把该项目的《需求说明书》中的“项目背景”部分摘抄到这里。<br><strong>系统简介</strong>:这里简单介绍该系统的实际使用场景，需要提供的功能等信息，可以把该项目的《需求说明书》中的“系统简介”部分摘抄到这里。<br><strong>测试目标</strong>:配合开发部，使该项目最终产品达到商用标准。</p><h4 id="1-3参考文档"><a href="#1-3参考文档" class="headerlink" title="1.3参考文档"></a>1.3参考文档</h4><p><img src="/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.assets/image-20240424201439051.png" alt="image-20240424201439051" style="zoom:67%;"></p><h3 id="2、测试设计简介"><a href="#2、测试设计简介" class="headerlink" title="2、测试设计简介"></a>2、测试设计简介</h3><h4 id="2-1-测试用例设计"><a href="#2-1-测试用例设计" class="headerlink" title="2.1 测试用例设计"></a>2.1 测试用例设计</h4><p>设计测试用例点xx个</p><p>把每个模块设计的用例记录下来</p><p><img src="/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.assets/image-20240424201427523.png" alt="image-20240424201427523" style="zoom:67%;"></p><h4 id="2-2-测试环境与配置"><a href="#2-2-测试环境与配置" class="headerlink" title="2.2 测试环境与配置"></a>2.2 测试环境与配置</h4><p><img src="/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.assets/image-20240424201416838.png" alt="image-20240424201416838"></p><h4 id="2-3-测试方法与工具"><a href="#2-3-测试方法与工具" class="headerlink" title="2.3 测试方法与工具"></a>2.3 测试方法与工具</h4><ul><li><p>测试方法：手工测试</p></li><li><p>测试工具：</p><p>xmind：设计测试用例；</p><p>word：编写测试计划、测试报告；</p><p>excel：编写测试用例；</p><p>禅道：管理测试用例与缺陷；</p><p>自动化测试: Selenium、requests；</p><p>接口测试：JMeter、Postman；</p><p>性能测试：JMeter；</p><p>APP专项测试:Monkey、PerfDog、QNET、Fiddlerk、Wetest、手机助手；</p></li></ul><h3 id="3、测试结果及分析"><a href="#3、测试结果及分析" class="headerlink" title="3、测试结果及分析"></a>3、测试结果及分析</h3><h4 id="3-1-测试执行情况与记录"><a href="#3-1-测试执行情况与记录" class="headerlink" title="3.1 测试执行情况与记录"></a>3.1 测试执行情况与记录</h4><p><img src="/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.assets/image-20240424201416838.png" alt="image-20240424201416838" style="zoom:80%;"></p><h4 id="3-2-缺陷汇总"><a href="#3-2-缺陷汇总" class="headerlink" title="3.2 缺陷汇总"></a>3.2 缺陷汇总</h4><p><img src="/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.assets/image-20240424201346968.png" alt="image-20240424201346968" style="zoom:67%;"></p><p>测试中发现致命问题：XX ;严重问题:XX众;一般问:XX众;提示问题:XX个。</p><p>Postponed:因为不是很重要或技术难度过大或需求不明确，可推迟到下一个版本再解决。</p><p>Fixed:已被开发人员找到原因并修复的缺陷。</p><p>Closed:测试人员在修复的版本中验证该问题确实已修复。</p><p>Open:测试人员发现并提交的 bug。</p><p>New:测试人员发现并新建了bug 单。</p><p>这里说明在测试过程中总共提交了多少bug，其中有效bug数为多分，无效 bug数为多少，已修改bug数为多少，遗留bug数为多少。</p><p>==管理可以通过缺陷汇总来判断：==</p><ul><li><strong>缺陷密度</strong>是否正常：</li><li><strong>缺陷的遗留率</strong>是否正常：一般和提示问题数量/缺陷总数</li><li><strong>缺陷修复率</strong>是否达标：已经修复并关闭的缺陷数量/缺陷总数</li></ul><h4 id="3-3-测试覆盖率"><a href="#3-3-测试覆盖率" class="headerlink" title="3.3 测试覆盖率"></a>3.3 测试覆盖率</h4><p>覆盖率=（pass+fail）/总用例数</p><h4 id="3-4-结论"><a href="#3-4-结论" class="headerlink" title="3.4 结论"></a>3.4 结论</h4><p>用一段简洁明了的文字，总结测试的质量。<br>例如：所有的功能已经实现，基本稳定，性能已经达标；</p><ul><li>以科睿项目为例：用户管理模块，导出用户功能不可用，同时添加和修改用户时对账号、密码等输入没有进行校验，不合理的输入也能添加或修改，其他功能已经实现且比较稳定。</li></ul><p>如果不稳定，存在XXX问题。<br>但还存在以下问题（在表格中把遗留问题逐一列举，并对问题根因进行说明)</p><p><img src="/2024/04/24/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.assets/image-20240424201052974.png" alt="image-20240424201052974" style="zoom:50%;"></p><h4 id="3-5-建议"><a href="#3-5-建议" class="headerlink" title="3.5 建议"></a>3.5 建议</h4><p>对遗留问题对系统商用进行简单评估，给出是否可以商用的建议。<br>缺陷遗留比较多，还有XXX严重问题没解决，建议修改后回归测试再评估。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是测试报告？&lt;/p&gt;
&lt;p&gt;测试报告是测试人员在&lt;strong&gt;完成整个系统的测试工作之后&lt;/strong&gt;所撰写的文档，该文档可以反映测试&lt;strong&gt;过程&lt;/strong&gt;与测试&lt;strong&gt;结果&lt;/strong&gt;，是对阶段性测试任务的&lt;u&gt;总结&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试报告作用？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以评估项目当前状态和产品质量&lt;/li&gt;
&lt;li&gt;确定产品是否准备好发布的最终文档&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一、测试报告的几大要素&quot;&gt;&lt;a href=&quot;#一、测试报告的几大要素&quot; class=&quot;headerlink&quot; title=&quot;一、测试报告的几大要素&quot;&gt;&lt;/a&gt;一、测试报告的几大要素&lt;/h2&gt;&lt;h3 id=&quot;1、人力投入&quot;&gt;&lt;a href=&quot;#1、人力投入&quot; class=&quot;headerlink&quot; title=&quot;1、人力投入&quot;&gt;&lt;/a&gt;1、人力投入&lt;/h3&gt;&lt;p&gt;对不同测试阶段所花的时间有清晰记录&lt;/p&gt;
&lt;p&gt;eg. 测试用例编写：人员、工作量&lt;/p&gt;
&lt;p&gt;测试执行：人员、工作量&lt;/p&gt;
&lt;h3 id=&quot;2、用例覆盖度&quot;&gt;&lt;a href=&quot;#2、用例覆盖度&quot; class=&quot;headerlink&quot; title=&quot;2、用例覆盖度&quot;&gt;&lt;/a&gt;2、用例覆盖度&lt;/h3&gt;&lt;p&gt;==用例覆盖率=（pass+fail）/总用例数==&lt;/p&gt;
&lt;p&gt;用例状态：pass（通过）、fail（未通过）、NT（not test尚未测试）、block（阻塞，暂时没有条件执行）、investigate（观察中，正在测试）&lt;/p&gt;
&lt;p&gt;eg.pass和fail一共251，总用例263个&lt;/p&gt;
&lt;p&gt;用例覆盖率=251/263=95%&lt;/p&gt;
&lt;h3 id=&quot;3、缺陷统计&quot;&gt;&lt;a href=&quot;#3、缺陷统计&quot; class=&quot;headerlink&quot; title=&quot;3、缺陷统计&quot;&gt;&lt;/a&gt;3、缺陷统计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;bug严重等级：其中致命bug少的原因——开发自测和冒烟测试已经筛掉了大部分致命bug&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;功能型bug最多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bug状态：激活、已解决、已关闭&lt;/p&gt;
&lt;p&gt;==缺陷遗留率=（激活+已解决）/总bug数==&lt;/p&gt;
&lt;p&gt;只认准已关闭的bug为已解决&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bug来源：一般是需求、编码类bug较多&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4、缺陷遗留问题&quot;&gt;&lt;a href=&quot;#4、缺陷遗留问题&quot; class=&quot;headerlink&quot; title=&quot;4、缺陷遗留问题&quot;&gt;&lt;/a&gt;4、缺陷遗留问题&lt;/h3&gt;&lt;p&gt;缺陷遗留率：是否达标? 3%、一般、提示没有关闭的缺陷数/缺陷总数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于影响大的问题，不能遗留，需要在当前版本立马解决&lt;/li&gt;
&lt;li&gt;对于某些兼容性问题且只有ie6浏览器会出现问题时，可以忽略，因为有规避措施，换浏览器就可以解决&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试基础" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>测试需求</title>
    <link href="https://laylaycjl.github.io/2024/03/27/%E6%B5%8B%E8%AF%95%E9%9C%80%E6%B1%82/"/>
    <id>https://laylaycjl.github.io/2024/03/27/%E6%B5%8B%E8%AF%95%E9%9C%80%E6%B1%82/</id>
    <published>2024-03-27T07:32:39.000Z</published>
    <updated>2024-05-17T02:37:23.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、测什么？"><a href="#一、测什么？" class="headerlink" title="一、测什么？"></a>一、测什么？</h1><p>测试点思路步骤如下：正常+异常</p><p>1、正常功能：单个功能冒烟、看正常功能是否可以使用。</p><p>2、单个功能项验证是否异常（从上到下对每一个输入项进行验证，避免遗漏）</p><p>从三个方面考虑：</p><ul><li><strong>数据长度、数据类型、是否为必填、是否可重复</strong></li><li><strong>限制约束验证（看需求规格说明书中是否对该输入项有相关规则和约束）</strong></li><li><strong>隐性需求（根据个人经验或对比同类产品，发掘隐性需求）</strong></li></ul><p>3、功能交互验证<br>模块之间传递的信息和数据，对存在功能交互的功能项</p><p>4、非功能性测试:<br>界面、易用性、兼容性、安全性、性能压力</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、测什么？&quot;&gt;&lt;a href=&quot;#一、测什么？&quot; class=&quot;headerlink&quot; title=&quot;一、测什么？&quot;&gt;&lt;/a&gt;一、测什么？&lt;/h1&gt;&lt;p&gt;测试点思路步骤如下：正常+异常&lt;/p&gt;
&lt;p&gt;1、正常功能：单个功能冒烟、看正常功能是否可以使用。&lt;/p&gt;
&lt;p&gt;2、单个功能项验证是否异常（从上到下对每一个输入项进行验证，避免遗漏）&lt;/p&gt;
&lt;p&gt;从三个方面考虑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据长度、数据类型、是否为必填、是否可重复&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;限制约束验证（看需求规格说明书中是否对该输入项有相关规则和约束）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐性需求（根据个人经验或对比同类产品，发掘隐性需求）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、功能交互验证&lt;br&gt;模块之间传递的信息和数据，对存在功能交互的功能项&lt;/p&gt;
&lt;p&gt;4、非功能性测试:&lt;br&gt;界面、易用性、兼容性、安全性、性能压力&lt;/p&gt;</summary>
    
    
    
    <category term="测试" scheme="https://laylaycjl.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试基础" scheme="https://laylaycjl.github.io/tags/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>互斥访问临界区的软/硬件实现方法</title>
    <link href="https://laylaycjl.github.io/2022/07/01/%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E8%BD%AF-%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>https://laylaycjl.github.io/2022/07/01/%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E8%BD%AF-%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</id>
    <published>2022-07-01T10:35:54.000Z</published>
    <updated>2024-03-06T04:36:50.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、软件实现"><a href="#一、软件实现" class="headerlink" title="一、软件实现"></a>一、软件实现</h1><h2 id="1、单标志法"><a href="#1、单标志法" class="headerlink" title="1、单标志法"></a>1、单标志法</h2><p>​        <strong>直接上锁</strong><br>​        （1）理解：A，B共用一个标志flag，比如为0就是A用，为1就是B用，用完之后主动把flag设置为对方使用的状态。<br>​        （2）违反 “空闲让进” 原则：限制了只能轮流使用临界资源，只能A用完B用，而不能A用完之后（B不用的情况下）A再用一次。主要原因是只有一个标志，且每次使用后都要把标志换成对方用，这就导致标志不可能连续是1，或者连续是0。</p><h2 id="2、双标志法先检查"><a href="#2、双标志法先检查" class="headerlink" title="2、双标志法先检查"></a>2、双标志法先检查</h2><p>​        <strong>先检查再上锁</strong><br>​        （1）理解：A，B两个进程各一个标志，表示是否上锁（这里上锁指的是有访问临界资源的意愿），A先检查B有没有上锁，B没有的话，A就上锁，然后访问。B先检查A有没有上锁，A没有的话，B就上锁，然后访问。<br>​        （2）违反 “忙则等待” 原则：在A检查完之后，发生中断还没来得及上锁，B此时就可以检查然后上锁，再返回A，虽然B此时已经上锁，但A已经检查完了，不知道B后来又上锁了，A也上个锁，就导致AB同时访问了。主要原因就是检查和上锁不是原子操作，不能一气呵成，很容易卡bug同时访问临界资源</p><span id="more"></span><h2 id="3、双标志法后检查"><a href="#3、双标志法后检查" class="headerlink" title="3、双标志法后检查"></a>3、双标志法后检查</h2><p>​        <strong>先上锁再检查</strong><br>​        （1）理解：A，B两个进程各一个标志，表示是否上锁（这里上锁指的是有访问临界资源的意愿）A先上锁表明自己想访问，再检查B有没有上锁，B没有的话，A就访问。B先上锁表明自己想访问，再检查A有没有上锁，A没有的话，B就访问。<br>​        （2）违反 “有限等待” 和 “空闲让进” 原则：A如果先上了锁，然后发生中断，B也上锁，然后B检查A的情况就会发现A已经上锁了，就等待A进程使用结束再使用，此时回到A进程，A发现B也上锁，就等待B解锁，此时就形成了A、B相互等待对方释放资源。</p><h2 id="4、Peterson’s-Alogorithm"><a href="#4、Peterson’s-Alogorithm" class="headerlink" title="4、Peterson’s Alogorithm"></a>4、Peterson’s Alogorithm</h2><p>​        <strong>单标志和双标志法后检查的结合</strong><br>​        （1）理解：A，B两个进程各一个标志，外加一个turn标志指示谁更优先，只有上锁且turn为自己优先时才能使用临界资源。A先上锁，然后将对方（B）设置为更优先，只有当B没有上锁或者A自身优先级更高时才会使用临界资源。B先上锁，然后将对方（A）设置为更优先，只有当A没有上锁或者B自身优先级更高时才会使用临界资源。<br>​        （2）违反 “让权等待” 原则：因为算法里等待是执行while空循环直到对方让出资源，也就是一直霸占着CPU执行while循环，而不是交出处理机资源，让权等待。</p><h1 id="二、硬件实现（低级方法）（元方法）"><a href="#二、硬件实现（低级方法）（元方法）" class="headerlink" title="二、硬件实现（低级方法）（元方法）"></a>二、硬件实现（低级方法）（元方法）</h1><h2 id="1、中断屏蔽法"><a href="#1、中断屏蔽法" class="headerlink" title="1、中断屏蔽法"></a>1、中断屏蔽法</h2><p>用开关中断来实现临界区访问的排他性与原子性</p><p>违反 “让权等待” 原则</p><p>缺点是：<br>①限制了处理机交替执行程序的能力<br>②且开关中断属于特权指令，要在内核态才能运行，所以这个方法只适合内核进程，用户进程如果能随意开关中断会让系统很危险<br>③对多处理机系统无效，开关中断只限制了一个处理机只能有一个进程访问临界资源，当有多个处理机的时候很有可能导致不同处理机的多个进程同时访问临界资源        </p><h2 id="2、硬件指令法"><a href="#2、硬件指令法" class="headerlink" title="2、硬件指令法"></a>2、硬件指令法</h2><h3 id="（1）TestAndSet指令（TS指令）（TSL指令）"><a href="#（1）TestAndSet指令（TS指令）（TSL指令）" class="headerlink" title="（1）TestAndSet指令（TS指令）（TSL指令）"></a>（1）TestAndSet指令（TS指令）（TSL指令）</h3><p>TSL = TestSetLock<br>实质上和软件实现的 “双标志先检查” 一样，只不过这个是用硬件实现，保证了过程的原子性，不会被中断</p><h3 id="（2）Swap指令（Exchange指令）（XCHG指令）"><a href="#（2）Swap指令（Exchange指令）（XCHG指令）" class="headerlink" title="（2）Swap指令（Exchange指令）（XCHG指令）"></a>（2）Swap指令（Exchange指令）（XCHG指令）</h3><p>违反 “让权等待” 原则</p><p>和TestAndSet指令逻辑一样，只是具体实现方法上有差别<br>适合多处理机，实现简单</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、软件实现&quot;&gt;&lt;a href=&quot;#一、软件实现&quot; class=&quot;headerlink&quot; title=&quot;一、软件实现&quot;&gt;&lt;/a&gt;一、软件实现&lt;/h1&gt;&lt;h2 id=&quot;1、单标志法&quot;&gt;&lt;a href=&quot;#1、单标志法&quot; class=&quot;headerlink&quot; title=&quot;1、单标志法&quot;&gt;&lt;/a&gt;1、单标志法&lt;/h2&gt;&lt;p&gt;​        &lt;strong&gt;直接上锁&lt;/strong&gt;&lt;br&gt;​        （1）理解：A，B共用一个标志flag，比如为0就是A用，为1就是B用，用完之后主动把flag设置为对方使用的状态。&lt;br&gt;​        （2）违反 “空闲让进” 原则：限制了只能轮流使用临界资源，只能A用完B用，而不能A用完之后（B不用的情况下）A再用一次。主要原因是只有一个标志，且每次使用后都要把标志换成对方用，这就导致标志不可能连续是1，或者连续是0。&lt;/p&gt;
&lt;h2 id=&quot;2、双标志法先检查&quot;&gt;&lt;a href=&quot;#2、双标志法先检查&quot; class=&quot;headerlink&quot; title=&quot;2、双标志法先检查&quot;&gt;&lt;/a&gt;2、双标志法先检查&lt;/h2&gt;&lt;p&gt;​        &lt;strong&gt;先检查再上锁&lt;/strong&gt;&lt;br&gt;​        （1）理解：A，B两个进程各一个标志，表示是否上锁（这里上锁指的是有访问临界资源的意愿），A先检查B有没有上锁，B没有的话，A就上锁，然后访问。B先检查A有没有上锁，A没有的话，B就上锁，然后访问。&lt;br&gt;​        （2）违反 “忙则等待” 原则：在A检查完之后，发生中断还没来得及上锁，B此时就可以检查然后上锁，再返回A，虽然B此时已经上锁，但A已经检查完了，不知道B后来又上锁了，A也上个锁，就导致AB同时访问了。主要原因就是检查和上锁不是原子操作，不能一气呵成，很容易卡bug同时访问临界资源&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://laylaycjl.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="互斥访问临界区" scheme="https://laylaycjl.github.io/tags/%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    
  </entry>
  
</feed>
